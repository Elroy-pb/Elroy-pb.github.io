<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>android-Handler机制-2</title>
    <url>/2021/07/27/android-Handler%E6%9C%BA%E5%88%B6-2/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Handle---消息分发机制</title>
    <url>/2021/07/26/android-Handler%E6%9C%BA%E5%88%B6-1/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Message</td>
<td align="center">消息</td>
<td align="left">使用了享元设计模式 链表的数据结构</td>
<td align="left">详情</td>
</tr>
<tr>
<td align="left">MessageQuene</td>
<td align="center">消息队列</td>
<td align="left">单链表的数据结构</td>
<td align="left">优先级的队列 — 根据时间先后顺序排队的单链表</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="center">message的处理者</td>
<td align="left">即线程间传递的对象，传递的信息包含在其中    Handler的构造函 ，在构造函数中初始化了一个Looper 和 MessageQueue。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ThreadLocal</td>
<td align="center">数据结构是键值对</td>
<td align="left">只有在指定的线程可以获取到存储的数据</td>
<td align="left">获取线程唯一的变量 Theadlocal value 线程内部的数据存储类,使用场景：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本</td>
</tr>
<tr>
<td align="left">Looper</td>
<td align="center">循环器</td>
<td align="left"><img src="code_looper_1.jpg" alt="code_looper"></td>
<td align="left">类Looper的prepare的函数,即是对Looper进行了初始化，将Looper对象引用保存在sThreadLocal中，先保证了Looper和Threadlocal-1V1关系,由于sThreadLocal获取的值是通过获取当前线程获取线程唯一的变量,这样就保证了一个线程只有一个looper</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-APK构建流程</title>
    <url>/2021/07/26/android-APK%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Apk构建流程"><a href="#Apk构建流程" class="headerlink" title="Apk构建流程"></a>Apk构建流程</h1><h2 id="Apk是什么"><a href="#Apk是什么" class="headerlink" title="Apk是什么"></a>Apk是什么</h2><h2 id="Apk构成的属性"><a href="#Apk构成的属性" class="headerlink" title="Apk构成的属性"></a>Apk构成的属性</h2><h2 id="Apk编译的流程"><a href="#Apk编译的流程" class="headerlink" title="Apk编译的流程"></a>Apk编译的流程</h2><ol>
<li>通过<strong>aapt-Android Asset Packing Tool</strong> 打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）  </li>
</ol>
<blockquote>
<p>这一过程主要是aapt对res和asset文件夹，AndroidManifest.xml，android库(aar,jar)等的资源文件进行处理。  </p>
<ul>
<li>先检查<strong>AndroidManifest.xml</strong>的合法性  </li>
<li>然后编译res与asserts目录下的资源并生成resource.arsc文件  </li>
<li>再生成R文件。</li>
</ul>
</blockquote>
<p>除了assets和res/raw资源被原封不动地打包进APK之外，其它的资源都会被编译或者处理，<em>大部分文本格式的XML资源文件会被编译成二进制格式的XML资源文件</em>。<br>除了assets资源之外，其他的资源都会在R文件中被赋予一个资源ID。也就是说，R文件中只会存在id，真正的资源存在于resource.arsc中，resource.arsc相当于一个资源索引表，资源id是key，value是资源路径。我们使用drawable-xdpi或者drawable-xxdpi这些不同分辨率的图片的时候，就是依靠resource.arsc根据设备的分辨率选择不同的图片</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190915004258.png" alt="R.java"><br> (R.java相关知识)<br>2. 处理.aidl文件，生成对应的Java接口文件<br>3. 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 (编译期超出64k?)<br>4. 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex<br>5. 通过<strong>Japkbuilder</strong>J工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk<br>6. 通过<strong>Jarsigner</strong>工具，对上面的apk进行debug或release签名<br>通过zipalign工具，将签名后的apk进行对齐处理<br>(引申出问题，为什么需要签名，签名的方式有几种，有什么区别？)<br>7. 通过<strong>zipalign</strong>工具，将签名后的apk进行对齐处理<br>(引申一个问题，为什么需要对齐？)<br>8. 混淆proguard：proguard主要的目的是混淆代码，保护应用源代码。次要的功能还有移除无用类等，优化字节码，缩小包体积。  </p>
<h1 id="APK扩展性问题"><a href="#APK扩展性问题" class="headerlink" title="APK扩展性问题:"></a>APK扩展性问题:</h1><h2 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h2><h3 id="1-R-java是什么-R-java构成"><a href="#1-R-java是什么-R-java构成" class="headerlink" title="1. R.java是什么(R.java构成)"></a>1. <em>R.java是什么(R.java构成)</em></h3><blockquote>
<p>R.java由ADT(aapt)编译生成，<br>记录应用apk-res路径所有资源，并根据这些资源建立对应的ID(生成唯一的标识符)<br>编译期间，同一个资源在普通的apk中只会属于一个<strong>package</strong>，一个<strong>type</strong>，只拥有一个<strong>entry次序</strong>。<br>以0x01开头的就是系统已经内置的资源id，以0x7f开头的是咱们自己添加的app资源id </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/%E8%B5%84%E6%BA%90id.png" alt="R.java"> </p>
<blockquote>
<p>由于项目开发是多模块的开发 - 编译期相关的知识</p>
<ul>
<li>主模块中的R.java中的字段以final修饰，以常量形式存在。  </li>
<li>库模块中的R.java中的字段不以final修饰，以变量形式被项目中的代码所引用。  </li>
</ul>
</blockquote>
<h4 id="Android资源的合并"><a href="#Android资源的合并" class="headerlink" title="Android资源的合并"></a>Android资源的合并</h4><blockquote>
<p>覆盖的优先级如下：<br>build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependences</p>
</blockquote>
<blockquote>
<p>这种依赖关系不同于gradle里面的implementation依赖传递，implementation是跨级不能传递，但是R文件的生成是跨级可以传递的。<br>module的R文件数 = 依赖的module/aar数量 + 1(自身的R文件)<br>R.文件的生成是底层到上层 </p>
</blockquote>
<h3 id="为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？"><a href="#为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？" class="headerlink" title="为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？"></a>为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？</h3><blockquote>
<p><em>比较早的aapt的版本生成的非主模块的资源id确实都是final修饰的，这样会带来一个问题，这些资源id全部内联到代码中，一旦新增或者删除，修改了资源，资源id就会有变化，所有的代码都需要重新编译，造成严重的编译耗时</em>。  </p>
</blockquote>
<p>后来改为主模块final常量方式内联，非主模块引用方式，这样等按照从下到上编译到App模块的时候，所有的资源id都已经确定了，底层模块的资源只需要通过引用就能拿到自己对应的id，而修改(新增，删除，修改)了资源之后，也只需要重新生成R文件就好了。编译耗时大大减少。</p>
<p>在我们平常打包的时候，反编译apk，再合并资源回编时，也是要重新生成R文件。  </p>
<p>开发时，在其他module代码引用资源文件时,使用以下代码进行索引  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return a resource identifier for the given resource name.  A fully</span><br><span class="line"> * qualified resource name is of the form &quot;package:type/entry&quot;.  The first</span><br><span class="line"> * two components (package and type) are optional if defType and</span><br><span class="line"> * defPackage, respectively, are specified here.</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;Note: use of this function is discouraged.  It is much more</span><br><span class="line"> * efficient to retrieve resources by identifier than by name.</span><br><span class="line"> * </span><br><span class="line"> * @param name The name of the desired resource.</span><br><span class="line"> * @param defType Optional default resource type to find, if &quot;type/&quot; is</span><br><span class="line"> *                not included in the name.  Can be null to require an</span><br><span class="line"> *                explicit type.</span><br><span class="line"> * @param defPackage Optional default package to find, if &quot;package:&quot; is</span><br><span class="line"> *                   not included in the name.  Can be null to require an</span><br><span class="line"> *                   explicit package.</span><br><span class="line"> * </span><br><span class="line"> * @return int The associated resource identifier.  Returns 0 if no such</span><br><span class="line"> *         resource was found.  (0 is not a valid resource ID.)</span><br><span class="line"> */</span><br><span class="line">public int getIdentifier(String name, String defType, String defPackage) &#123;</span><br><span class="line">    return mResourcesImpl.getIdentifier(name, defType, defPackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？"><a href="#为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？" class="headerlink" title="为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？"></a>为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？</h3><p>因为资源id只是表示资源的次序，而不是别的跟资源本身绑定的属性。当到了不同的模块以后，参与编译的资源变多了，那次序肯定会改变。资源id也就改变了。并且子模块的资源id只是引用形式存在于代码中，id具体是什么值并不是很care。</p>
<h3 id="apk或者aab，为什么需要对齐？"><a href="#apk或者aab，为什么需要对齐？" class="headerlink" title="apk或者aab，为什么需要对齐？"></a><em>apk或者aab</em>，为什么需要对齐？</h3><blockquote>
<p>zipalign的主要工作是将apk包进行对齐处理，使apk包中的所有资源文件举例文件起始偏移为4字节的整数倍，这样通过内存映射访问apk时的速度会更快。<br>为什么快呢？如果每个资源的开始位置上都是一个资源之后的4n字节，那么访问下一个资源就不用遍历，直接跳到4字节之后即可 </p>
</blockquote>
<h3 id="apk或者aab混淆的方式有哪些"><a href="#apk或者aab混淆的方式有哪些" class="headerlink" title="apk或者aab混淆的方式有哪些()"></a><em>apk或者aab</em>混淆的方式有哪些()</h3><blockquote>
</blockquote>
<p>压缩(Shrink)：检测并移除代码中无用的类、字段、方法和特性<br>优化(Optimize)：字节码进行优化，移除无用的指令。<br>混淆(Obfuscate)：使用a、b、c、d这样简短而无意义的名称，对垒、字段和方法进行重命名。<br>预检测(Preveirfy)：在Java平台对处理后的代码进行预检测，确保加载class文件是可执行的 </p>
<h3 id="“Android”-64k报错"><a href="#“Android”-64k报错" class="headerlink" title="“Android” 64k报错"></a>“Android” 64k报错</h3><p>应用及第三方库包含的方法数(method)总和超过65536，在开发的时候，会遇到一个构建的错误。<br>指明您的应用达到Android构建规定的应用的限制：</p>
<h4 id="构建错误的原因"><a href="#构建错误的原因" class="headerlink" title="构建错误的原因:"></a>构建错误的原因:</h4><h5 id="dex文件格式的限制"><a href="#dex文件格式的限制" class="headerlink" title="dex文件格式的限制"></a>dex文件格式的限制</h5><p>Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 二进制文件形式的可执行字节码文件，这些文件包含用来运行应用的已编译代码。<br>Dalvik Executable 规范将可在单个 DEX 文件内引用的方法总数限制为 65536 (其中包括 Android 框架方法、库方法以及您自己的代码中的方法)</p>
<h5 id="其他限制"><a href="#其他限制" class="headerlink" title="其他限制"></a>其他限制</h5><p>系统对dex文件进行优化操作时分配的缓冲区大小的限制 ，方法如果超出缓存区，同样也是会报错的。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android App Bundles</title>
    <url>/2021/07/19/google-aab/</url>
    <content><![CDATA[<h1 id="Google-Android-App-Bundles"><a href="#Google-Android-App-Bundles" class="headerlink" title="Google - Android App Bundles"></a>Google - Android App Bundles</h1><p>2018 年的 Google I/O ，Google 向 Android 引入了新 App 动态化框架（即 Android App Bundle，缩写为<strong>AAB</strong>)</p>
<blockquote>
<p>App 动态化框架，动态化概念指的是 Play Dynamic Delivery </p>
<blockquote>
<p><strong>上线要求</strong>:从 2021 年 8 月起，新应用需要使用 Android App Bundle 才能在 Google Play 中发布。  </p>
</blockquote>
</blockquote>
<h2 id="About-Android-App-Bundles"><a href="#About-Android-App-Bundles" class="headerlink" title="About Android App Bundles"></a>About Android App Bundles</h2><blockquote>
<p>Android App Bundle 是一种包含编译后代码和资源文件的新的上传格式（.aab） </p>
</blockquote>
<p>补充:<strong>Android Application Bundle</strong> != <strong>Apk</strong><br>App Bundle 纯粹是为了上传设计的文件，用户无法直接安装和使用它。<br>虽然AAB和Apk本质上都是压缩包,但是内部的目录结构完全不同，以下是一个Abb正常的aab文件结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–BundleConfig.pb ： 打包bundle的时候，自动生成</span><br><span class="line">–base : base目录</span><br><span class="line">——assets: 对应apk的assets目录</span><br><span class="line">——dex: 原apk中classes.dex,classes2.dex…都放这里</span><br><span class="line">——lib: 原apk中lib目录都放这里</span><br><span class="line">——manifest: 原apk的AndroidManifest.xml放这里，需要是编译后的AndroidManifest.xml</span><br><span class="line">——res：apk中的资源放这里，需要是编译后的资源</span><br><span class="line">——root: apk中相对于根目录的其他资源文件</span><br><span class="line">——resources.pb：编译资源的时候会生成的</span><br><span class="line">——assets.pb:编译bundle的时候会生成的</span><br><span class="line">——native.pb: 编译bundle的时候会生成的</span><br></pre></td></tr></table></figure>

<h2 id="Google-Play-Dynamic-Delivery"><a href="#Google-Play-Dynamic-Delivery" class="headerlink" title="Google Play Dynamic Delivery"></a>Google Play Dynamic Delivery</h2><blockquote>
<p>简介:Google Play 推出新 app 交付模式，叫做动态交付 (Dynamic Delivery)，它根据每个用户的设备信息，使用开发者上传的 app bundle 来生成对应的 apk 文件。</p>
<blockquote>
<p><img src="https://conorlee.top/images/blogimages/2019/640.gif" alt="AAB">  </p>
</blockquote>
</blockquote>
<h2 id="Play-Asset-Delivery"><a href="#Play-Asset-Delivery" class="headerlink" title="Play Asset Delivery"></a>Play Asset Delivery</h2><blockquote>
<p>Play Asset Delivery (PAD)可以让依靠 Google Play 来托管和提供你的资产包，PAD提供灵活的分发模式，本质上减少包的体积，让用户更佳的体验,目前分发模式有3种，分别为<br><strong>1.install-time 2.fast-follow 3.on-demand</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分发模式</th>
<th align="center">大小限制</th>
<th align="left">简介</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">install-time  =&gt; 安装时分发</td>
<td align="center">总下载大小上限为1GB</td>
<td align="left">资源包在用户安装应用时进行分发，”预先”资源包</td>
<td align="left">在应用启动是使用，用户无法修改或删除这些资源包</td>
</tr>
<tr>
<td align="left">fast-follow =&gt; 快速跟进式分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包在用户安装应用后立即自动下载</td>
<td align="left">用户无需打开应用即可开始 fast-follow 下载。此类下载不会阻止用户访问应用。</td>
</tr>
<tr>
<td align="left">on-demand =&gt; 按需分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包会在应用运行时进行下载</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意 ！！！</strong>：如果为资源包选择 <strong>install-time 分发类型</strong>，就无需在游戏中使用 <strong>Play Asset Delivery API</strong>。这些资源包与主应用 APK同时安装。<br>目前公司项目使用就是分发模式就是 <strong>install-time</strong></p>
<p>由于google规定需要apk&lt;150m，等于aab中的base目录&lt;150m，如果超出限制，需要把多出的资源迁移到install-time，让google去动态下发资源</p>
<h1 id="软件使用说明"><a href="#软件使用说明" class="headerlink" title="软件使用说明"></a>软件使用说明</h1><h3 id="需要提前安装的环境"><a href="#需要提前安装的环境" class="headerlink" title="需要提前安装的环境"></a>需要提前安装的环境</h3><ul>
<li>需要自己额外再安装的路径  <ol>
<li>python3</li>
<li>aapt  </li>
<li>gradle </li>
<li>as-pro  ==&gt; 模板工程 </li>
</ol>
</li>
<li>该工具内置了反编译的环境 请勿随意修改路径  <ol>
<li>apktool  </li>
<li>dex2jar  </li>
<li>smali  </li>
</ol>
</li>
</ul>
<p>2 需要在该工具路径下/tool/apktool/signature/config/apk.ini文件配置以下路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置项 后续看项目的需求支持可增加参数</span><br><span class="line">[config]</span><br><span class="line"># 注意所有配置项需要顶行写，&quot;=&quot; 号两边和行首尾不能有空格</span><br><span class="line"># AS 路径 </span><br><span class="line">as_path=/Users/zhupengbo/Desktop/S3/S3_Hw</span><br><span class="line"># AAB 生成的路径 必填</span><br><span class="line">abb_path=/Users/zhupengbo/tool/apktool/apk/abb</span><br><span class="line"># 版本号和版本名</span><br><span class="line">versionCode=1</span><br><span class="line">versionName=1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>3.该项目增加了pad配置表<br>3.1 <strong>aab_pad.xls</strong> 配置表路径在 <strong>/apktool/signature/config</strong> 的路径下<br>3.2 配置的方法<br>支持配置<strong>文件路径</strong>和<strong>文件夹</strong><br>S3项目以resource路径下进行配表，该路径包含了游戏内的资源  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置形式为:resource/路径</span><br></pre></td></tr></table></figure>


<p><strong>aab_pad.xls 格式如下-示例</strong></p>
<table>
<thead>
<tr>
<th align="left">Path</th>
</tr>
</thead>
<tbody><tr>
<td align="left">resource/model</td>
</tr>
<tr>
<td align="left">resource/Video</td>
</tr>
<tr>
<td align="left">resource/allRes.json</td>
</tr>
<tr>
<td align="left">resource/ui</td>
</tr>
</tbody></table>
<p>4 该工具支持下终端下执行，调用示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Users/zhupengbo/tool/apktool/android_pack.sh /Users/zhupengbo/tool/apktool/apk/apk/AAA.apk</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-崩溃优化</title>
    <url>/2021/07/23/android-native/</url>
    <content><![CDATA[<h1 id="崩溃优化"><a href="#崩溃优化" class="headerlink" title="崩溃优化"></a>崩溃优化</h1><h2 id="Android-崩溃分析"><a href="#Android-崩溃分析" class="headerlink" title="Android 崩溃分析"></a>Android 崩溃分析</h2><p>Android 崩溃基本分为 <strong>Java 崩溃</strong>和 <strong>Native 崩溃</strong><br>简单来说，Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出。<br>那 Native 崩溃又是怎么产生的呢？一般都是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，<br>这些都会产生相应的 <strong>signal 信号</strong>，导致程序异常退出。</p>
<h3 id="Native-崩溃"><a href="#Native-崩溃" class="headerlink" title="Native 崩溃"></a>Native 崩溃</h3><blockquote>
<ol>
<li>在 Unix-like 系统中，所有的崩溃都是编程错误或者硬件错误相关的，系统遇到不可恢复的错误时会触发崩溃机制让程序退出，如除零、段地址错误等。</li>
<li>异常发生时，CPU 通过异常中断的方式，触发异常处理流程。不同的处理器，有不同的异常中断类型和中断处理方式。</li>
<li>linux 把这些中断处理，统一为信号量，可以注册信号量向量进行处理。</li>
<li>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。  </li>
</ol>
</blockquote>
<h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="https://upload-images.jianshu.io/upload_images/2718191-cf676fb7776e121b.png" alt="信号机制"> </p>
<h5 id="1-信号的接收"><a href="#1-信号的接收" class="headerlink" title="(1) 信号的接收"></a>(1) 信号的接收</h5><p>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入<strong>内核态</strong> 。<br>！！！注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<h5 id="2-信号的检测"><a href="#2-信号的检测" class="headerlink" title="(2) 信号的检测"></a>(2) 信号的检测</h5><p>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<p>1.进程从内核态返回到用户态前进行信号检测</p>
<p>2.进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</p>
<p>当发现有新信号时，便会进入下一步，信号的处理。</p>
<h5 id="3-信号的处理"><a href="#3-信号的处理" class="headerlink" title="(3) 信号的处理"></a>(3) 信号的处理</h5><p>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<p>四、捕捉native crash<br>1.注册信号处理函数<br>第一步就是要用信号处理函数捕获到native crash(SIGSEGV, SIGBUS等)。在posix系统，可以用sigaction()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;signal.h&gt; </span><br><span class="line">int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));</span><br></pre></td></tr></table></figure>
<p>signum：代表信号编码，可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号，如果为这两个信号定义自己的处理函数，将导致信号安装错误。</p>
<p>act：指向结构体sigaction的一个实例的指针，该实例指定了对特定信号的处理，如果设置为空，进程会执行默认处理。</p>
<p>oldact：和参数act类似，只不过保存的是原来对相应信号的处理，也可设置为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sigaction sa_old;  </span><br><span class="line">memset(&amp;sa, 0, sizeof(sa));  </span><br><span class="line">sigemptyset(&amp;sa.sa_mask);  </span><br><span class="line">sa.sa_sigaction = my_handler;  </span><br><span class="line">sa.sa_flags = SA_SIGINFO;</span><br><span class="line">if (sigaction(sig, &amp;sa, &amp;sa_old) == 0) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.设置额外栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigaltstack(const stack_t *ss, stack_t *oss);</span><br></pre></td></tr></table></figure>
<p>SIGSEGV很有可能是栈溢出引起的，如果在默认的栈上运行很有可能会破坏程序运行的现场，无法获取到正确的上下文。而且当栈满了（太多次递归，栈上太多对象），系统会在同一个已经满了的栈上调用SIGSEGV的信号处理函数，又再一次引起同样的信号。</p>
<p>我们应该开辟一块新的空间作为运行信号处理函数的栈。可以使用sigaltstack在任意线程注册一个可选的栈，保留一下在紧急情况下使用的空间。（系统会在危险情况下把栈指针指向这个地方，使得可以在一个新的栈上运行信号处理函数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack_t stack;  </span><br><span class="line">memset(&amp;stack, 0, sizeof(stack));  </span><br><span class="line">/* Reserver the system default stack size. We don&#x27;t need that much by the way. */  </span><br><span class="line">stack.ss_size = SIGSTKSZ;  </span><br><span class="line">stack.ss_sp = malloc(stack.ss_size);  </span><br><span class="line">stack.ss_flags = 0;  </span><br><span class="line">/* Install alternate stack size. Be sure the memory region is valid until you revert it. */  </span><br><span class="line">if (stack.ss_sp != NULL &amp;&amp; sigaltstack(&amp;stack, NULL) == 0) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.兼容其他signal处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static void my_handler(const int code, siginfo_t *const si, void *const sc) &#123;</span><br><span class="line">...  </span><br><span class="line">  /* Call previous handler. */  </span><br><span class="line">  old_handler.sa_sigaction(code, si, sc);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某些信号可能在之前已经被安装过信号处理函数，而sigaction一个信号量只能注册一个处理函数，这意味着我们的处理函数会覆盖其他人的处理信号</p>
<p>保存旧的处理函数，在处理完我们的信号处理函数后，在重新运行老的处理函数就能完成兼容。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-外挂篇</title>
    <url>/2021/07/27/android-%E5%A4%96%E6%8C%82%E7%AF%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo CMD</title>
    <url>/2021/07/19/hexo/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;博客名称&quot;  =&gt; hexo new &quot;博客名称&quot;   #这两个都是创建新文章，前者是简写模式</span><br><span class="line">hexo p  =&gt; hexo publish</span><br><span class="line">hexo g  =&gt; hexo generate  #生成</span><br><span class="line">hexo s  =&gt; hexo server  #启动服务预览</span><br><span class="line">hexo d  =&gt; hexo deploy  #部署  </span><br><span class="line"></span><br><span class="line">hexo server   #Hexo 会监视文件变动并自动更新，无须重启服务器。</span><br><span class="line">hexo server -s   #静态模式</span><br><span class="line">hexo server -p 5000   #更改端口</span><br><span class="line">hexo server -i 192.168.1.1   #自定义IP</span><br><span class="line">hexo clean   #清除缓存，网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g   #生成静态网页</span><br><span class="line">hexo d   #开始部署</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
