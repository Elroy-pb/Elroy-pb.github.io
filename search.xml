<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>技术写作模板</title>
    <url>/2021/10/21/%E5%86%99%E4%BD%9C%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="写作的注意事项"><a href="#写作的注意事项" class="headerlink" title="写作的注意事项"></a>写作的注意事项</h1><ul>
<li>文章<br>如果文章全篇转载，请在<strong>全文开头</strong>显著位置注明出处并链接至原文<br>如果文章内容过多，那么可以根据内容类型进行分篇处理（保持读者的阅读耐心)</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>初衷</li>
<li>适合人群</li>
<li>内容结构</li>
<li>温馨提示</li>
</ul>
<h1 id="文章主体"><a href="#文章主体" class="headerlink" title="文章主体"></a>文章主体</h1><p>文章主体一定要符合文章前言的内容结构，除此之外内容尽量符合以下一些特性：</p>
<ul>
<li>图文并茂</li>
<li>思维导图</li>
<li>框架大图</li>
<li>表格分类对比</li>
<li>可视化数据分析</li>
<li>列表分类</li>
</ul>
<h1 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h1><ul>
<li>标题</li>
</ul>
<p>文章有且仅有 1 个一级标题<br>标题统一采用「#」标记<br>标题逐级递增（例如避免在一级标题下直接新增三级标题）<br>标题的「#」标记和文本之间必须要有 1 个空格，否则类似掘金平台无法识别标题<br>标题和子标题内容避免完全一致<br>标题避免有标点符号 “.,;:!?。，；：！？”<br>标题前后应该有空行<br>标题避免缩进<br>避免出现四级标题，保持简洁<br>避免出现孤儿标题<br>不要使用加粗代替标题<br>如果当前标题下内容过于简洁（例如只有一个简短的段落），可以需要考虑去除标题  </p>
<blockquote>
<p>标题的作用除了明确主题之外，重点是快进到想阅读的部分</p>
</blockquote>
<blockquote>
<p>作者：子弈<br>链接：<a href="https://juejin.cn/post/6844904168600109069">https://juejin.cn/post/6844904168600109069</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  </p>
</blockquote>
<ul>
<li>段落<br>段落之间不要产生多个连续的空白行<br>如果部分段落引用其他的技术文章，则需标明<strong>作者</strong>和<strong>来源链接</strong><br>段落开头避免缩进</li>
<li>引用<br>引用标记和内容之间避免有多个空格<br>引用前后应该有空行<br>温馨提示的内容可以采用引用的呈现形式</li>
<li>分割线<br>可以在图片下方添加或者是结尾的段落</li>
<li>代码块<br>在代码块中展示 Shell 命令不需要在命令行前加「$」符号，除非同时需要打印输出信息<br>代码块前后应该有空行<br>代码块必须指定语言类型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&#x27;load&#x27;, function() &#123;</span><br><span class="line">  console.log(&#x27;window loaded&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果部分代码引用其他的技术文章，则需标明作者和来源链接</p>
<blockquote>
<p>前方多图，流量预警⚠️ ⚠️ ⚠️ </p>
</blockquote>
<h1 id="写作工具"><a href="#写作工具" class="headerlink" title="写作工具"></a>写作工具</h1><ul>
<li><a href="https://carbon.now.sh/">代码块—carbon</a></li>
</ul>
<p><img src="carbon.png" alt="carbon"></p>
<ul>
<li><p>思维导图 - Xmind</p>
</li>
<li><p>流程图  Gilffy Diagrams</p>
</li>
<li><p>流程图 <a href="https://www.processon.com/">Process On</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>利弊分析</li>
<li>局限性及可扩展性</li>
<li>注意事项</li>
<li>未来发展</li>
<li>规律分析</li>
<li>横向对比</li>
<li>技术结论</li>
<li>思想指导</li>
<li>集思广益</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://juejin.cn/post/6844904168600109069#heading-1">掘金-技术文章的写作技巧分享</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidSdk-模块化</title>
    <url>/2021/10/19/AndroidSdk-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>初衷s1和s3出包的项目是<strong>Eclipse</strong>，后更新为<strong>Android-Studio</strong>，使用<strong>Android模块化</strong>对项目进行统一的划分。</p>
<h1 id="SDK分类"><a href="#SDK分类" class="headerlink" title="SDK分类"></a>SDK分类</h1><p>SDK划分主要是以我们打包环境来区别。<br>打包环境有2种，正式环境对应正式sdk,测试环境对应测试sdk。  </p>
<ul>
<li><strong>正式环境</strong><br>正式包，用于线上，一般是接了渠道的sdk，具备了登录，充值，实名等功能。  </li>
<li><strong>测试环境</strong><br>测试包，内部测试，不包含渠道的sdk，不具备渠道sdk的功能，主要供于游戏内部测试。  </li>
</ul>
<h1 id="SDK的结构"><a href="#SDK的结构" class="headerlink" title="SDK的结构"></a>SDK的结构</h1><p>为了方便理解SDK划分和结构，我们拿S1项目举个例子，可以先看下这张图</p>
<p><img src="%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="SDK结构图">  </p>
<p>无论是测试SDK或者正式SDK都划分为2个模块,一个为common模块，一个channel模块。</p>
<p>这里我们以S1正式SDK举例.</p>
<p>正式SDK包含2个模块，也就是是s1-common-sdk,s1-channel-dalan。</p>
<h2 id="common库结构图"><a href="#common库结构图" class="headerlink" title="common库结构图"></a>common库结构图</h2><p><img src="s1-common-sdk.png" alt="s1-common-sdk结构图"><br>!!!切记common编译库包含跟unity的的游戏库一致，否则游戏会出现奇怪的问题。</p>
<hr>
<h2 id="channel结构图"><a href="#channel结构图" class="headerlink" title="channel结构图"></a>channel结构图</h2><p><img src="s1-channel-dalan.png" alt="s1-common-channel结构图">  </p>
<hr>
<p>我们把2个目录整合一下，其实正式包channel.jar的目录只是把原本的sdks下的GameSDK和HyGameApplication取出，然后单纯作为一个jar。而其他代码是作为sdk的公共库(一般情况下不变)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–com</span><br><span class="line">——hoye</span><br><span class="line">——-game</span><br><span class="line">——--sdks</span><br><span class="line">——---GameSDK(channel)   </span><br><span class="line">——---GameSDKConstants</span><br><span class="line">——---GameSDKinferface</span><br><span class="line">-----GameSDKManager(channel)</span><br><span class="line">-----HyGameApplication   </span><br><span class="line">----BosController</span><br><span class="line">----GameActivity</span><br><span class="line">----GameApplication</span><br><span class="line">----GameConfig</span><br><span class="line">----HaoyueUtils</span><br><span class="line">----JsonParse</span><br><span class="line">----ResUtils</span><br><span class="line">----TakePhotoActivity</span><br></pre></td></tr></table></figure>

<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>目前工作环境正常下的版本，后续可能会随着as版本升级而发生变动，以下版本不作为唯一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AndroidStudio-version-4.1.1  </span><br><span class="line">gradle-version-6.1.1  </span><br><span class="line">gradle-tool-3.5.0  </span><br></pre></td></tr></table></figure>


<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>之所以用模块化开发，是为了后续几点考虑</p>
<ul>
<li>多团队并行开发测试；</li>
<li>模块间解耦、重用；</li>
<li>可单独编译打包某一模块，提升开发效率 </li>
</ul>
<p>而我们的项目刚好是要打包某一模块，提升开发的效率。</p>
<h2 id="as项目的配置-—-生成as模块"><a href="#as项目的配置-—-生成as模块" class="headerlink" title="as项目的配置 — 生成as模块"></a>as项目的配置 — 生成as模块</h2><p><img src="as.png" alt="as模块">  </p>
<p>我们需要在左侧红色方框的2个配置文件内配置好<br><strong>apply.properties</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1_channel_dalan = com.android.library</span><br></pre></td></tr></table></figure>
<p><strong>setting.gradle</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include(&#x27;s1_channel_dalan&#x27;)</span><br></pre></td></tr></table></figure>
<p>以上2个配置之后，点击Sync Project with Gradle Files<br>会在右侧生成gradle模块(以模块的名称来命名)。如as模块右侧截图。在这里的项目都是生成好了，有需要的话按照以上方式添加新的模块即可。</p>
<p>读取的代码在主目录的build.gradle，这里不做展示。</p>
<h2 id="decompile转换工具库说明"><a href="#decompile转换工具库说明" class="headerlink" title="decompile转换工具库说明"></a>decompile转换工具库说明</h2><p>as截图内左上角的编译的目录是 <strong>decomplie</strong>,是转化文件格式的工具类，主要是用于 .jar文件,smali文件,.dex文件3者的转换。</p>
<p>as项目内已编写好gradle脚本(在根目录的gradle)，通过gradle调用decompile的python的脚本(smali.py)，然后<strong>smali.py</strong>调用相关的命令,生成jar包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–decompile ： 打包bundle的时候，自动生成</span><br><span class="line">——lib: 工具jar存放的目录</span><br><span class="line">——-baksmali.jar jar转化dex</span><br><span class="line">——-baksmali-2.2.2.jar</span><br><span class="line">——-smali.jar    dex转smali</span><br><span class="line">——-smali-2.2.2.ajr</span><br><span class="line">—gradle.sh 编译检查的命令</span><br><span class="line">-smali.py 调用python脚本</span><br></pre></td></tr></table></figure>

<h1 id="工程流程-—-如何打包生成jar"><a href="#工程流程-—-如何打包生成jar" class="headerlink" title="工程流程 — 如何打包生成jar"></a>工程流程 — 如何打包生成jar</h1><p>as项目内的android模块通过<strong>decompile转换库</strong>调用python命令,把java目录下的代码打成.jar包，这里打的jar包是不包含lib，也就是只包含java目录下的代码，然后替换到打包工具的对应的目录，然后打包工具生成apk。</p>
<p>我们这里举例说明一下，假设我们需要生成s1-common-sdk的jar包。</p>
<p><img src="generate-jar.png" alt="generate_jar"> </p>
<p>1.右侧Gradle模块，是根据左侧模块文件夹的文件名生成的，然后我们点击<strong>a_makeJarLib_smali</strong>即可在文件下生成对应模块的jar。</p>
<p><img src="generated-jar.png" alt="generate_jar"> </p>
<p>2.生成jar后只要提交到145远程机的打包工具对应的目录即可。</p>
<p>3.然后使用打包工具生成apk，对apk进行测试</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1.在生成jar的时候，一定分清楚对应的处理的模块，打成jar之后可以通过第三方工具，查看对应的层级代码，避免在提交打包工具的时候提交错jar，减少低成本的问题。</p>
<p>2.as模块common库的编译时要提前检查，左侧as模块的Lib目录下的unity版本是不是跟打包工具的unity版本库一致。</p>
<p>如：S1-PIUS使用的unity库是2018.jar,那么common库的模块下的unity版本也要是2018的才行，不然提交后打包工具后，会因为编译后的字节码不一致而导致黑屏或者是卡顿等其他奇怪的问题。</p>
<p>3.在项目编译时，该工具的会先提前对模块内的代码进行检查，检查通过后才可编译，在一定程度减少容错率，无法编译时，先提前检查代码。</p>
<h1 id="局限性及可扩展性"><a href="#局限性及可扩展性" class="headerlink" title="局限性及可扩展性"></a>局限性及可扩展性</h1><p>扩展性：在此项目上我在满足基本项目打包的要求上，新增了a_makeJarChannel_smali的命令:</p>
<p>可以把包含Lib的依赖和gardle远程依赖统一分成合成jar.<br>同时对生成好的jar拆分为smali，dex，改功能针对发行要求，在mac环境上已测试通过。</p>
<p>后续可继续增加扩展smali分包的功能</p>
<!-- # 文章总结
* 利弊分析
* 局限性及可扩展性
* 注意事项
* 未来发展
* 规律分析
* 横向对比
* 技术结论
* 思想指导
* 集思广益
# 参考文档

[掘金-写作技巧](https://juejin.cn/post/6844904168600109069#heading-6)  
作者：子弈  
链接：https://juejin.cn/post/6844904168600109069  
来源：稀土掘金  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  -->]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-接口和内部类</title>
    <url>/2021/10/03/Java-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<!-- 接口和内部类 -->
<h1 id="接口-—-Interface"><a href="#接口-—-Interface" class="headerlink" title="接口 — Interface"></a>接口 — Interface</h1><p>定义：<br>接口是对类一组需求的描述，实现接口的类要遵从接口的描述的定义。<br>接口中的所有方法自动地属于public，所有声明方法不必提供关键字<br>不过在实现接口的时候，必须将方法声明为public，否则编译器会给出试图提供更弱的访问权限信息</p>
<pre><code>通常类实现一个接口，通常需要2个步骤
1.让类声明为实现给定的接口
2.对接口中的方法进行定义
</code></pre>
<h2 id="java十万个为什么"><a href="#java十万个为什么" class="headerlink" title="java十万个为什么"></a>java十万个为什么</h2><p>为什么接口内无法定义静态方法？</p>
<h1 id="内部类-—-inner-class"><a href="#内部类-—-inner-class" class="headerlink" title="内部类 — inner class"></a>内部类 — inner class</h1><p>内部类（inner class）是定义在另一个类中的类，其实也可以区分为外部类和内部类，这2者的关系，<br>我个人的理解就好像是<strong>火车车厢</strong>跟<strong>火车车厢内的旅客</strong>关系，火车先组装好，再把旅客放上去，旅客在车厢内，肯定是很自然拿到车厢的信息。<br>举个例子：自然拿到车厢的班次，车厢内座位。</p>
<pre><code>内部类的方法可以访问该类定义所在的作用域中的数据，包括私有数据。  
内部类可以对同一个包中的其他类隐藏起来。  
当想定义一个回调函数并且不想编写大量的代码的时候，可以使用匿名类内部类对比。
</code></pre>
<h2 id="课外补习"><a href="#课外补习" class="headerlink" title="课外补习"></a>课外补习</h2><p>嵌套是一种类与类之间的关系，而不是对象之间的关系。<br>嵌套类有2个好处：<strong>命名控制</strong>和<strong>访问控制</strong></p>
<h3 id="java-十万个为什么"><a href="#java-十万个为什么" class="headerlink" title="java 十万个为什么"></a>java 十万个为什么</h3><h4 id="为什么java内部类可以访问外部对象"><a href="#为什么java内部类可以访问外部对象" class="headerlink" title="为什么java内部类可以访问外部对象"></a>为什么java内部类可以访问外部对象</h4><p>java的内部类对象有一个隐式引用，实例化该内部类对象的外部对象，通过这个指针，可以访问到外部类的全部状态。<br>内部类的对象总有一个隐式的引用，它指向它的外部类对象。</p>
<h4 id="总共有多少种内部类"><a href="#总共有多少种内部类" class="headerlink" title="总共有多少种内部类"></a>总共有多少种内部类</h4><ul>
<li>4种内部类</li>
</ul>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>静态内部类</li>
<li>匿名内部类<h4 id="内部类的共性"><a href="#内部类的共性" class="headerlink" title="内部类的共性"></a>内部类的共性</h4></li>
</ul>
<p>1.内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。<br>内部类不能用普通的方式访问。内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的。<br>2.内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员的变量。  </p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>1.局部类不能用public和private访问说明符进行声明。<br>2.他的作用域被限定在这声明这个局部类的块中。<br>3.局部内部类中不可定义静态变量，可以访问外部类的局部变量(即方法内的变量)，但是变量必须是final的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Outer2 &#123;</span><br><span class="line">private int s = 100;</span><br><span class="line">private int out_i = 1;</span><br><span class="line">public void f(final int k)&#123;</span><br><span class="line">final int s = 200;</span><br><span class="line">int i = 1;</span><br><span class="line">final int j = 10;</span><br><span class="line">class Inner&#123; //定义在方法内部</span><br><span class="line">int s = 300;//可以定义与外部类同名的变量</span><br><span class="line">//static int m = 20;//不可以定义静态变量</span><br><span class="line">Inner(int k)&#123;</span><br><span class="line">inner_f(k);</span><br><span class="line">&#125;</span><br><span class="line">int inner_i = 100;</span><br><span class="line">void inner_f(int k)&#123;</span><br><span class="line">System.out.println(out_i);//如果内部类没有与外部类同名的变量，在内部类中可以直接访问外部类的实例变量</span><br><span class="line">System.out.println(k);//可以访问外部类的局部变量(即方法内的变量)，但是变量必须是final的</span><br><span class="line">// System.out.println(i);</span><br><span class="line">System.out.println(s);//如果内部类中有与外部类同名的变量，直接用变量名访问的是内部类的变量</span><br><span class="line">System.out.println(this.s);//用&quot;this.变量名&quot; 访问的也是内部类变量</span><br><span class="line">System.out.println(Outer2.this.s);//用外部&quot;外部类类名.this.变量名&quot; 访问的是外部类变量</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">new Inner(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//访问局部内部类必须先有外部类对象</span><br><span class="line">Outer2 out = new Outer2();</span><br><span class="line">out.f(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>我们在上文提到这个观点: </p>
<blockquote>
<p>内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员的变量。</p>
</blockquote>
<p>这里解释为什么，内部类是静态，那么它就是类级别的成员，根据类的加载机制(加载顺序)，就不在依赖对象而存在。所以静态内部类，不能访问外部类非静态成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Outer3 &#123;</span><br><span class="line"></span><br><span class="line">private static int i = 1;</span><br><span class="line">private int j = 10;</span><br><span class="line">public static void outer_f1()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void outer_f2()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 静态内部类可以用public，protect，private修饰</span><br><span class="line">static class Inner &#123;</span><br><span class="line">static int inner_i = 100;</span><br><span class="line">int inner_j = 200;</span><br><span class="line"></span><br><span class="line">static void inner_f1() &#123;</span><br><span class="line">System.out.println(&quot;Outer.i &quot; + i);//静态内部类只能访问外部类的静态成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inner_f2() &#123;</span><br><span class="line">// System.out.println(&quot;Outer.i&quot;+j);//静态内部类不能访问外部类的非静态成员</span><br><span class="line">// outer_f2();//包括非静态变量和非静态方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void outer_f3()&#123;</span><br><span class="line">System.out.println(Inner.inner_i);</span><br><span class="line">Inner.inner_f1();</span><br><span class="line">// 外部类访问内部类的非静态成员:实例化内部类即可</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.inner_f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Outer().outer_f3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<em><strong><strong><strong>生成（new）一个静态内部类不需要外部类成员：这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成：<br>Outer.Inner in=new Outer.Inner()；<br>而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类。静态内部类不可用private来进行定义。</strong></strong></strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StaticInnerClassTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">double[] d = new double[20];</span><br><span class="line">for (int i= 0;i&lt;d.length;i++)</span><br><span class="line">d[i] = 100 * Math.random();</span><br><span class="line">ArrayAlg.Pair p = ArrayAlg.minmax(d);</span><br><span class="line">System.out.println(&quot;min = &quot; + p.getFirst());</span><br><span class="line">System.out.println(&quot;min = &quot; + p.getSecond());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ArrayAlg</span><br><span class="line">&#123;</span><br><span class="line">public static class Pair</span><br><span class="line">&#123;</span><br><span class="line">private double first;</span><br><span class="line">private double second;</span><br><span class="line"></span><br><span class="line">public Pair(double first, double second) &#123;</span><br><span class="line">this.first = first;</span><br><span class="line">this.second = second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getFirst() &#123;</span><br><span class="line">return first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getSecond() &#123;</span><br><span class="line">return second;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Pair minmax(double[] values)&#123;</span><br><span class="line"></span><br><span class="line">double min = Double.MAX_VALUE;</span><br><span class="line">double max = Double.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">for (double v : values)&#123;</span><br><span class="line">if (min &gt; v);</span><br><span class="line">if (max &lt; v);</span><br><span class="line">&#125;</span><br><span class="line">return new Pair(min,max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>先提出问题?</p>
<p>匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new 父类构造器（参数列表）|实现接口（）    </span><br><span class="line">    &#123;    </span><br><span class="line">     //匿名内部类的类体部分    </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p>我们看到使用匿名内部类我们必须继承一个父类或者是实现一个接口，仅能继承一个父类或者是一个接口。<br>没有class的关键字，这是因为匿名类是直接使用new来生成一个对象的引用。当然是隐式的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Bird &#123;  </span><br><span class="line">    private String name;  </span><br><span class="line">  </span><br><span class="line">    public String getName() &#123;  </span><br><span class="line">        return name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setName(String name) &#123;  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public abstract int fly();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">      </span><br><span class="line">    public void test(Bird bird)&#123;  </span><br><span class="line">        System.out.println(bird.getName() + &quot;能够飞 &quot; + bird.fly() + &quot;米&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Test test = new Test();  </span><br><span class="line">        test.test(new Bird() &#123;  </span><br><span class="line">              </span><br><span class="line">            public int fly() &#123;  </span><br><span class="line">                return 10000;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            public String getName() &#123;  </span><br><span class="line">                return &quot;大雁&quot;;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<hr>
<p>Output：<br>大雁能够飞 10000米  </p>
<p>对于这段匿名内部类代码其实是可以拆分为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WildGoose extends Bird&#123;  </span><br><span class="line">    public int fly() &#123;  </span><br><span class="line">        return 10000;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public String getName() &#123;  </span><br><span class="line">        return &quot;大雁&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">WildGoose wildGoose = new WildGoose();  </span><br><span class="line">test.test(wildGoose);  </span><br></pre></td></tr></table></figure>
<p>在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。<br>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。</p>
<p>使用匿名内部类时，我们必须是继承一个类或者是实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。<br>匿名类是不能定义构造函数的。<br>匿名内部类中不能存在任何静态成员变量和静态方法<br>匿名内部类为局部内部类，所以局部内部类的所有限制对匿名类产生有效<br>匿名类不能是抽象，因为他必须实现继承的类或者是实现接口的所有抽象方法</p>
<p>使用的形参为何要final？</p>
<p>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final<br>    当所在的方法的形参需要被内部类里面使用时，该形参必须为final。</p>
<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OuterClass &#123;  </span><br><span class="line">    public void display(final String name,String age)&#123;  </span><br><span class="line">        class InnerClass&#123;  </span><br><span class="line">            void display()&#123;  </span><br><span class="line">                System.out.println(name);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从上面代码中看好像name参数应该是被内部类直接调用？<br>其实不然，在java编译之后实际的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OuterClass$InnerClass &#123;  </span><br><span class="line">    public InnerClass(String name,String age)&#123;  </span><br><span class="line">        this.InnerClass$name = name;  </span><br><span class="line">        this.InnerClass$age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void display()&#123;  </span><br><span class="line">        System.out.println(this.InnerClass$name + &quot;----&quot; + this.InnerClass$age );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。<br>直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p>
<p>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。<br>故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。</p>
<h3 id="匿名内部类初始化"><a href="#匿名内部类初始化" class="headerlink" title="匿名内部类初始化"></a>匿名内部类初始化</h3><pre><code>我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OutClass &#123;  </span><br><span class="line">    public InnerClass getInnerClass(final int age,final String name)&#123;  </span><br><span class="line">        return new InnerClass() &#123;  </span><br><span class="line">            int age_ ;  </span><br><span class="line">            String name_;  </span><br><span class="line">            //构造代码块完成初始化工作  </span><br><span class="line">            &#123;  </span><br><span class="line">                if(0 &lt; age &amp;&amp; age &lt; 200)&#123;  </span><br><span class="line">                    age_ = age;  </span><br><span class="line">                    name_ = name;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            public String getName() &#123;  </span><br><span class="line">                return name_;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            public int getAge() &#123;  </span><br><span class="line">                return age_;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        OutClass out = new OutClass();  </span><br><span class="line">          </span><br><span class="line">        InnerClass inner_1 = out.getInnerClass(201, &quot;chenssy&quot;);  </span><br><span class="line">        System.out.println(inner_1.getName());  </span><br><span class="line">          </span><br><span class="line">        InnerClass inner_2 = out.getInnerClass(23, &quot;chenssy&quot;);  </span><br><span class="line">        System.out.println(inner_2.getName());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类加载顺序：有继承关系的加载顺序"><a href="#类加载顺序：有继承关系的加载顺序" class="headerlink" title="类加载顺序：有继承关系的加载顺序"></a>类加载顺序：有继承关系的加载顺序</h1><p><a href="https://www.cnblogs.com/sxkgeek/p/9647992.html">参考文章(CSDN)-类加载的顺序</a></p>
<p>1.首先加载父类的静态字段或者静态语句块</p>
<p>2.子类的静态字段或静态语句块</p>
<p>3.父类普通变量以及语句块</p>
<p>4.父类构造方法被加载</p>
<p>5.子类变量或者语句块被加载</p>
<p>6.子类构造方法被加载</p>
<h2 id="类加载顺序-关键点"><a href="#类加载顺序-关键点" class="headerlink" title="类加载顺序:关键点"></a>类加载顺序:关键点</h2><ul>
<li>静态代码块（只加载一次）</li>
<li>构造方法（创建一个实例就加载一次）</li>
<li>静态方法，调用的时候才会加载，不调用的时候不会加载</li>
<li>静态语句块和静态变量被初始化的顺序与代码先后顺序有关</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android插件化-开篇</title>
    <url>/2021/09/15/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Android插件化-开篇"><a href="#Android插件化-开篇" class="headerlink" title="Android插件化-开篇"></a>Android插件化-开篇</h1><p>插件化的分类</p>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>···</p>
<h3 id="Java-ClassLoader"><a href="#Java-ClassLoader" class="headerlink" title="Java - ClassLoader"></a>Java - ClassLoader</h3><ul>
<li>Java中默认有三种ClassLoader。分别是:<ul>
<li>BootStrap ClassLoader：启动类加载器，最顶层的加载器。主要负责加载JDK中的核心类。在JVM启动后也随着启动，并构造Ext ClassLoader和App ClassLoader。</li>
</ul>
<ul>
<li>Extension ClassLoader：扩展类加载器，负责加载Java的扩展类库。</li>
<li>App ClassLoader：系统类加载器，负责加载应用程序的所有jar和class文件。</li>
<li>自定义ClassLoader：需要继承自ClassLoader类。 </li>
</ul>
</li>
</ul>
<h4 id="ClassLoader职能"><a href="#ClassLoader职能" class="headerlink" title="ClassLoader职能"></a>ClassLoader职能</h4><p>ClassLoader默认使用双亲委托模型来搜索类。<br>每个ClassLoader都有一个父类的引用。当ClassLoader需要加载某个类时，先判断是否加载过，如果加载过就返回Class对象。否则交给他的父类去加载，继续判断是否加载过。这样 层层判断，就到了最顶层的BootStrap ClassLoader来试图加载。如果连最顶层的Bootstrap ClassLoader都没加载过，那就加载。如果加载失败，就转交给子ClassLoader，层层加载，直到最底层。如果还不能加载的话那就只能抛出异常了。  </p>
<ul>
<li>通过这种双亲委托模型，好处是：<ul>
<li>更高效，父类加载一次就可以避免了子类多次重复加载</li>
<li>更安全，避免了外界伪造java核心类。</li>
</ul>
</li>
</ul>
<h3 id="Android-ClassLoader"><a href="#Android-ClassLoader" class="headerlink" title="Android - ClassLoader"></a>Android - ClassLoader</h3><p>android从5.0开始使用art虚拟机，这种虚拟机在程序运行时也需要ClassLoader将类加载到内存中，但是与java不同的是，java虚拟机通过读取class字节码来加载，但是art则是通过dex字节码来加载。<br>这是一种优化，可以合并多个class文件为一个classes.dex文件。</p>
<ul>
<li>android一共有三种类加载器:  <ul>
<li>BootClassLoader：父类构造器  </li>
<li>PathClassLoader：一般是加载指定路径/data/app中的apk，也就是安装到手机中的apk。所以一般作为默认的加载器。</li>
<li>DexClassLoader：从包含classes.dex的jar或者apk中，加载类的加载器，可用于动态加载。<br>看PathClassLoader和DexClassLoader源码，都是继承自BaseDexClassLoader。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DexClassLoader(String dexPath, String optimizedDirectory,</span><br><span class="line">      String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">    super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">&#125;</span><br><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">public PathClassLoader(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, null, parent);  //见下文</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BaseDexClassLoader extends ClassLoader &#123;</span><br><span class="line">    private final DexPathList pathList;</span><br><span class="line">public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">        String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        super(parent);  //见下文</span><br><span class="line">        //收集dex文件和Native动态库【见小节3.2】</span><br><span class="line">        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们可以看到PathClassLoader的两个参数都为null，表明只能接受固定的dex文件，而这个文件是只能在安装后出现的。而DexClassLoader中optimizedDirectory，和librarySearchPath都是可以自己定义的，说明我们可以传入一个jar或者apk包，保证解压缩后是一个dex文件就可以操作了。因此，我们通常使用DexClassLoader来进行插件化和热修复。  </li>
</ul>
</li>
</ul>
<p><img src="ClassLoader.png" alt="ClassLoader"></p>
<p>可以看到，BaseDexClassLoader有一个相当重要的过程就是初始化DexPathList。初始化DexPathList的过程主要是收集dexElements和nativeLibraryPathElements。一个Classloader可以包含多个dex文件，每个dex文件被封装到一个Element对象。这element对象在初始化和热修复逻辑中是相当重要的。当查找某个类时，会遍历dexElements，如果找到就返回，否则继续遍历。所以当多个dex中有相同的类，只会加载前面的dex中的类。下面是这段逻辑的具体实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    for (Element element : dexElements) &#123;</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">        if (dex != null) &#123;</span><br><span class="line">            //找到目标类，则直接返回</span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            if (clazz != null) &#123;</span><br><span class="line">                return clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结<br>我们先是讲解了Java中类加载的双亲委托机制，然后介绍了Android中的几种ClassLoader，从源码角度介绍了两种ClassLoader加载机制的不同。以后的插件化实践中，我们会经常用到DexClassLoader。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机English词汇普及更正</title>
    <url>/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BAEnglish%E8%AF%8D%E6%B1%87%E6%99%AE%E5%8F%8A%E6%9B%B4%E6%AD%A3/</url>
    <content><![CDATA[<p>pertain 属于<br>pertaiing to 属于<br>Threadlocal values pertaining to this thread.<br>This map is maintained by the ThreadLocal class.  </p>
<p>usages n 用途,用法</p>
<p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了处理非常大和生命周期非常长的线程(<strong>usages</strong>)，哈希表使用弱引用作为 key。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-CMD集合</title>
    <url>/2021/09/07/Android-CMD%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重启adb </span><br><span class="line">adb kill-server &amp;&amp; adb server &amp;&amp; adb shell</span><br><span class="line">查看当前的进程</span><br><span class="line">adb shell ps | grep package-name </span><br><span class="line">过滤日志</span><br><span class="line">adb logcat </span><br><span class="line">查看链接cpu架构信息</span><br><span class="line">adb shell </span><br><span class="line">cat/proc/cpuinfo </span><br><span class="line">查看已经连接的设备</span><br><span class="line">adb devices</span><br><span class="line">指定设备安装apk</span><br><span class="line">adb -s xxx install xxx.apk</span><br><span class="line"></span><br><span class="line">keytool -list -v -keystore  xxx.keystore</span><br><span class="line">查看签名秘钥</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ADB-进阶CMD"><a href="#ADB-进阶CMD" class="headerlink" title="ADB 进阶CMD"></a>ADB 进阶CMD</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev:每隔 1s 输出一次APP CPU信息，命令如下</span><br><span class="line">$adb shell</span><br><span class="line">$adb top -d 1 | grep com.packagename.xxx</span><br><span class="line"></span><br><span class="line">dev: 获取Apk安装的路径</span><br><span class="line">adb shell pm path com.packagename.xxx</span><br><span class="line"></span><br><span class="line">dev: 导出apk文件</span><br><span class="line">adb pull /data/app/com.packagename.xxx/base.apk</span><br><span class="line"></span><br><span class="line">adb shell pm list package</span><br><span class="line">example:</span><br><span class="line">$ adb shell pm list package tao</span><br><span class="line">package:com.taobao.taobao</span><br><span class="line"></span><br><span class="line">dev:结合 grep 搜索包名</span><br><span class="line">$ adb shell pm list package | grep -i z</span><br><span class="line">package:ru.zdevs.zarchiver</span><br></pre></td></tr></table></figure>

<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gradle</span><br><span class="line">查看主要的任务</span><br><span class="line">./gradlew tasks </span><br><span class="line">查看所有任务，包括缓存任务</span><br><span class="line">./gradlew tasks --all</span><br><span class="line">调试模式构建并打印堆栈日志</span><br><span class="line">./gradlew build --info --debug --stacktrace</span><br></pre></td></tr></table></figure>

<h2 id="bundletool"><a href="#bundletool" class="headerlink" title="bundletool"></a>bundletool</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Linux-Android"><a href="#Linux-Android" class="headerlink" title="Linux - Android"></a>Linux - Android</h2><p>1、查看 CPU 详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>Android卡顿优化-前章</title>
    <url>/2021/09/07/Android%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96-%E5%89%8D%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Android存储路径更新(前章)</title>
    <url>/2021/09/06/Android%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在Android版本的不断升级更替中，Google对存储目录操作的限制也是越来越严格。<br>至于为什么要限制，其实是有迹可循的。第一点是出于用户安全数据的保护，Android (Q)10 之前，Android的文件存储现象就像个垃圾桶，只要app取得了存储空间的读写权限，WRITE_EXTERNAL_STORAGE，就可以肆意创建文件，难以管理。用户体验也特别差，打开文件管理器，会发现，想找个具体的文件根本无从下手。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Android 10 (Q)  新增了分区存储的概念，targetSdkVersion=29  </span><br><span class="line">Android &gt;10() *强制开启分区存储的概念，targetSdkVersion&gt;=30</span><br><span class="line">// 这里我们在罗列上一些开发的细节</span><br><span class="line"></span><br><span class="line">当targetSdk &lt;= 28时，应用使用传统存储方式；</span><br><span class="line">当targetSdk &lt;= 29时，可以通过在应用清单的application标签中添加android:requestLegacyExternalStorage=&quot;true&quot; ，从而关闭分区存储功能，继续使用传统访问方式。</span><br><span class="line">当targetSdk &gt;= 30时，Android会强制执行分区存储，无法关闭。可以通过Environment.isExternalStorageLegacy()判断应用存储的运行方式，true表示以传统的兼容方式运行，false表示以分区存储运行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="科普-targetSdkVersion"><a href="#科普-targetSdkVersion" class="headerlink" title="科普 - targetSdkVersion"></a>科普 - targetSdkVersion</h2><p>在开发中targetSdkVersion到底是啥含义？</p>
<h2 id="Android手机的存储"><a href="#Android手机的存储" class="headerlink" title="Android手机的存储"></a>Android手机的存储</h2><ul>
<li>安卓设备的物理存储分为两大块，内部存储和外部存储</li>
</ul>
<p>内部存储：<br>设备中每一个安装的 App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹，这个文件夹也用来 存放SharedPreferences 和 SQLiteDatabase 的数据， App 中的 WebView 缓存页面信息也在这文件夹下；<br>但是 当app被卸载的时候，这个文件夹 会被删除掉。<br>开发过程中，可通过 Context对象提供的 API 读取操作 内部存储中的文件</p>
<p>强烈建议大家开发的手机尽量Root或者使用64位的模拟器 👍🏻,可以对整体目录有个清晰了解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * Environment.getDataDirectory() : /data</span><br><span class="line">    * context.getFilesDir() : /data/user/0/com.e.dk_wd/files</span><br><span class="line">    * context.getCacheDir() : /data/user/0/com.e.dk_wd/cache</span><br><span class="line">    * context.getDataDir() : /data/user/0/com.e.dk_wd</span><br><span class="line">*/</span><br><span class="line">    Log.i(&quot;----&quot;, &quot;Environment.getDataDirectory() : &quot; + Environment.getDataDirectory().absolutePath)</span><br><span class="line">    Log.i(&quot;----&quot;, &quot;context.getFilesDir() : &quot; + this.filesDir!!.absolutePath)</span><br><span class="line">    Log.i(&quot;----&quot;, &quot;context.getCacheDir() : &quot; + this.cacheDir!!.absolutePath)</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        Log.i(&quot;----&quot;, &quot;context.getDataDir() : &quot; + this.dataDir!!.absolutePath)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果你想看app的看存储的话，提前root，或者你用模拟器打开即可。</p>
<p>外部存储：</p>
<p>现在的手机基本上都是内置了 <strong>SD</strong> 卡，同时也提供 <strong>SD 卡的拓展</strong>。<br>所说的外部存储，就是手机设备内置的 SD卡 和 扩展的SD卡 提供的存储空间<br>外部存储 也会为 安装的app 提供一块区域（文件夹） ，用来存放私有的文件<br>通常的路径是：**/storage/emulated/0/Android/data/包名/**</p>
<p>这里提供一下获取方式:</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_ALARMS)</td>
<td align="center">/storage/sdcard0/Alarms</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_DCIM)</td>
<td align="center">/storage/sdcard0/DCIM</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)</td>
<td align="center">/storage/sdcard0/Download</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_MOVIES)</td>
<td align="center">/storage/sdcard0/Movies</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_MUSIC)</td>
<td align="center">/storage/sdcard0/Music</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_NOTIFICATIONS)</td>
<td align="center">/storage/sdcard0/Notifications</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_PICTURES)</td>
<td align="center">/storage/sdcard0/Pictures</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_PODCASTS)</td>
<td align="center">/storage/sdcard0/Podcasts</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_RINGTONES)</td>
<td align="center">/storage/sdcard0/Ringtones</td>
</tr>
</tbody></table>
<h3 id="分区存储概览"><a href="#分区存储概览" class="headerlink" title="分区存储概览"></a>分区存储概览</h3><p>这里我们先看一张图，先大概有个概念</p>
<p><img src="%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95.awebp" alt="分区存储"></p>
<p>Android存储的改变基本上遵循了3个原则:<br>更好的从属性: 系统知道哪些文件属于哪些应用，这可以让用户更方便地管理他们的文件。当应用被卸载后，除非用户需要，否则应用之前所创建的文件也不应该保留在设备上；<br>保护应用数据: 当一个应用将 它所属的文件 写入外部存储时，这些文件是不应该被其他应用所访问的；<br>保护用户数据: 当用户下载了一些文件，比如带有敏感信息的邮件附件，这些文件应该对其他应用不可见。  </p>
<p>Android10分区存储对<strong>外部存储</strong>重新进行了设计</p>
<ul>
<li>私有存储 (Private Storage) : 每个应用在都拥有自己的私有目录，其它应用看不到，彼此也无法访问到该目录：内部存储私有目录 (/data/data/packageName) ；外部存储私有目录 (/sdcard/Android/data/packageName)，</li>
<li>共享存储 (Shared Storage) : 存储其他应用可访问文件， 包含媒体文件、文档文件以及其他文件，对应设备DCIM、Pictures、Alarms、Music、Notifications、Podcasts、Ringtones、Movies、Download等目录<h4 id="私有存储"><a href="#私有存储" class="headerlink" title="私有存储"></a>私有存储</h4>应用私有目录文件访问方式与之前Android版本一致，可以通过file path获取资源。<br>这里有个细节点，访问app自身外部私有目录是不需要要任何权限的。  </li>
</ul>
<p><strong>需要注意的不同点是：开启了分区存储特性后，应用只能访问自身的私有空间，即使获得了存储权限，也无法访问其他应用的私有空间</strong></p>
<h4 id="共有目录"><a href="#共有目录" class="headerlink" title="共有目录"></a>共有目录</h4><p>其实开启分区存储，对内部还有和外部私有目录是没有影响的。<br>这个目录有个明显的地方，该目录保存之后的文件，即使在app卸载后文件也依旧停留在了手机上，所以这也是被google团队重点关照的地方。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Apk安装的流程(前章)</title>
    <url>/2021/08/20/Android-Apk%E5%AE%89%E8%A3%85%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>最近自己又去阅读了Android源码，感觉以前有些困惑清晰了不少。<br>android源码庞大而复杂，一个源文件文件少则都是几千行代码。抓住核心很重要，那么多API的调用链根本记不完，不能一窥全貌，就只能迷失在森林之中，其实重要的是去梳理流程，搞清楚这个模块的设计初衷是为了什么，如果让你自己来你会怎么设计，如何写出高质量的代码。<br>思维上的提高才是本质上的进步！！！</p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>APK安装的方式其实有很多种，网上也有很多好的文章，不过学会才是最重要的，做出我们自己的总结。<br>从2021 年 8 月起 新应用需要使用 Android App Bundle 才能在 Google Play 中发布(<a href="https://developer.android.com/guide/app-bundle">Android ABB</a>)，在加上国内华为也支持了该ABB形式文件上架应用，后面也兴会成为主流。</p>
<p>关于相关的 Android App Bundle的知识可以点击这里<a href="https://zhupengbo.com/2021/07/19/google-aab/">🏷</a>)</p>
<h1 id="APK安装的方式"><a href="#APK安装的方式" class="headerlink" title="APK安装的方式"></a>APK安装的方式</h1><p>本章节只讲大致流程，代码流程我们后面再慢慢梳理</p>
<ul>
<li>安装方式</li>
</ul>
<ul>
<li>1.系统应用和预制应用的安装</li>
<li>2.通过商店</li>
<li>3.Adb</li>
<li>4.通过SD卡</li>
</ul>
<h1 id="🏷-科普"><a href="#🏷-科普" class="headerlink" title="🏷 科普"></a>🏷 科普</h1><h2 id="Android科普"><a href="#Android科普" class="headerlink" title="Android科普"></a>Android科普</h2><p><a href="https://blog.csdn.net/qq_28193019/article/details/102880179">安装目录的基本知识</a></p>
<p>既然是APK安装,有输入点就有输出点，所以就会有对应的目录，每个不同的目录存放这对应的文件。  </p>
<!-- | Class |     Name  | 
|:------------- |:---------------:|  -->

<table>
<thead>
<tr>
<th align="left">目录</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/system/app</td>
<td align="center">系统自带的应用程序,获得 root 权限才能删除</td>
</tr>
<tr>
<td align="left">/data/app</td>
<td align="center">第三方应用apk文件.安装时把apk文件复制到此目录</td>
</tr>
<tr>
<td align="left">/data/anr</td>
<td align="center">存放anr信息（/data/anr/traces.txt用于存放app ANR信息）</td>
</tr>
<tr>
<td align="left">/data/data</td>
<td align="center">应用程序数据</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}</td>
<td align="center">特定应用程序数据目录</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/cache</td>
<td align="center">临时文件，系统会自动清理</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/databases</td>
<td align="center">数据库</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/files</td>
<td align="center">一般文件</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/shared_pres</td>
<td align="center">SharedPreference</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/lib</td>
<td align="center">so文件</td>
</tr>
<tr>
<td align="left">/data/dalvik-cache</td>
<td align="center">存放odex文件.将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,ART模式的可执行文件格式为.aot,启动ART时,系统会执行dex文件转换至aot文件)</td>
</tr>
<tr>
<td align="left">/data/system/packages.list</td>
<td align="center">类似于Window的注册表,该文件是解析apk时由writeLP()创建的。记录了系统的permissons,以及解析apk的AndroidManifest获取的应用name,codePath,flag,ts,version,userid等信息。解析完apk后将更新信息写入这个文件并保存到flash,下次开机的时候直接从里面读取相关信息并添加到内存相关列表中.当有apk升级,安装或删除时会更新这个文件。</td>
</tr>
<tr>
<td align="left">/data/system/packages.xml</td>
<td align="center">指定应用的默认存储位置/data/data/com.xx.xx/package.xml中包含了该应用申请的权限,签名和代码所在的位置等信息系,并且两者都有同一个userld.</td>
</tr>
<tr>
<td align="left">/data/user/0</td>
<td align="center">软链接，指向/data/data</td>
</tr>
<tr>
<td align="left">/data/user_de/0/${package_name}</td>
<td align="center">设备存储保护区，在快速启动模式可以访问这个文件夹</td>
</tr>
<tr>
<td align="left">/proc/cpuinfo</td>
<td align="center">cpu信息</td>
</tr>
<tr>
<td align="left">/proc/smaps</td>
<td align="center">内存占用信息</td>
</tr>
<tr>
<td align="left">/sdcard</td>
<td align="center">软链接，最终指向/storage/emulated/0【跟Android版本和ROM版本有关】</td>
</tr>
<tr>
<td align="left">/storage/emulated/0</td>
<td align="center">外部存储的根目录</td>
</tr>
<tr>
<td align="left">/storage/emulated/0/Android/data/${package_name}</td>
<td align="center">应用的额外数据</td>
</tr>
<tr>
<td align="left">/system/app</td>
<td align="center">系统应用apk文件</td>
</tr>
<tr>
<td align="left">/system/lib</td>
<td align="center">系统应用so库</td>
</tr>
<tr>
<td align="left">————————————————</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>在/data/data/包名目录下，每个app都有自己的目录，目录名就是应用程序在AndroidManifest.xml文件中定义的包。每个应用程序的代码，对自己的目录是有绝对的控制权限的。在每个目录下，一般有如下几个子目录（结合上面的表格）：</p>
<p>databases : 存放数据库<br>cache : 存放缓存数据<br>files : 存放应用程序自己控制的文件<br>lib : 存放使用的包</p>
<h2 id="Linux科普"><a href="#Linux科普" class="headerlink" title="Linux科普"></a>Linux科普</h2><p>为什么这里需要了解Linux的知识点，<br>Linux进程有两个ID，一个就是用户ID，为每个用户的唯一标识符；<br>另一个是组ID，为用户组的唯一标识符</p>
<p>当你在手机点击一个APK之后,APK中的AndroidManifest.xml会被解析,在手机root之后，或者用模拟器打开根目录 <strong>/data/system/</strong> ，我们获得超级权限之后，可以在查看目前手机在系统已经注册的app，解析的内容会被存储到 <strong>/data/system/packages.xml</strong> 和 <strong>/data/system/packages.list</strong> 中。我们打开packages.list和packages.xml，我们已Apk的包名为索引，可以看到对应的内容。</p>
<p>packages.list</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.game.dalan2.s3 10130 1 /data/user/0/com.game.dalan2.s3 default 3003</span><br></pre></td></tr></table></figure>

<p>packages.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;package name=&quot;com.game.dalan2.s3&quot; codePath=&quot;/data/app/com.game.dalan2.s3-1&quot; nativeLibraryPath=&quot;/data/app/com.game.dalan2.s3-1/lib&quot; primaryCpuAbi=&quot;x86&quot; publicFlags=&quot;940097350&quot; privateFlags=&quot;0&quot; ft=&quot;17b8267bd90&quot; it=&quot;17b586694ad&quot; ut=&quot;17b8267cb67&quot; version=&quot;1&quot; userId=&quot;10130&quot;&gt;</span><br><span class="line">     &lt;sigs count=&quot;1&quot;&gt;</span><br><span class="line">         &lt;cert index=&quot;9&quot; key=&quot;忽略&quot; /&gt;</span><br><span class="line">     &lt;/sigs&gt;</span><br><span class="line">     &lt;perms&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.INTERNET&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.ACCESS_WIFI_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">     &lt;/perms&gt;</span><br><span class="line">     &lt;proper-signing-keyset identifier=&quot;147&quot; /&gt;</span><br><span class="line"> &lt;/package&gt;</span><br></pre></td></tr></table></figure>

<p>packages.list中指名了该应用默认存储的位置<br>packages.xml中包含了该应用申请的权限、签名和代码所在位置等信息，并且两者都有一个userId为10060。  </p>
<p>之所以每个应用都有一个userId，是因为Android在系统设计上把每个应用当作Linux系统上的一个用户对待，这样就可以利用已有的Linux上用户管理机制来设计Android应用，比如应用目录，应用权限，应用进程管理等。</p>
<p>这个解析的过程也可以理解为在APK在系统的注册。</p>
<p>相关知识点可以查看这里 <a href="https://stackoverflow.com/questions/12442979/android-understanding-the-apk-installation-process">Stack Overflow</a></p>
<h1 id="Apk安装的流程"><a href="#Apk安装的流程" class="headerlink" title="Apk安装的流程"></a>Apk安装的流程</h1><p>这里大致只讲流程，详细的代码我们后面再一一罗列出来:<br>简单来说分为四步：</p>
<p>1)将APK的信息通过IO流的形式写入到PackageInstaller.Session中。</p>
<p>2)调用PackageInstaller.Session的commit方法，将APK的信息交由PKMS处理。</p>
<p>3)拷贝APK</p>
<p>4)最后进行安装</p>
<h1 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h1><h2 id="什么是覆盖安装-？"><a href="#什么是覆盖安装-？" class="headerlink" title="什么是覆盖安装 ？"></a>什么是覆盖安装 ？</h2><p>无论在国内还是出海国外上架海外游戏App，我们在每次上架新版本的时候，都是需要<strong>versionCode</strong>+1,用户再通过商店渠道再把 versioncode+1的apk覆盖掉原先的apk,这个过程就是覆盖安装，。<br>不过还是有前置条件：<br>    1.包名跟旧的一致<br>    2.签名跟原来的一致<br>    3.组件不冲突</p>
<p>更详细的内容看这张表：</p>
<table>
<thead>
<tr>
<th align="left">正常安装</th>
<th align="center">覆盖安装</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">删除旧版本APK之后重新进行安装</td>
<td align="center">（不删除之前的旧版本包，直接安装）</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SQLite的数据也会被删除</td>
<td align="center">SQLite的数据不会丢失</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">shared_prefs中的数据会被删除</td>
<td align="center">shared_prefs中的数据不会丢失</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4.4之前的版本不会比较apk的Version_code</td>
<td align="center"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？"><a href="#部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？" class="headerlink" title="部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？"></a>部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？</h2><p>首先要清除对应的安装包，就得知道安装包的目录是在哪，计算机的世界有入口就有出口。<br>我们这里在做一些知识的扩展：<br>现在部分手机的App是具有分享Apk的功能，也就是传输本机上的apk，比如说QQ，还有一些第三方的软件具备之类的功能。手机安装app时，会在根目录和外存储器合生成文件夹。反过来说，你删除app的时候，这些对应生成文件夹也会被系统删除。根目录会放置app的安装包，而且统一命名为base.apk，还有一些重要的app用户数据。(你想查看，前提是开启root)<br>外存储器就是你能看到的文件夹，里面放置可操作的文件，例如保存的图片，视频。所以即使你安装app后删除安装包，也是删除了外存储器的安装包，QQ传输app安装包就是传输<strong>根目录</strong>的安装包。</p>
<h2 id="Android目录扫盲"><a href="#Android目录扫盲" class="headerlink" title="Android目录扫盲"></a>Android目录扫盲</h2><p>关于存储的目录，我们后面额外再开一张新的文章，android对于目录和权限其实做了不少的修改。<br>接下来这段是很多Code的误区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Environment.getExternalStorageDirectory()</span><br></pre></td></tr></table></figure>
<p>实际上是获取的手机自带的sd卡，这个自带的sd卡你在手机的文件管理应用里看，显示的中文名是“内部存储”，这个“内部存储”实际上就是手机自带的sd卡，也就是ExternalStorage</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发篇-1</title>
    <url>/2021/08/13/Java-%E5%B9%B6%E5%8F%91%E7%AF%87-1/</url>
    <content><![CDATA[<p><a href="https://www.zhihu.com/question/22950899">https://www.zhihu.com/question/22950899</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Activity</title>
    <url>/2021/08/11/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>在最近的任务栈里面看见的task未必还活着。<br>在最近的任务栈里面看不见的task未必就死了。</p>
<h2 id="android-launchMode"><a href="#android-launchMode" class="headerlink" title="android-launchMode"></a>android-launchMode</h2><p>在这里我推荐大家去看扔物线的课程: <a href="https://www.bilibili.com/video/BV1CA41177Se">Android 面试黑洞</a></p>
<p>Activity有4种启动模式，分别是：Standard、SingleTop、SingleTask和SingleInstance，它们控制了被启动Activity的启动行为。<br>Activity任务栈（Task）是一个标准的栈结构<br>用于在ActivityManagerService侧管理所有的Activity（AMS通过TaskRecord标识一个任务栈，通过ActivityRecord标识一个Activity）。</p>
<table>
<thead>
<tr>
<th align="left">launchMode</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE【知识扩展】</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Standard</td>
<td align="center">标准模式</td>
<td align="left">标准模式，也是系统的默认模式。该模式下，每次启动Activity，都会创建一个新实例，并且将其加入到启动该Activity的那个Activity所在的任务栈中，所以目标Activity的多个实例可以位于不同的任务栈。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SingleTop</td>
<td align="center">栈顶复用模式</td>
<td align="left">该模式下，若目标Activity的实例已经存在，但是没有位于栈顶，那么仍然会创建新的实例，并添加到任务栈；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SingleTask</td>
<td align="center">栈内复用模式</td>
<td align="left">clearTop的作用，整个任务栈只能有一个activity的实例。</td>
<td align="left">如果此时任务栈内已经存在 Activity C 的实例且未位于栈顶，当启动 Activity C 时，会将 Activity C 上方的实例全部出栈让其位于任务栈顶并 Activity C 中的 onNewIntent() 方法会被调用</td>
</tr>
<tr>
<td align="left">SingleInstance</td>
<td align="center">单一实例</td>
<td align="left">要求该Activity所在的Task只有有这么一个Activity，</td>
<td align="left">下面没有旧，上面没有新</td>
</tr>
</tbody></table>
<h2 id="MORE【知识扩展】"><a href="#MORE【知识扩展】" class="headerlink" title="MORE【知识扩展】"></a>MORE【知识扩展】</h2><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><p>当我们使用Application的Context来启动一个Activity的时候，会报AndroidRuntimeException，因为standard模式下启动的Activity，会默认进入启动它的Activity的任务栈中，而非Activity类型的context却并没有所谓的任务栈，所以就会出现问题，解决这个问题的方法是需要为要启动的Activity指定标记位：FLAG_ACTIVITY_NEW_TASK，这个标记的作用是为启动的Activity创建一个新的任务栈。</p>
<h3 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h3><p>该模式下，若目标Activity的实例已经存在，但是没有位于栈顶，那么仍然会创建新的实例，并添加到任务栈；</p>
<p>若目标Activity的实例已经存在，且位于栈顶，那么就不会创建新的实例，而是复用已有实例，并依次调用目标Activity的onPause -&gt; onNewIntent -&gt; onResume方法。<br>知识扩展！！！</p>
<p>singleTop模式的activity特点就是除了外部可以启动它显示信息外，它也可以用同样的方式启动自己更新显示信息，这样就减少了冗余代码，降低了维护成本。</p>
<p>他的onCreate、onStart方法不会被调用，避免多次初始化，应用宝用的就是这套方案。</p>
<h3 id="SingleTask-A和B都是不同的2个应用"><a href="#SingleTask-A和B都是不同的2个应用" class="headerlink" title="SingleTask A和B都是不同的2个应用"></a>SingleTask A和B都是不同的2个应用</h3><p>首先做个假设：A-Activity 启动 B_Activity,launchMode下文进行了标注<br>A_Activity[Standard] ==&gt; B_Activity[SingleTask]<br>B_Activity的Activity被启动时，不会进入启动A的Task里,而是创建属于B自己的Task里，置于B-Task栈顶,然后把整个B-Task 压到 A-Task上面,这种方式打开的方式是入场动画是应用间的切换。</p>
<p>如果这时按下返回键，这里回退的顺序是 B-Task 来回退，而不是返回原来的A_Activity[Standard]。原来的A要在前台显示，必须是B-Task的栈的Activity完全关闭才可以，这里场景动画也是场景间的切换。  </p>
<p>这里要明确一个概念：不止应用的Activity内部可以叠成栈，不同应用之间的Task也可以叠成栈。</p>
<p>Task的叠加只适用于前台的Task。</p>
<p>SingleTask是保证了一个栈内有且只有被该属性修饰Activity的实例对象，全局单例</p>
<h3 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h3><p>为了描述清晰，我们还是要举个例子:<br>A_Activity[Standard] ==&gt; B_Activity[SingleInstance]<br>还是 A 短信应用 打开 B 邮箱应用<br>邮件App不仅为了当前跳转的Activity创建对象，而且会创建一个单独的B-Task,然后把当前的打开应用的Activity的实例放到B-Task。<br>第二种情况是当前Activity已经被创建过了，则会回调当前应用的Activity生命周期的**onNewIntent()**方法</p>
<p>这2种情况的变化，这个B-Task都会被拿过来压在A-Task上面，入场动画是切换Task的动画。</p>
<p>假设用户这个时候点返回，上面的Task因为只有一个Activity，手机会直接回到短信App，入场动画是切换Task的动画。</p>
<p>假设用户没有直接点返回，而是选择查看了最近的任务又返回到之B-Task，这个时候短信的A-Task已经被退到后台，所以用户再点返回的话，又因为当前的Task内只有一个B-Activity，所以是直接回退到桌面。</p>
<p>假设用户又没有点返回，也没有选择查看任务，而是选择了在B-Task，又打开了一个C-App的Activity，由于SingleInstance的限制，所以C-task并不会叠在B-Task之上，而是另辟蹊径，而是装到另一个Task中，然后整个Task跌在B-Task上面。</p>
<p>知识点: 我来解释一下另辟蹊径的意思，这个时候相对邮箱App此时有2个Task，一个是独栈的，也就是短信调用的那个，还有一个是后台的Task，C的Activity是被放到了后台的Task。</p>
<blockquote>
<p>在最近的任务栈里面看不见的task未必就死了。这句话也是在这里体现。<br>在延伸出一个属性:Android:taskAffinity，</p>
</blockquote>
<h2 id="Android-taskAffinity属性"><a href="#Android-taskAffinity属性" class="headerlink" title="Android:taskAffinity属性"></a>Android:taskAffinity属性</h2><blockquote>
<p>在android里，一般情况下一个App默认只有一个Task，可以显示在最近的列表里面，但是用来甄别唯一性的不是App，而是<strong>taskAffinity</strong>，每一个Activity都有属于自己的Activity，相当于每个Activity的预先分组。<br><img src="taskAffinity%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99.png" alt="taskAffinity"><br>android:taskAffinity是Activity的一个属性，表示该Activity期望的任务栈的名称。<br>默认情况下，一个应用程序中所有Activity的taskAffinity都是相同的，即应用程序的包名。当然，我们可以在配置文件中为每个Activity指定不同的taskAffinity（只有和已有包名不同，才有意义）。<br><img src="taskAffinity%E6%9C%80%E8%BF%91%E5%88%97%E8%A1%A8.png" alt="taskAffinity"><br>另外每一个Task也有taskAffinity，他的值取自栈底的Activity的taskAffinity值，这个栈底Activity也就是第一个启动应用的Activity。</p>
</blockquote>
<p>另外一点taskAffinity也可以在androidManifest被定制。<br><img src="taskAffinity%E5%BC%80%E5%8F%91%E6%8E%A8%E8%8D%90.png" alt="taskAffinity">  </p>
<p>一般情况下，该属性主要和SingleTask启动模式或者android:allowTaskReparenting属性结合使用（下面会详细介绍），在其他情况下没有意义。</p>
<h3 id="Task-Reparenting"><a href="#Task-Reparenting" class="headerlink" title="Task - Reparenting"></a>Task - Reparenting</h3><p>B AndroidManifest属性 设置为android:allowTaskReparenting = True</p>
<p>场景具体化:A 短信应用 打开 B 邮箱应用</p>
<p>B还是会进入到A的Task里,但稍后用户从桌面点击B应用的时候，原先放在A-Task里面的B-Activity会被挪到B应用的Task的栈顶,这个时候你在切回短信Task，你会发现原先的B-Activity已经不见了。<br>(有争议… Android 8,9是有问题的，10以上正常)</p>
<h3 id="前台Task"><a href="#前台Task" class="headerlink" title="前台Task"></a>前台Task</h3><p>前台叠加的多个Task进入后台第一时间就会拆开</p>
<blockquote>
<p>1.按Home键回到桌面<br>2.按最近任务键 查看最近的任务  </p>
<ul>
<li>前台Task 在最近列表显示出来的时候就已经进入到了后台，而不是切到其他任务之后。</li>
</ul>
</blockquote>
<p>但是光知道理论还是不够的，由于我们开发的时候大部分的情况都是多变的，我们在前面的章节可以了解到不同的应用的Activity是启动Task内叠加的。</p>
<p>首先做个假设：A-Activity 启动 B_Activity,launchMode下文进行了标注<br>A_Activity[Standard] ==&gt; B_Activity[SingleTask]<br>我们再把场景具体化，A 短信应用 打开 B 邮箱应用，这个时间我们没有按下返回键，而是按最近任务键，再重新回去原来的Task，这个时候看起来没有变化，但是实际上A的Task已经被去除掉了，只留下B的Task，这个时候我们再按下返回键，把B的Task内的Activity全部关闭，这个时候返回的系统的桌面而不是短信的APP。</p>
<h2 id="Android十万个为什么系列"><a href="#Android十万个为什么系列" class="headerlink" title="Android十万个为什么系列"></a>Android十万个为什么系列</h2><h3 id="当前-app-正在前台运行，不在栈顶的-Activity-有可能会因为系统资源，例如内存等不足回收吗？"><a href="#当前-app-正在前台运行，不在栈顶的-Activity-有可能会因为系统资源，例如内存等不足回收吗？" class="headerlink" title="当前 app 正在前台运行，不在栈顶的 Activity 有可能会因为系统资源，例如内存等不足回收吗？"></a>当前 app 正在前台运行，不在栈顶的 Activity 有可能会因为系统资源，例如内存等不足回收吗？</h3><p>我现在还记得这个问题，那年我毕业，投了心仪公司的简历，过了Hr的面试，来到了技术环节，和蔼的面试官问了:我们日常开发比较多组件的是Activity，假设 App 正在前台运行，不在栈顶的Activity有可能会被回收吗?<br>那时年少，我感觉我天灵盖被人开了，当场差点直接自闭，懵逼，接下来回答支支吾吾，面试结果是显而易见的。。。  <strong>(ಥ_ಥ)</strong><br>回去的路上越想越不对劲，到家之后立马查源码，好家伙找到了！平时不看源码，关键时刻被别人搞得一愣一愣！</p>
<p>凡事先说结论: 会 ！！！<br>这里看的源码是API30,在网上也看到一些相关答案答案，这里我们提炼一下要点，重点我们日常开发对场景预测，比方说游戏A-APP开启了一个B-App应用的界面，这个时候B-App开启了一个比较消耗耗内存的线程，如果这个内存不断地增大，最后游戏A-App的生命周期onDestroy()就会被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void attach(boolean system, long startSeq) &#123;</span><br><span class="line">        sCurrentActivityThread = this;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        if (!system) &#123;</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            try &#123;</span><br><span class="line">               //ApplicationThread是ActivityThread和AMS沟通的桥梁</span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            // Watch for getting close to heap limit.</span><br><span class="line">            BinderInternal.addGcWatcher(new Runnable() &#123;</span><br><span class="line">                @Override public void run() &#123;</span><br><span class="line">                    if (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                    long dalvikMax = runtime.maxMemory();</span><br><span class="line">                    long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                    if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123;</span><br><span class="line">                        if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024)</span><br><span class="line">                                + &quot; total=&quot; + (runtime.totalMemory()/1024)</span><br><span class="line">                                + &quot; used=&quot; + (dalvikUsed/1024));</span><br><span class="line">                        mSomeActivitiesChanged = false;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            ActivityTaskManager.getService().releaseSomeActivities(mAppThread);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            throw e.rethrowFromSystemServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="当-app-处于后台运行，app-进程未被杀死，其内部的-Activity-会被回收吗？"><a href="#当-app-处于后台运行，app-进程未被杀死，其内部的-Activity-会被回收吗？" class="headerlink" title="当 app 处于后台运行，app 进程未被杀死，其内部的 Activity 会被回收吗？"></a>当 app 处于后台运行，app 进程未被杀死，其内部的 Activity 会被回收吗？</h3><h3 id="当-app-处于后台运行，app-的进程会被杀死吗？"><a href="#当-app-处于后台运行，app-的进程会被杀死吗？" class="headerlink" title="当 app 处于后台运行，app 的进程会被杀死吗？"></a>当 app 处于后台运行，app 的进程会被杀死吗？</h3>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机杂谈-进程与线程</title>
    <url>/2021/08/04/Android%E6%9D%82%E8%B0%88-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>名词是对客观事物的指代，形容词是对客观事物的描述。</p>
<p>进程和线程又分别是什么? 进程和线程区别到底是什么?<br>带着简单的疑问，我们慢慢往下看看，本文不会过多章节去分析代码，而是比较多去谈自己的理解！</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程是<strong>操作系统</strong>分配资源的单位,线程是调度的基本单位,线程之间共享进程资源。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>其实就这么简单的一句话，就可以引申出很多概念。<br>逆向思维(反推)，从已有的结果出发挖掘更多的可能性.  </p>
<blockquote>
<p>到底线程之间共享了哪些进程资源？<br>共享资源意味着什么？<br>共享资源这种机制是如何实现的？<br>线程有哪些是线程私有的  </p>
</blockquote>
<h3 id="计算机扩展概念"><a href="#计算机扩展概念" class="headerlink" title="计算机扩展概念"></a>计算机扩展概念</h3><p>其实无论是谈生意也好，还是谈工作也好，首先必须要解决一个问题，就是明确主题和双方信息差的问题！<br>为了更好的理解，我们需要了解一些基础的计算机知识(linux)。具体文献请参考原文</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><a href="http://www.linfo.org/cpu.html">CPU</a></h3><blockquote>
<p>A CPU contains three main sections: (1) <strong>an arithmetic/logic unit</strong>, (2) <strong>a control unit</strong> and (3) <strong><a href="http://www.linfo.org/register.html">registers</a></strong>. The arithmetic/logic unit contains circuitry that performs data manipulation. The control unit consists of circuitry for coordinating the machine’s activities. The registers are high speed memory cells that are used for holding instructions for data that is currently being processed.<br>CPU 包含三个主要部分：(1)<strong>算术/逻辑单元</strong>，(2)<strong>控制单元</strong>和 (3)<strong>寄存器</strong>。<br>算术/逻辑单元包含执行数据操作的电路。<br>控制单元由用于协调机器活动的电路组成。<br>寄存器是<strong>高速存储</strong>单元，用于保存当前正在处理的数据的指令。</p>
</blockquote>
<h3 id="Register-Definition-—-寄存器"><a href="#Register-Definition-—-寄存器" class="headerlink" title="Register Definition — 寄存器"></a><a href="http://www.linfo.org/register.html">Register Definition</a> — 寄存器</h3><blockquote>
<p>A register is a very small amount of very fast memory that is built into the CPU (central processing unit) in order to speed up its operations by providing quick access to commonly used values.<br>寄存器是非常快又微型的存储器内置于Cpu，是通过访问快速提供的值,已加快Cpu(中央处理单元)的操作</p>
</blockquote>
<p>作用:寄存器是<strong>高速存储</strong>单元，用于保存当前正在处理的数据的指令。</p>
<p>专用寄存器存储内部 CPU 数据，例如程序计数器（也称为指令指针）、堆栈指针和状态寄存器。</p>
<h4 id="寄存器概念扩展"><a href="#寄存器概念扩展" class="headerlink" title="寄存器概念扩展"></a>寄存器概念扩展</h4><p>寄存器是存储器层次结构的顶部，是系统操作数据的最快方式。<br>在它们下面是几个级别的高速缓存，至少其中一些也内置在 CPU 中，而其中一些可能在其他专用芯片上。高速缓存比寄存器慢，但要丰富得多。在不同级别的高速缓存之下是主存储器，它更慢但更丰富（例如，与只有 32 个寄存器相比，数百兆字节）。但反过来，它仍然比存储设备和媒体（例如，硬盘驱动器和 CDROM）快得多，容量也小得多。</p>
<h4 id="其他作用"><a href="#其他作用" class="headerlink" title="其他作用"></a>其他作用</h4><p><strong>指令寄存器</strong>保存CPU正在执行的指令。<br><strong>地址寄存器</strong>保存内存地址，用于访问内存。<br><strong>数据寄存器</strong>用于存储整数。  </p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote>
<p>线程运行的本质就是函数。<br>函数的执行总会有一个源头，这个源头就是所谓的入口函数，相当于java的main的函数，<em>CPU</em> 从入口函数开始执行从而形成一个执行流，只不过我们人为的给执行流起一个名字，这个名字就叫线程。  </p>
</blockquote>
<h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><p>凡事从本质出发，我们就要去分析函数包含了些哪些信息。线程之间既然共享了进程资源，那就会对应不共享的资源，也就是线程私有资源<br>函数运行时的信息包含了栈帧中，栈帧中保存了函数的返回值，调用其他函数的参数，局部变量，该函数的寄存器初始值。  </p>
<p><img src="%E5%87%BD%E6%95%B0%E4%BF%A1%E6%81%AF.jpeg" alt="函数信息"></p>
<p>这里延伸出一个问题，因为线程是可以被操作系统随时暂停运行的和恢复运行的，那是怎么做到的？<br>可以通过保存以及恢复程序计数器的值就可以知道线程的从哪里运行又从哪里开始。</p>
<p>由于每个线程的本质都是函数的运行，函数运行时的信息是保存在栈中的，因此<strong>每个线程都有对应自己独立，私有的栈区</strong></p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%8C%BA.jpeg" alt="线程私有"></p>
<p>同时像函数的局部变量也是存放到寄存器之中，运行完就释放掉，回收内存。</p>
<p>所属线程的栈区，程序计数器，栈指针以及函数运行使用的寄存器都是线程私有的。</p>
<h3 id="线程间的共享"><a href="#线程间的共享" class="headerlink" title="线程间的共享"></a>线程间的共享</h3><h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h4><p>编译后的可执行机器指令,从可执行文件中加载到内存的，可执行程序中的代码区就是用来初始化进程地址空间中的代码区的。</p>
<h4 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h4><p>进程地址空间中的数据区，这里存放的就是所谓的全局变量。<br>全局变量简单的理解，一般不会被系统回收的变量，即使函数执行完后该变量依然存在，对于其他线程也是可见的 </p>
<h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>对象存放的地址空间，可被GC。<br>变量的地址，也就是指针。<br>任何一个线程都可以访问指针指向的数据，因此堆区也是线程共享的属于进程的资源。</p>
<h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>因为线程不像进程，进程是互相隔离，且独立。<br>如果一个线程能拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说这些线程可以任意修改本属于另一个线程栈区中的变量。<br>一个线程的栈区对其它线程是可以见的，也就是说我们可以修改属于任何一个线程的栈区  </p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>如果程序在运行过程中打开了一些文件，那么进程地址空间中还保存有打开的文件信息，进程打开的文件也可以被所有的线程使用，这也属于线程间的共享资源。</p>
<p>如图<br><img src="%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB.jpeg" alt="线程共享"><br>线程共享的地址，除了线程上下文的信息  </p>
<p>对于这个地方，我们引入java虚拟机<br>如图<br><img src="jvm.jpeg" alt="线程共享">  </p>
<p>这里再扩展一下,jdk.1.8.0其实以及取消了方法区,与之对于的是元空间</p>
<ul>
<li>以下jdk1.8 的标准（）<ul>
<li> 移除了永久代（PermGen），替换为元空间（Metaspace）；</li>
<li> 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li>
<li> 永久代中的 interned Strings 和 class static variables 转移到了 Java heap；<br>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize） </li>
</ul>
</li>
</ul>
<p><img src="jdk-1.8.0.png" alt="jdk-1.8.0.png">  </p>
<p>其实以下的概念我们都在上文讲过:</p>
<h3 id="java线程私有："><a href="#java线程私有：" class="headerlink" title="java线程私有："></a>java线程私有：</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>• 程序计数器：<br>    1. 每一个线程都需要有独立的计数器，各个线程互不干扰，独立存储<br>    2. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制<br>    3. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡 </p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>• Java虚拟机栈：<br>• 描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。<br>• 栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。<br>• Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。  </p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>• 本地方法栈<br>• 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。  </p>
<ul>
<li>线程共享:<br>• 堆<br>• 方法区<br>• 直接内存(非运行时数据区）<br>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。<br>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。    </li>
</ul>
<!-- ### Android十万个为什么 
#### Android中的context
很多人面试包括开发，最常遇到的一个名词就是Context，就是android的上下文，但是很多开发者其实不知道Context代表了什么意思，这里我的理解是 (格外提一点 寄存器是多个，不是一个)
> 线程的栈区 + 程序计数器 + 栈指针 + 函数运行使用的寄存器 = 上下文

Android操作系统可以随时中断并且回复正常，依靠的就是线程上下文。

这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了的进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存 -->

<!-- 作者：zhonyong
链接：https://www.zhihu.com/question/25532384/answer/81152571
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统Binder驱动分析(2)</title>
    <url>/2021/07/31/Android%E7%B3%BB%E7%BB%9FBinder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90-2/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我的文章比较多是对自己知识的梳理，有些概念没讲得那么清楚，但会贴出参考的链接，请大家自便</p>
<h1 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote>
<p>IPC : Inter-Process Communication (进程间的通信)<br>RPC : Remote Procedure Call (远程过程调用)<br>RPC是IPC的基础上进行了封装</p>
</blockquote>
<h3 id="简单例子-大致有个概念"><a href="#简单例子-大致有个概念" class="headerlink" title="简单例子: 大致有个概念"></a>简单例子: 大致有个概念</h3><p>再简单的分析下要素 (led是例子)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A(①封装数据 ②发送给B) ===&gt;(IPC) B(①取出数据 @调用数据) </span><br><span class="line">源 : A   </span><br><span class="line">目的 B 先向 ServerManger注册led服务  </span><br><span class="line">    A 向 ServerManger 查询led服务,得到一个Handler  </span><br><span class="line">数据：char_Buff   --&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Binder究竟是什么"><a href="#Binder究竟是什么" class="headerlink" title="Binder究竟是什么"></a>Binder究竟是什么</h2><p>Binder是Android系统中负责每个<strong>用户进程</strong>与<strong>内核</strong>通信的驱动模块。 </p>
<h3 id="Binder的优势"><a href="#Binder的优势" class="headerlink" title="Binder的优势"></a>Binder的优势</h3><p><a href="https://blog.csdn.net/universus/article/details/6211589">推荐文章</a><br>主要是基于性能、稳定性和安全性几方面的原因。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><table>
<thead>
<tr>
<th align="left">IPC</th>
<th align="center">数据拷贝次数</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">共享内存</td>
<td align="center">0</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Binder</td>
<td align="center">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Socket</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">管道</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">消息队列</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>Binder 基于 C/S 架构，架构清晰、职责明确又相互独立</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。<br>首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。<br>Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。</p>
<!-- (App UID 可 **packagename** 包名来区分)  -->
<p>传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。<br>可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>以下对比 Binder IPC 对比 传统IPC 的区别</p>
<h3 id="Linux-下的传统-IPC-通信原理"><a href="#Linux-下的传统-IPC-通信原理" class="headerlink" title="Linux 下的传统 IPC 通信原理"></a>Linux 下的传统 IPC <a href="https://zhuanlan.zhihu.com/p/35519585">通信原理</a></h3><p><img src="%E4%BC%A0%E7%BB%9FIPC.jpg" alt="Linux传统 IPC"></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<p>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；<br>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。  </p>
<h2 id="专栏-Android十万个为什么"><a href="#专栏-Android十万个为什么" class="headerlink" title="专栏:Android十万个为什么"></a>专栏:Android十万个为什么</h2><h3 id="什么是实名Binder"><a href="#什么是实名Binder" class="headerlink" title="什么是实名Binder?"></a>什么是实名Binder?</h3><h3 id="什么是匿名Binder？"><a href="#什么是匿名Binder？" class="headerlink" title="什么是匿名Binder？"></a>什么是匿名Binder？</h3><h3 id="“内核缓存区”-和-“数据接收缓存区”-存在的意义"><a href="#“内核缓存区”-和-“数据接收缓存区”-存在的意义" class="headerlink" title="“内核缓存区” 和 “数据接收缓存区” 存在的意义"></a>“内核缓存区” 和 “数据接收缓存区” 存在的意义</h3><p>Linux是使用的虚拟内存寻址方式，虚拟内存需要映射一块真的的物理内存，<br>内核缓存区和数据接收区的映射就是指向了同一块物理内存。接收方下次也可能是发送方，如果共用一块缓存那么岂不是发送方，内核，接收方都指向了同一块物理内存，违反了进程隔离的设计原则。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-崩溃优化</title>
    <url>/2021/07/29/Android-%E5%A5%94%E6%BA%83%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="崩溃优化"><a href="#崩溃优化" class="headerlink" title="崩溃优化"></a>崩溃优化</h1><h2 id="Android-崩溃分析"><a href="#Android-崩溃分析" class="headerlink" title="Android 崩溃分析"></a>Android 崩溃分析</h2><p>Android 崩溃基本分为 <strong>Java 崩溃</strong>和 <strong>Native 崩溃</strong><br>简单来说，Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出。<br>那 Native 崩溃又是怎么产生的呢？一般都是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，<br>这些都会产生相应的 <strong>signal 信号</strong>，导致程序异常退出。</p>
<h3 id="Native-崩溃"><a href="#Native-崩溃" class="headerlink" title="Native 崩溃"></a>Native 崩溃</h3><blockquote>
<ol>
<li>在 Unix-like 系统中，所有的崩溃都是编程错误或者硬件错误相关的，系统遇到不可恢复的错误时会触发崩溃机制让程序退出，如除零、段地址错误等。</li>
<li>异常发生时，CPU 通过异常中断的方式，触发异常处理流程。不同的处理器，有不同的异常中断类型和中断处理方式。</li>
<li>linux 把这些中断处理，统一为信号量，可以注册信号量向量进行处理。</li>
<li>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。  </li>
</ol>
</blockquote>
<h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="signal.png" alt="信号机制"> </p>
<h5 id="1-信号的接收"><a href="#1-信号的接收" class="headerlink" title="(1) 信号的接收"></a>(1) 信号的接收</h5><p>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入<strong>内核态</strong> 。<br>！！！注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<h5 id="2-信号的检测"><a href="#2-信号的检测" class="headerlink" title="(2) 信号的检测"></a>(2) 信号的检测</h5><p>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<p>1.进程从内核态返回到用户态前进行信号检测</p>
<p>2.进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</p>
<p>当发现有新信号时，便会进入下一步，信号的处理。</p>
<h5 id="3-信号的处理"><a href="#3-信号的处理" class="headerlink" title="(3) 信号的处理"></a>(3) 信号的处理</h5><p>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<p>四、捕捉native crash<br>1.注册信号处理函数<br>第一步就是要用信号处理函数捕获到native crash(SIGSEGV, SIGBUS等)。在posix系统，可以用sigaction()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;signal.h&gt; </span><br><span class="line">int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));</span><br></pre></td></tr></table></figure>
<p>signum：代表信号编码，可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号，如果为这两个信号定义自己的处理函数，将导致信号安装错误。</p>
<p>act：指向结构体sigaction的一个实例的指针，该实例指定了对特定信号的处理，如果设置为空，进程会执行默认处理。</p>
<p>oldact：和参数act类似，只不过保存的是原来对相应信号的处理，也可设置为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sigaction sa_old;  </span><br><span class="line">memset(&amp;sa, 0, sizeof(sa));  </span><br><span class="line">sigemptyset(&amp;sa.sa_mask);  </span><br><span class="line">sa.sa_sigaction = my_handler;  </span><br><span class="line">sa.sa_flags = SA_SIGINFO;</span><br><span class="line">if (sigaction(sig, &amp;sa, &amp;sa_old) == 0) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.设置额外栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigaltstack(const stack_t *ss, stack_t *oss);</span><br></pre></td></tr></table></figure>
<p>SIGSEGV很有可能是栈溢出引起的，如果在默认的栈上运行很有可能会破坏程序运行的现场，无法获取到正确的上下文。而且当栈满了（太多次递归，栈上太多对象），系统会在同一个已经满了的栈上调用SIGSEGV的信号处理函数，又再一次引起同样的信号。</p>
<p>我们应该开辟一块新的空间作为运行信号处理函数的栈。可以使用sigaltstack在任意线程注册一个可选的栈，保留一下在紧急情况下使用的空间。（系统会在危险情况下把栈指针指向这个地方，使得可以在一个新的栈上运行信号处理函数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack_t stack;  </span><br><span class="line">memset(&amp;stack, 0, sizeof(stack));  </span><br><span class="line">/* Reserver the system default stack size. We don&#x27;t need that much by the way. */  </span><br><span class="line">stack.ss_size = SIGSTKSZ;  </span><br><span class="line">stack.ss_sp = malloc(stack.ss_size);  </span><br><span class="line">stack.ss_flags = 0;  </span><br><span class="line">/* Install alternate stack size. Be sure the memory region is valid until you revert it. */  </span><br><span class="line">if (stack.ss_sp != NULL &amp;&amp; sigaltstack(&amp;stack, NULL) == 0) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.兼容其他signal处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static void my_handler(const int code, siginfo_t *const si, void *const sc) &#123;</span><br><span class="line">...  </span><br><span class="line">  /* Call previous handler. */  </span><br><span class="line">  old_handler.sa_sigaction(code, si, sc);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某些信号可能在之前已经被安装过信号处理函数，而sigaction一个信号量只能注册一个处理函数，这意味着我们的处理函数会覆盖其他人的处理信号</p>
<p>保存旧的处理函数，在处理完我们的信号处理函数后，在重新运行老的处理函数就能完成兼容。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 与 Unity 的交互</title>
    <url>/2021/07/29/Android%E4%B8%8EUnity%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p><img src="Unity%E7%9B%AE%E5%BD%95.jpg" alt="路径示例"></p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统Binder驱动分析(1)</title>
    <url>/2021/07/29/Android%E7%B3%BB%E7%BB%9FBinder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="提前掌握Binder的基础知识-预习"><a href="#提前掌握Binder的基础知识-预习" class="headerlink" title="提前掌握Binder的基础知识(预习)"></a>提前掌握Binder的基础知识(预习)</h1><p>Android系统架构的底层就是linux,本篇文章如有不懂的地方，建议参考<a href="http://www.linfo.org/">原文文档</a>,以便更好帮助自己学习。<br>希望能跟大家多多交流 !!!  </p>
<h2 id="Linux的基础知识"><a href="#Linux的基础知识" class="headerlink" title="Linux的基础知识"></a>Linux的基础知识</h2><p>Binder究竟是什么<br>什么是linux的系统内存<br>内核空间是什么<br>进程隔离<br>用户空间是什么</p>
<h2 id="Binder究竟是什么"><a href="#Binder究竟是什么" class="headerlink" title="Binder究竟是什么"></a>Binder究竟是什么</h2><p>Binder是Android系统中负责每个<strong>用户进程</strong>与<strong>内核</strong>通信的机制(驱动)</p>
<h2 id="内核空间是什么"><a href="#内核空间是什么" class="headerlink" title="内核空间是什么"></a>内核空间是什么</h2><p><a href="http://www.linfo.org/kernel_space.html">内核空间</a></p>
<blockquote>
<p>System memory in Linux can be divided into two distinct regions: kernel space and user space. Kernel space is where the kernel (i.e., the core of the operating system) executes (i.e., runs) and provides its services.<br>系统内存在的Linux可以分为两个不同的区域：<strong>内核空间</strong>和<strong>用户空间</strong>。内核空间是内核（即操作系统的核心）执行（即运行）并提供其服务的地方。</p>
</blockquote>
<h3 id="内核的作用是什么"><a href="#内核的作用是什么" class="headerlink" title="内核的作用是什么:"></a>内核的作用是什么:</h3><blockquote>
<p>One of the roles of the kernel is to manage individual user processes within this space and to prevent them from interfering with each other.<br>内核的作用之一是管理该空间内的各个用户进程并防止它们相互干扰。<br>这里涉及到一个概念 : <strong>进程隔离</strong></p>
</blockquote>
<h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
</blockquote>
<h4 id="内核空间的误区"><a href="#内核空间的误区" class="headerlink" title="内核空间的误区"></a>内核空间的误区</h4><blockquote>
<p>The kernel is a program that constitutes the central core of a computer operating system. It is not a process, but rather a controller of processes, and it has complete control over everything that occurs on the system. This includes managing individual user processes within user space and preventing them from interfering with each other.</p>
</blockquote>
<p>内核是构成计算机操作系统中央核心的程序。它不是一个进程，而是一个进程的控制器，它可以完全控制系统上发生的一切。这包括管理用户空间内的单个用户进程并防止它们相互干扰。</p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p><a href="http://www.linfo.org/user_space.html">用户空间</a></p>
<blockquote>
<p>User space is that portion of system memory in which user processes run<br>用户空间是用户进程在其中运行的系统内存部分</p>
</blockquote>
<h3 id="用户空间跟用户进程的区别"><a href="#用户空间跟用户进程的区别" class="headerlink" title="用户空间跟用户进程的区别"></a>用户空间跟用户进程的区别</h3><blockquote>
<p> User space is that set of memory locations in which user processes (i.e., everything other than the kernel) run<br>用户空间是一组内存位置，用户进程（即内核以外的所有东西）在其中运行。<br>每个正在运行的App都是一个用户进程,再不干涉的情景下，互相独立互不影响，都有属于自己的进程的用户空间。</p>
</blockquote>
<h2 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用/内核态/用户态"></a>系统调用/内核态/用户态</h2><blockquote>
<p>Kernel space can be accessed by user processes only through the use of system calls<br>用户空间访问内核空间的唯一方式就是系统调用</p>
</blockquote>
<p><strong>内核态</strong> : 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行<br><strong>用户态</strong> : 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。<br>处理器在特权等级高的时候才能执行那些特权CPU指令。 </p>
<h2 id="扩展概念"><a href="#扩展概念" class="headerlink" title="扩展概念"></a>扩展概念</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用是 <strong>类 Unix</strong> 操作系统中活动进程对内核执行的服务的请求，例如输入/输出(I/O) 或进程创建。活动进程是当前在 CPU 中进行的进程，与在 CPU 中等待其下一次运行的进程相反。I/O 是将数据传入或传出 CPU 以及传入或传出外围设备（如磁盘驱动器、键盘、鼠标和打印机）的任何程序、操作或设备。<br>系统调用主要通过如下两个函数来实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy_from_user() // 将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() // 将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>
<h3 id="Linux-使用两级保护机制："><a href="#Linux-使用两级保护机制：" class="headerlink" title="Linux 使用两级保护机制："></a>Linux 使用两级保护机制：</h3><p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<h3 id="Linux-内存映射"><a href="#Linux-内存映射" class="headerlink" title="Linux 内存映射"></a>Linux 内存映射</h3><p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h3 id="动态内核可加载模块"><a href="#动态内核可加载模块" class="headerlink" title="动态内核可加载模块"></a>动态内核可加载模块</h3><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。<br>它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>android-Handler机制-2</title>
    <url>/2021/07/27/android-Handler%E6%9C%BA%E5%88%B6-2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Message</td>
<td align="center">消息</td>
<td align="left">使用了享元设计模式 链表的数据结构</td>
<td align="left">详情</td>
</tr>
<tr>
<td align="left">MessageQuene</td>
<td align="center">消息队列</td>
<td align="left">单链表的数据结构</td>
<td align="left">优先级的队列 — 根据时间先后顺序排队的单链表</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="center">message的处理者</td>
<td align="left">即线程间传递的对象，传递的信息包含在其中    Handler的构造函 ，在构造函数中初始化了一个Looper 和 MessageQueue。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ThreadLocal</td>
<td align="center">数据结构是键值对</td>
<td align="left">只有在指定的线程可以获取到存储的数据</td>
<td align="left">获取线程唯一的变量 Theadlocal value 线程内部的数据存储类,使用场景：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本</td>
</tr>
<tr>
<td align="left">Looper</td>
<td align="center">循环器</td>
<td align="left"><img src="code_looper_1.jpg" alt="code_looper"></td>
<td align="left">类Looper的prepare的函数,即是对Looper进行了初始化，将Looper对象引用保存在sThreadLocal中，先保证了Looper和Threadlocal-1V1关系,由于sThreadLocal获取的值是通过获取当前线程获取线程唯一的变量,这样就保证了一个线程只有一个looper</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-APK的资源加载</title>
    <url>/2021/07/27/android-%E5%A4%96%E6%8C%82%E7%AF%87/</url>
    <content><![CDATA[<h1 id="APK的资源加载"><a href="#APK的资源加载" class="headerlink" title="APK的资源加载"></a>APK的资源加载</h1><h2 id="AssetManager"><a href="#AssetManager" class="headerlink" title="AssetManager"></a>AssetManager</h2><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-APK构建流程</title>
    <url>/2021/07/26/android-APK%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Apk构建流程"><a href="#Apk构建流程" class="headerlink" title="Apk构建流程"></a>Apk构建流程</h1><h2 id="Apk是什么"><a href="#Apk是什么" class="headerlink" title="Apk是什么"></a>Apk是什么</h2><p>维基百科，自由的百科全书<br>跳到导航跳到搜索<br>APK<br>APK format icon (2014-2019).png<br>扩展名    .apk、.xapk、.apks、.apkm<br>互联网媒体类型    application/vnd.android.package-archive<br>格式类型    包管理器 存档文件<br>专门属    软件包<br>延伸自    JAR 和 ZIP</p>
<p>APK 文件基于 ZIP 文件格式，它与JAR文件的构造方式相似。它的互联网媒体类型是：application/vnd.android.package-archive[5]。</p>
<p>扩展资料:<br>    Android5.0引入了Split APK机制，这是为了解决65536上限以及APK安装包越来越大等问题。Split APK机制可以将一个APK，拆分成多个独立APK。<br>    在引入了Split APK机制后，APK有两种分类：</p>
<pre><code>Single APK：安装文件为一个完整的APK，即base APK。Android称其为Monolithic。
Mutiple APK：安装文件在一个文件目录中，其内部有多个被拆分的APK，这些APK由一个 base APK和一个或多个split APK组成。Android称其为Cluster。
</code></pre>
<h2 id="Apk构成的属性"><a href="#Apk构成的属性" class="headerlink" title="Apk构成的属性"></a>Apk构成的属性</h2><pre><code>META-INF目录：包含两个签名文件（CERT.SF和CERT.RSA），以及一个manifest文件（MANIFEST.MF）
                  
assets目录：包含工程中的asset目录下的文件，可以使用AssetManager获取
                  
res目录：包含那些没有被编译到resources.arsc的资源
                
lib目录：包含适用于不同处理器的第三方依赖库，这里边可以有多个子目录，比如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, 以及mips
              
resources.arsc文件：存储编译好的资源，包括项目工程中的res/values目录里的xml文件，它们都被编译成二进制格式，也包括一些路径，指向那些没有被编译的资源，比如layout文件和图片
              
classes.dex文件：项目中的java类都被编译到该dex文件，这个文件可以被Android的Dalvik/ART虚拟机解析。
            
AndroidManifest.xml：二进制格式的manifest文件，这个文件是必须的。
        
这些文件是Android系统运行一个应用程序时会用到的数据和代码，下面介绍系统如何安装一个APK包。
</code></pre>
<h2 id="Apk编译的流程"><a href="#Apk编译的流程" class="headerlink" title="Apk编译的流程"></a>Apk编译的流程</h2><ol>
<li>通过<strong>aapt-Android Asset Packing Tool</strong> 打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）  </li>
</ol>
<blockquote>
<p>这一过程主要是aapt对res和asset文件夹，AndroidManifest.xml，android库(aar,jar)等的资源文件进行处理。  </p>
<ul>
<li>先检查<strong>AndroidManifest.xml</strong>的合法性  </li>
<li>然后编译res与asserts目录下的资源并生成resource.arsc文件  </li>
<li>再生成R文件。</li>
</ul>
</blockquote>
<p>除了assets和res/raw资源被原封不动地打包进APK之外，其它的资源都会被编译或者处理，<em>大部分文本格式的XML资源文件会被编译成二进制格式的XML资源文件</em>。<br>除了assets资源之外，其他的资源都会在R文件中被赋予一个资源ID。也就是说，R文件中只会存在id，真正的资源存在于resource.arsc中，resource.arsc相当于一个资源索引表，资源id是key，value是资源路径。我们使用drawable-xdpi或者drawable-xxdpi这些不同分辨率的图片的时候，就是依靠resource.arsc根据设备的分辨率选择不同的图片</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190915004258.png" alt="R.java"><br> (R.java相关知识)<br>2. 处理.aidl文件，生成对应的Java接口文件<br>3. 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 (编译期超出64k?)<br>4. 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex<br>5. 通过<strong>Japkbuilder</strong>J工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk<br>6. 通过<strong>Jarsigner</strong>工具，对上面的apk进行debug或release签名<br>通过zipalign工具，将签名后的apk进行对齐处理<br>(引申出问题，为什么需要签名，签名的方式有几种，有什么区别？)<br>7. 通过<strong>zipalign</strong>工具，将签名后的apk进行对齐处理<br>(引申一个问题，为什么需要对齐？)<br>8. 混淆proguard：proguard主要的目的是混淆代码，保护应用源代码。次要的功能还有移除无用类等，优化字节码，缩小包体积。  </p>
<h1 id="APK扩展性问题"><a href="#APK扩展性问题" class="headerlink" title="APK扩展性问题:"></a>APK扩展性问题:</h1><h2 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h2><h3 id="1-R-java是什么-R-java构成"><a href="#1-R-java是什么-R-java构成" class="headerlink" title="1. R.java是什么(R.java构成)"></a>1. <em>R.java是什么(R.java构成)</em></h3><blockquote>
<p>R.java由ADT(aapt)编译生成，<br>记录应用apk-res路径所有资源，并根据这些资源建立对应的ID(生成唯一的标识符)<br>编译期间，同一个资源在普通的apk中只会属于一个<strong>package</strong>，一个<strong>type</strong>，只拥有一个<strong>entry次序</strong>。<br>以0x01开头的就是系统已经内置的资源id，以0x7f开头的是咱们自己添加的app资源id </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/%E8%B5%84%E6%BA%90id.png" alt="R.java"> </p>
<blockquote>
<p>由于项目开发是多模块的开发 - 编译期相关的知识</p>
<ul>
<li>主模块中的R.java中的字段以final修饰，以常量形式存在。  </li>
<li>库模块中的R.java中的字段不以final修饰，以变量形式被项目中的代码所引用。  </li>
</ul>
</blockquote>
<h4 id="Android资源的合并"><a href="#Android资源的合并" class="headerlink" title="Android资源的合并"></a>Android资源的合并</h4><blockquote>
<p>覆盖的优先级如下：<br>build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependences</p>
</blockquote>
<blockquote>
<p>这种依赖关系不同于gradle里面的implementation依赖传递，implementation是跨级不能传递，但是R文件的生成是跨级可以传递的。<br>module的R文件数 = 依赖的module/aar数量 + 1(自身的R文件)<br>R.文件的生成是底层到上层 </p>
</blockquote>
<h3 id="为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？"><a href="#为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？" class="headerlink" title="为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？"></a>为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？</h3><blockquote>
<p><em>比较早的aapt的版本生成的非主模块的资源id确实都是final修饰的，这样会带来一个问题，这些资源id全部内联到代码中，一旦新增或者删除，修改了资源，资源id就会有变化，所有的代码都需要重新编译，造成严重的编译耗时</em>。  </p>
</blockquote>
<p>后来改为主模块final常量方式内联，非主模块引用方式，这样等按照从下到上编译到App模块的时候，所有的资源id都已经确定了，底层模块的资源只需要通过引用就能拿到自己对应的id，而修改(新增，删除，修改)了资源之后，也只需要重新生成R文件就好了。编译耗时大大减少。</p>
<p>在我们平常打包的时候，反编译apk，再合并资源回编时，也是要重新生成R文件。  </p>
<p>开发时，在其他module代码引用资源文件时,使用以下代码进行索引  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return a resource identifier for the given resource name.  A fully</span><br><span class="line"> * qualified resource name is of the form &quot;package:type/entry&quot;.  The first</span><br><span class="line"> * two components (package and type) are optional if defType and</span><br><span class="line"> * defPackage, respectively, are specified here.</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;Note: use of this function is discouraged.  It is much more</span><br><span class="line"> * efficient to retrieve resources by identifier than by name.</span><br><span class="line"> * </span><br><span class="line"> * @param name The name of the desired resource.</span><br><span class="line"> * @param defType Optional default resource type to find, if &quot;type/&quot; is</span><br><span class="line"> *                not included in the name.  Can be null to require an</span><br><span class="line"> *                explicit type.</span><br><span class="line"> * @param defPackage Optional default package to find, if &quot;package:&quot; is</span><br><span class="line"> *                   not included in the name.  Can be null to require an</span><br><span class="line"> *                   explicit package.</span><br><span class="line"> * </span><br><span class="line"> * @return int The associated resource identifier.  Returns 0 if no such</span><br><span class="line"> *         resource was found.  (0 is not a valid resource ID.)</span><br><span class="line"> */</span><br><span class="line">public int getIdentifier(String name, String defType, String defPackage) &#123;</span><br><span class="line">    return mResourcesImpl.getIdentifier(name, defType, defPackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？"><a href="#为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？" class="headerlink" title="为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？"></a>为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？</h3><p>因为资源id只是表示资源的次序，而不是别的跟资源本身绑定的属性。当到了不同的模块以后，参与编译的资源变多了，那次序肯定会改变。资源id也就改变了。并且子模块的资源id只是引用形式存在于代码中，id具体是什么值并不是很care。</p>
<h3 id="apk或者aab，为什么需要对齐？"><a href="#apk或者aab，为什么需要对齐？" class="headerlink" title="apk或者aab，为什么需要对齐？"></a><em>apk或者aab</em>，为什么需要对齐？</h3><blockquote>
<p>zipalign的主要工作是将apk包进行对齐处理，使apk包中的所有资源文件举例文件起始偏移为4字节的整数倍，这样通过内存映射访问apk时的速度会更快。<br>为什么快呢？如果每个资源的开始位置上都是一个资源之后的4n字节，那么访问下一个资源就不用遍历，直接跳到4字节之后即可 </p>
</blockquote>
<h3 id="apk或者aab混淆的方式有哪些"><a href="#apk或者aab混淆的方式有哪些" class="headerlink" title="apk或者aab混淆的方式有哪些()"></a><em>apk或者aab</em>混淆的方式有哪些()</h3><blockquote>
</blockquote>
<p>压缩(Shrink)：检测并移除代码中无用的类、字段、方法和特性<br>优化(Optimize)：字节码进行优化，移除无用的指令。<br>混淆(Obfuscate)：使用a、b、c、d这样简短而无意义的名称，对垒、字段和方法进行重命名。<br>预检测(Preveirfy)：在Java平台对处理后的代码进行预检测，确保加载class文件是可执行的 </p>
<h3 id="“Android”-64k报错"><a href="#“Android”-64k报错" class="headerlink" title="“Android” 64k报错"></a>“Android” 64k报错</h3><p>应用及第三方库包含的方法数(method)总和超过65536，在开发的时候，会遇到一个构建的错误。<br>指明您的应用达到Android构建规定的应用的限制：</p>
<h4 id="构建错误的原因"><a href="#构建错误的原因" class="headerlink" title="构建错误的原因:"></a>构建错误的原因:</h4><h5 id="dex文件格式的限制"><a href="#dex文件格式的限制" class="headerlink" title="dex文件格式的限制"></a>dex文件格式的限制</h5><p>Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 二进制文件形式的可执行字节码文件，这些文件包含用来运行应用的已编译代码。<br>Dalvik Executable 规范将可在单个 DEX 文件内引用的方法总数限制为 65536 (其中包括 Android 框架方法、库方法以及您自己的代码中的方法)</p>
<h5 id="其他限制"><a href="#其他限制" class="headerlink" title="其他限制"></a>其他限制</h5><p>系统对dex文件进行优化操作时分配的缓冲区大小的限制 ，方法如果超出缓存区，同样也是会报错的。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Handle---消息分发机制(ThreadLocal)</title>
    <url>/2021/07/26/android-Handler%E6%9C%BA%E5%88%B6-1/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Message</td>
<td align="center">消息</td>
<td align="left">使用了享元设计模式 链表的数据结构</td>
<td align="left">详情</td>
</tr>
<tr>
<td align="left">MessageQuene</td>
<td align="center">消息队列</td>
<td align="left">单链表的数据结构</td>
<td align="left">优先级的队列 — 根据时间先后顺序排队的单链表</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="center">message的处理者</td>
<td align="left">即线程间传递的对象，传递的信息包含在其中    Handler的构造函 ，在构造函数中初始化了一个Looper 和 MessageQueue。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ThreadLocal</td>
<td align="center">数据结构是键值对</td>
<td align="left">只有在指定的线程可以获取到存储的数据</td>
<td align="left">获取线程唯一的变量 Theadlocal value 线程内部的数据存储类,使用场景：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本</td>
</tr>
<tr>
<td align="left">Looper</td>
<td align="center">循环器</td>
<td align="left"><img src="code_looper_1.jpg" alt="code_looper"></td>
<td align="left">类Looper的prepare的函数,即是对Looper进行了初始化，将Looper对象引用保存在sThreadLocal中，先保证了Looper和Threadlocal-1V1关系,由于sThreadLocal获取的值是通过获取当前线程获取线程唯一的变量,这样就保证了一个线程只有一个looper</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/">技术小黑屋</a><br><a href="https://www.jianshu.com/p/8fd635f50016">简书-InheritableThreadLocal</a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事物的创造从未有应该或不应该，但被创造出来后如何被人利用却成了最大的问题。</span><br></pre></td></tr></table></figure>
<p>我觉得这个话应用到编程上也是一样的，把自身关注点放到事物是什么背景下创造出来的，了解事物的出生，发展，迭代，衰亡，站在巨人的肩膀上看问题。</p>
<p>深刻理解事物的本质和特性，这也是导致变化的原因，本质影响结果的走向，特性影响过程的变化。<br>无法对现象作出最终解释的理论都是无用的，因为其不能反映客观事实！</p>
<!-- 我们回归正题,要分析他的本质和特性，就要回归本源(看源码)! -->

<h1 id="ThreadLocal-简述"><a href="#ThreadLocal-简述" class="headerlink" title="ThreadLocal 简述"></a>ThreadLocal 简述</h1><p>ThreadLocal是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰。 </p>
<p>ThreadLocal就是提供给每个线程操作变量的工具类，做到了线程之间的变量隔离目的。</p>
<h2 id="TheadLocal-原理及应用场景"><a href="#TheadLocal-原理及应用场景" class="headerlink" title="TheadLocal 原理及应用场景"></a>TheadLocal 原理及应用场景</h2><ul>
<li>ThreadLocal主要有2大特性   </li>
</ul>
<ul>
<li>全局性 线程内可访问  </li>
<li>唯一性 使用ThreadLocal维护变量时，每个线程都会获得该线程独享一份变量副本。</li>
</ul>
<p>这里借鉴下大神的图<br><img src="thread.jpeg" alt="code_looper">  </p>
<hr>
<p>1.每个Thread线程内部都有一个ThreadLocalMap。<br>2.Map里面存储线程本地对象ThreadLocal（key）和线程的变量副本（value）。<br>3.Thread内部的Map是由ThreadLocal维护，ThreadLocal负责向map获取和设置线程的变量值。<br>4.一个Thread可以有多个ThreadLocal。</p>
<p><strong>Thread</strong><br>当我们初始化一个线程的时候,其内部干去创建了一个ThreadLocalMap的Map容器待用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Thread implements Runnable &#123;</span><br><span class="line">    /* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line">     * by the ThreadLocal class. */</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocal</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sets the current thread&#x27;s copy of this thread-local variable to the specified value. </span><br><span class="line">Most subclasses will have no need to override this method, relying solely on the &#123;@link #initialValue&#125; method to set the values of thread-locals.</span><br><span class="line"></span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get the map associated with a ThreadLocal </span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里其实可以发现真正起到作用的其实这个<strong>ThreadLocal内部类ThreadLocalMap</strong>。<br>由于<strong>ThreadLocalMap</strong>的数据结构是Map键值对(K,V)，这里的K是本地线程threadLocals，V是线程的变量副本（value）。</p>
<p>但是这样还是不够，我还是没弄明白ThreadLocal是怎么把变量复制到Thread的ThreadLocalMap中的？</p>
<p>直到我去google到这篇<a href="https://zhuanlan.zhihu.com/p/158033837">文章</a> 😯 😄 😏 </p>
<p>当我们初始化一个线程的时候其内部干去创建了一个ThreadLocalMap的Map容器待用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Thread implements Runnable &#123;</span><br><span class="line">    /* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line">     * by the ThreadLocal class. */</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当ThreadLocalMap被创建加载的时候ThreadLocalMap静态内部类Entry也随之加载，完成初始化动作。<br><strong>ThreadLocalMap</strong>内部类<strong>Entry</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        /** The value associated with this ThreadLocal. */</span><br><span class="line">       Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能到这里大家多少有些困惑，我们重新整理下流程<br>当我们在Thread内部调用set方法时:<br><strong>ThreadLocal</strong><br>1.会去获取调用当前方法的线程Thread。<br>2.然后顺其自然的拿到当前线程内部的ThreadLocalMap容器。<br>3.最后就把变量副本给丢进去。<br>ThreadLocal（就认为是个维护线程内部变量的工具！）只是在Set的时候去操作了Thread内部的·ThreadLocalMap将变量拷贝到了Thread内部的Map容器中，Key就是当前的ThreadLocal,Value就是变量的副本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于涉及的类很多，我们这里把架构图拆分下<br><img src="threadlocal%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="threadLocal架构图">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the value in the current thread&#x27;s copy of this</span><br><span class="line"> * thread-local variable.  If the variable has no value for the</span><br><span class="line"> * current thread, it is first initialized to the value returned</span><br><span class="line"> * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line"> *</span><br><span class="line"> * @return the current thread&#x27;s value of this thread-local</span><br><span class="line"> */</span><br><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null)</span><br><span class="line">            return (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">获取当前线程的ThreadLocalMap对象</span><br><span class="line">从map中根据this（当前的threadlocal对象）获取线程存储的Entry节点。</span><br><span class="line">从Entry节点获取存储的对应Value副本值返回。</span><br><span class="line">map为空的话返回初始值null，即线程变量副本为null。</span><br></pre></td></tr></table></figure>


<h1 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h1><h2 id="Key的弱引用问题"><a href="#Key的弱引用问题" class="headerlink" title="Key的弱引用问题"></a>Key的弱引用问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.</span><br></pre></td></tr></table></figure>
<p>为了处理非常大和生命周期非常长的线程(<strong>usages</strong>)，哈希表使用弱引用作为 key。</p>
<p>ThreadLocal在没有外部对象强引用时如Thread，发生GC时弱引用Key会被回收，而Value是强引用不会回收，如果创建ThreadLocal的线程一直持续运行如线程池中的线程，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p>
<p>key 如果使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。<br>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。</p>
<p>通常ThreadLocalMap的生命周期跟Thread（注意线程池中的Thread）一样长，如果没有手动删除对应key（线程使用结束归还给线程池了，其中的KV不再被使用但又不会GC回收，可认为是内存泄漏），一定会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal会被GC回收，不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除，Java8已经做了上面的代码优化。</p>
<p>总结<br>每个ThreadLocal只能保存一个变量副本，如果想要一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。<br>ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。<br>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>再看看内部的剖析图<br><img src="ThreadLocal%E5%86%85%E9%83%A8%E5%89%96%E6%9E%90%E5%9B%BE.webp" alt="ThreadLocal结果图"></p>
<p>ThreadLocal底层原理是线程内部维护了ThreadLocalMap，至于怎么加载ThreadLocalMap，上面已经有详细的解释了，这里我们不做太多的解释，我们把 Threadlocal 对象作为 key，要存储的的数据作为 value ，这里Threadlocal的对象作为线程局部变量的入口。<br>再扩展一下源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">        // Map中的Entry对象，弱引用类型，key是ThreadLocal对象，value是线程局部变量</span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 初始化容量16，必须是2的幂次方</span><br><span class="line">        private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">        // 存储数据的数组，可扩容，长度必须是2的幂次方 </span><br><span class="line">        private Entry[] table;</span><br><span class="line"></span><br><span class="line">        // table数组的大小</span><br><span class="line">        private int size = 0;</span><br><span class="line"></span><br><span class="line">        // table数组的阈值，达到则扩容</span><br><span class="line">        private int threshold; // Default to 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>再看demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line">    private static final ThreadLocal&lt;String&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 设置线程局部变量</span><br><span class="line">        THREAD_LOCAL.set(&quot;我是你爹&quot;);</span><br><span class="line">        // 使用线程局部变量</span><br><span class="line">        peelChenpi();</span><br><span class="line">        // 删除线程局部变量</span><br><span class="line">        THREAD_LOCAL.remove();</span><br><span class="line">        // 使用线程局部变量</span><br><span class="line">        peelChenpi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void peelChenpi() &#123;</span><br><span class="line">        System.out.println(THREAD_LOCAL.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是你爹</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>我们需要从已知的开始反推。<br>为什么 ThreadLocalMap 内部存储机构是维护一个数组呢？因为一个线程是可以通过多个不同的 ThreadLocal 对象来设置多个线程局部变量的，这些局部变量都是存储在自己线程的同一个 ThreadLocalMap 对象中。通过不同的 ThreadLocal 对象可以取得当前线程的不同局部变量值。</p>
<p>作者：熬夜不加班<br>链接：<a href="https://www.jianshu.com/p/4c3e54656f4a">https://www.jianshu.com/p/4c3e54656f4a</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="ThreadLocal线程安全问题"><a href="#ThreadLocal线程安全问题" class="headerlink" title="ThreadLocal线程安全问题"></a>ThreadLocal线程安全问题</h2><p>ThreadLocal 类中的所有方法都是没有加锁的，因为 ThreadLocal 最终操作的都是对当前线程的 ThreadLocalMap 对象进行操作，既然线程处理自己的局部变量，就肯定不会有线程安全问题</p>
<h2 id="思考之外"><a href="#思考之外" class="headerlink" title="思考之外"></a>思考之外</h2><p>Thread 的 threadLocals 变量是默认访问权限的，只能被同个包下的类访问，所以我们是不能直接使用 Thread 的 threadLocals 变量的，这也就是为什么能控制不同线程只能获取自己的数据，达到了线程隔离。Threadlocal 类是访问它的入口。</p>
<h2 id="ThreadLocal内存泄露"><a href="#ThreadLocal内存泄露" class="headerlink" title="ThreadLocal内存泄露"></a>ThreadLocal内存泄露</h2><p>线程的生命周期都比较长，加上现在普遍使用的线程池，会让线程的生命更加长。<br>不remove，当然不会释放。这和Key，到底是不是弱引用，关系不大。<br>严格来说，ThreadLocal没有内存泄漏问题。有的话，那就是你忘记执行remove方法。这是不正确使用引起的。  </p>
<h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><!-- 我们打开ThreadLocal源码，开头的序言转译一下。 -->
<!-- ```
  This class provides thread-local variables.  These variables differ from
  their normal counterparts in that each thread that accesses one (via its
  {@code get} or {@code set} method) has its own, independently initialized
  copy of the variable.  {@code ThreadLocal} instances are typically private
  static fields in classes that wish to associate state with a thread (e.g.,
  a user ID or Transaction ID).
  此类提供线程局部变量。这些变量不同于它们的正常对应物，因为每个线程访问一个（通过其
  {@code get} 或 {@code set} 方法）有自己的，独立初始化的
  变量的副本。 {@code ThreadLocal} 实例通常是私有的
  希望将状态与线程相关联的类中的静态字段（例如，
  用户 ID 或交易 ID）。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">还有一段很重要的描述</span><br></pre></td></tr></table></figure>
<p>Each thread holds an implicit reference to its copy of a thread-local<br>variable as long as the thread is alive and the {@code ThreadLocal}<br>instance is accessible; after a thread goes away, all of its copies of<br>thread-local instances are subject to garbage collection (unless other<br>eferences to these copies exist).</p>
<p>每个线程都持有一个对其本地线程副本的隐式引用<br>只要线程还活着并且 {@code ThreadLocal} 变量<br>实例可访问；一个线程消失后，它的所有副本<br>线程本地实例受垃圾回收的影响（除非其他<br>存在对这些副本的引用）<br>@author  Josh Bloch and Doug Lea<br>@since   1.2</p>
<pre><code class="--&gt;">




</code></pre>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android App Bundles</title>
    <url>/2021/07/19/google-aab/</url>
    <content><![CDATA[<h1 id="Google-Android-App-Bundles"><a href="#Google-Android-App-Bundles" class="headerlink" title="Google - Android App Bundles"></a>Google - Android App Bundles</h1><p>2018 年的 Google I/O ，Google 向 Android 引入了新 App 动态化框架（即 Android App Bundle，缩写为<strong>AAB</strong>)</p>
<blockquote>
<p>App 动态化框架，动态化概念指的是 Play Dynamic Delivery </p>
<blockquote>
<p><strong>上线要求</strong>:从 2021 年 8 月起，新应用需要使用 Android App Bundle 才能在 Google Play 中发布。  </p>
</blockquote>
</blockquote>
<h2 id="About-Android-App-Bundles"><a href="#About-Android-App-Bundles" class="headerlink" title="About Android App Bundles"></a>About Android App Bundles</h2><blockquote>
<p>Android App Bundle 是一种包含编译后代码和资源文件的新的上传格式（.aab） </p>
</blockquote>
<p>补充:<strong>Android Application Bundle</strong> != <strong>Apk</strong><br>App Bundle 纯粹是为了上传设计的文件，用户无法直接安装和使用它。<br>虽然AAB和Apk本质上都是压缩包,但是内部的目录结构完全不同，以下是一个Abb正常的aab文件结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–BundleConfig.pb ： 打包bundle的时候，自动生成</span><br><span class="line">–base : base目录</span><br><span class="line">——assets: 对应apk的assets目录</span><br><span class="line">——dex: 原apk中classes.dex,classes2.dex…都放这里</span><br><span class="line">——lib: 原apk中lib目录都放这里</span><br><span class="line">——manifest: 原apk的AndroidManifest.xml放这里，需要是编译后的AndroidManifest.xml</span><br><span class="line">——res：apk中的资源放这里，需要是编译后的资源</span><br><span class="line">——root: apk中相对于根目录的其他资源文件</span><br><span class="line">——resources.pb：编译资源的时候会生成的</span><br><span class="line">——assets.pb:编译bundle的时候会生成的</span><br><span class="line">——native.pb: 编译bundle的时候会生成的</span><br></pre></td></tr></table></figure>

<h2 id="Google-Play-Dynamic-Delivery"><a href="#Google-Play-Dynamic-Delivery" class="headerlink" title="Google Play Dynamic Delivery"></a>Google Play Dynamic Delivery</h2><blockquote>
<p>简介:Google Play 推出新 app 交付模式，叫做动态交付 (Dynamic Delivery)，它根据每个用户的设备信息，使用开发者上传的 app bundle 来生成对应的 apk 文件。</p>
<blockquote>
<p><img src="https://conorlee.top/images/blogimages/2019/640.gif" alt="AAB">  </p>
</blockquote>
</blockquote>
<h2 id="Play-Asset-Delivery"><a href="#Play-Asset-Delivery" class="headerlink" title="Play Asset Delivery"></a>Play Asset Delivery</h2><blockquote>
<p>Play Asset Delivery (PAD)可以让依靠 Google Play 来托管和提供你的资产包，PAD提供灵活的分发模式，本质上减少包的体积，让用户更佳的体验,目前分发模式有3种，分别为<br><strong>1.install-time 2.fast-follow 3.on-demand</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分发模式</th>
<th align="center">大小限制</th>
<th align="left">简介</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">install-time  =&gt; 安装时分发</td>
<td align="center">总下载大小上限为1GB</td>
<td align="left">资源包在用户安装应用时进行分发，”预先”资源包</td>
<td align="left">在应用启动是使用，用户无法修改或删除这些资源包</td>
</tr>
<tr>
<td align="left">fast-follow =&gt; 快速跟进式分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包在用户安装应用后立即自动下载</td>
<td align="left">用户无需打开应用即可开始 fast-follow 下载。此类下载不会阻止用户访问应用。</td>
</tr>
<tr>
<td align="left">on-demand =&gt; 按需分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包会在应用运行时进行下载</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意 ！！！</strong>：如果为资源包选择 <strong>install-time 分发类型</strong>，就无需在游戏中使用 <strong>Play Asset Delivery API</strong>。这些资源包与主应用 APK同时安装。<br>目前公司项目使用就是分发模式就是 <strong>install-time</strong></p>
<p>由于google规定需要apk&lt;150m，等于aab中的base目录&lt;150m，如果超出限制，需要把多出的资源迁移到install-time，让google去动态下发资源</p>
<!-- # 软件使用说明
### 需要提前安装的环境   
* 需要自己额外再安装的路径  
    1. python3
    2. aapt  
    3. gradle 
    4. as-pro  ==> 模板工程 
* 该工具内置了反编译的环境 请勿随意修改路径  
    1. apktool  
    2. dex2jar  
    3. smali  

2 需要在该工具路径下/tool/apktool/signature/config/apk.ini文件配置以下路径

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置项 后续看项目的需求支持可增加参数</span><br><span class="line">[config]</span><br><span class="line"># 注意所有配置项需要顶行写，&quot;=&quot; 号两边和行首尾不能有空格</span><br><span class="line"># AS 路径 </span><br><span class="line">as_path=/Users/zhupengbo/Desktop/S3/S3_Hw</span><br><span class="line"># AAB 生成的路径 必填</span><br><span class="line">abb_path=/Users/zhupengbo/tool/apktool/apk/abb</span><br><span class="line"># 版本号和版本名</span><br><span class="line">versionCode=1</span><br><span class="line">versionName=1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.该项目增加了pad配置表<br>3.1 <strong>aab_pad.xls</strong> 配置表路径在 <strong>/apktool/signature/config</strong> 的路径下<br>3.2 配置的方法<br>支持配置<strong>文件路径</strong>和<strong>文件夹</strong><br>S3项目以resource路径下进行配表，该路径包含了游戏内的资源  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置形式为:resource/路径</span><br></pre></td></tr></table></figure>

<p><strong>aab_pad.xls 格式如下-示例</strong></p>
<table>
<thead>
<tr>
<th align="left">Path</th>
</tr>
</thead>
<tbody><tr>
<td align="left">resource/model</td>
</tr>
<tr>
<td align="left">resource/Video</td>
</tr>
<tr>
<td align="left">resource/allRes.json</td>
</tr>
<tr>
<td align="left">resource/ui</td>
</tr>
</tbody></table>
<p>4 该工具支持下终端下执行，调用示例</p>
<pre><code>/Users/zhupengbo/tool/apktool/android_pack.sh /Users/zhupengbo/tool/apktool/apk/apk/AAA.apk
``` --&gt;




</code></pre>
]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo CMD</title>
    <url>/2021/07/19/hexo/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;博客名称&quot;  =&gt; hexo new &quot;博客名称&quot;   #这两个都是创建新文章，前者是简写模式</span><br><span class="line">hexo p  =&gt; hexo publish</span><br><span class="line">hexo g  =&gt; hexo generate  #生成</span><br><span class="line">hexo s  =&gt; hexo server  #启动服务预览</span><br><span class="line">hexo d  =&gt; hexo deploy  #部署  </span><br><span class="line"></span><br><span class="line">hexo server   #Hexo 会监视文件变动并自动更新，无须重启服务器。</span><br><span class="line">hexo server -s   #静态模式</span><br><span class="line">hexo server -p 5000   #更改端口</span><br><span class="line">hexo server -i 192.168.1.1   #自定义IP</span><br><span class="line">hexo clean   #清除缓存，网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g   #生成静态网页</span><br><span class="line">hexo d   #开始部署</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
