<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Google-Android-PFD</title>
    <url>/2023/11/28/Google-Android-PFD/</url>
    <content><![CDATA[<p>| 模块下载选项 |     与条件分发的兼容性  |<br>|:————- |:—————:| :————-| :————-|<br>| 融合 (&lt;dist:fusing dist:include=”true”/&gt;) |     如果某个模块将此选项设为 true，Google Play 在将您的应用部署到搭载 API 级别 19 或更低版本的设备时，不会遵循您指定的按条件分发选项。也就是说，对于搭载 API 级别 19 或更低版本的设备，启用了融合选项的功能模块始终会在安装应用时下载。 |<br>| 支持免安装体验 (&lt;dist:module dist:instant=”true”/&gt;)|     支持免安装体验的功能模块不支持按条件分发选项。  |  |ENGameResource,install_time|<br>| 按需 (<a href="dist:on-demand/">dist:on-demand/</a>) |     默认情况下，如果您指定按条件分发选项，则模块也可按需提供。  | </p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-mmap</title>
    <url>/2023/11/17/linux-mmap/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>聚合SDK-设计</title>
    <url>/2023/11/13/%E8%81%9A%E5%90%88SDK-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="聚合工程"><a href="#聚合工程" class="headerlink" title="聚合工程"></a>聚合工程</h1><p>1.用作客户端接入部分的统一框架 SDK_Client</p>
<p>2.用作服务端统一的逻辑转发和处理中心 SDK_Server</p>
<p>3.用作打包功能的逻辑和多线程的任务调度 SDK_Package</p>
<p>4.用户可视化操作界面和功能配置界面 SDK_Manager</p>
<h1 id="SDK-Package"><a href="#SDK-Package" class="headerlink" title="SDK_Package"></a>SDK_Package</h1><p><img src="https://wp.u2sy.com/wp-content/uploads/2022/03/20220304054007284.png?x-oss-process=image/auto-orient,1/quality,q_90/format,webp" alt="打包工具"></p>
<p>1、打包工具的输入，就是需要打包的 apk 包，也叫母包。游戏里面引入 sdk 抽象层的 jar 包，调用抽象层的接口。完成接入，然后打成 apk。</p>
<p>2、打包工具会首先用 apktool -d 对母包进行反编译。反编译到该渠道对应的临时工作目录中<br>3、重命名包名。我们知道在 AndroidManifet.xml 中的 package 就是包名，为了防止后面我们重新生成 R 文件导致冲突，我们对每个渠道都设置一个后缀。比如 UC，后缀叫.uc。当乐，后缀.dl 等等。如果渠道 SDK 有明确要求，使用他们提供的后缀，那就使用他们提供的后缀。如果没有，就自己设置一个。<br>4、拷贝 SDK 资源。将该渠道对应的 SDK 资源，从对应的 SDK 配置目录中，拷贝到反编译后的临时工作目录中。<br>1）拷贝 SDK 的 assets 目录，libs 目录，res 目录等<br>2）将 classes.dex 也反编译成 smali 格式，拷贝到反编译临时工作目录中<br>3）和 SDK_Manifest.xml 中的内容合并到游戏目录的   AndroidManifest.xml 中  </p>
<p>5、生成游戏中需要使用的配置。<br>1）对于之前 SDK 目录中 config.xml 中配置的 APPID，APPKEY 等信息，根据需要，对于需要添加到 AndroidManifest.xml 中的，我们就将他添加到 AndroidManifest.xml 中的 meta-data 中。对于其他参数，我们会在 assets 目录下生成一个 develop_config.properties 文件。<br>2）对于 SDK 目录下 config.xml 中配置的插件信息，我们会在 assets 目录下，生成一个 plugin_info.xml 文件。这样 SDK 抽象层会读取这个配置来实例化对应的插件。<br>6、重新生成 R 文件。部分渠道需要支持他们的闪屏画面。根据我们的闪屏解决方案（后面会专门来说），我们需要重新生成 R 文件，来索引我们的闪屏资源图片等信息。<br>7、重新打包，采用 apktool -b 重新将合并之后的资源和代码，进行打包<br>8、签名和优化。部分渠道要求使用他们提供的签名文件，所以，我们对签名文件也采用了配置。可以根据不同的渠道来配置不同的签名文件。<br>9、经过以上步骤，一个渠道包就生成了</p>
<h1 id="渠道配置"><a href="#渠道配置" class="headerlink" title="渠道配置"></a>渠道配置</h1><p>静态检测</p>
<p>动态检测</p>
<p>渠道包配置<br>1.闪屏，ICON<br>2.日志系统<br>3.参数<br>4.渠道sdk版本<br>5.包名<br>6.签名方式  v1,v2<br>7.热更 插件化  需要区分国区/海外<br>8.可选配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可选配置--第三方组件</span><br><span class="line">1 统计  </span><br><span class="line">2 分享  </span><br><span class="line">3 推送  </span><br><span class="line">4 打点   </span><br><span class="line">5 买量 头条，广点通</span><br><span class="line"></span><br><span class="line">6加密</span><br><span class="line">6.1.验签 </span><br><span class="line">    smail+服务端验签 </span><br><span class="line">    代码配置</span><br><span class="line">6.2.混淆</span><br><span class="line">    java  </span><br><span class="line">    native  </span><br><span class="line">7.安全</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>






]]></content>
      <tags>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Jni</title>
    <url>/2023/11/10/Android-Jni/</url>
    <content><![CDATA[<h1 id="如何回答面试问题"><a href="#如何回答面试问题" class="headerlink" title="如何回答面试问题"></a>如何回答面试问题</h1><h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-OOM</title>
    <url>/2023/11/02/Android-OOM/</url>
    <content><![CDATA[<h1 id="OOM痛点"><a href="#OOM痛点" class="headerlink" title="OOM痛点"></a>OOM痛点</h1><p>OOM（Out Of Memory）成为奔溃统计平台上的疑难杂症之一，大部分业务开发人员对于线上OOM问题一般都是暂不处理，一方面是因为OOM问题没有足够的log，无法在短期内分析解决，另一方面可能是忙于业务迭代、身心疲惫，没有精力去研究OOM的解决方案。</p>
<p>作者：蓝师傅<br>链接：<a href="https://juejin.cn/post/7074762489736478757">https://juejin.cn/post/7074762489736478757</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="OOM问题分类"><a href="#OOM问题分类" class="headerlink" title="OOM问题分类"></a>OOM问题分类</h1><p>-OOM可以大致归为以下3类：</p>
<ul>
<li>线程数太多</li>
<li>打开太多文件</li>
<li>内存不足</li>
</ul>
<h2 id="线程数太多"><a href="#线程数太多" class="headerlink" title="线程数太多"></a>线程数太多</h2><p>查看系统对每个进程的线程数限制</p>
<blockquote>
<p>cat /proc/sys/kernel/threads-max<br>不同设备的threads-max限制是不一样的，有些厂商的低端机型threads-max比较小，容易出现此类OOM问题</p>
</blockquote>
<h3 id="root手机查看"><a href="#root手机查看" class="headerlink" title="root手机查看"></a>root手机查看</h3><blockquote>
<p>模拟器 部分手机需要root，如小米等硬核  </p>
</blockquote>
<p>查看当前进程运行的线程数</p>
<blockquote>
<p>cat proc/{pid}/status<br>当线程数超过/proc/sys/kernel/threads-max中规定的上限时就会触发OOM。</p>
</blockquote>
<h3 id="真机-ulimit限制"><a href="#真机-ulimit限制" class="headerlink" title="真机 ulimit限制"></a>真机 ulimit限制</h3><p>查看当前总进程限制的线程数</p>
<blockquote>
<p>ulimit -a</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1|rubens:/ $ ulimit -a</span><br><span class="line">-t: time(cpu-seconds)     unlimited</span><br><span class="line">-f: file(blocks)          unlimited</span><br><span class="line">-c: coredump(blocks)      0</span><br><span class="line">-d: data(KiB)             unlimited</span><br><span class="line">-s: stack(KiB)            8192</span><br><span class="line">-l: lockedmem(KiB)        unlimited</span><br><span class="line">-n: nofiles(descriptors)  32768</span><br><span class="line">-p: processes             26248</span><br><span class="line">-i: sigpending            26248</span><br><span class="line">-q: msgqueue(bytes)       819200</span><br><span class="line">-e: maxnice               40</span><br><span class="line">-r: maxrtprio             0</span><br><span class="line">-m: resident-set(KiB)     unlimited</span><br><span class="line">-v: address-space(KiB)    unlimited</span><br><span class="line">-x: filelocks             unlimited</span><br></pre></td></tr></table></figure>
<p>参数解析<br>max memory size - 最大内存限制，在64位系统上通常都设置成unlimited<br>max user processes - 每用户总的最大进程数(包括线程)   总的！！！<br>virtual memory - 虚拟内存限制，在64位系统上通常都设置成unlimited   </p>
<p>既然系统对每个进程的线程数有限制，那么解决这个问题的关键就是尽可能降低线程数的峰值。</p>
<p>查看当前进程运行的线程数</p>
<blockquote>
<p>cat proc/{Pid}/status</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rubens:/ $ cat proc/18425/status</span><br><span class="line">Name:   tudy.pingindemo</span><br><span class="line">Umask:  0077</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   18425</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    18425</span><br><span class="line">PPid:   825</span><br><span class="line">TracerPid:      0</span><br><span class="line">Uid:    10375   10375   10375   10375</span><br><span class="line">Gid:    10375   10375   10375   10375</span><br><span class="line">FDSize: 256</span><br><span class="line">Groups: 9997 20375 50375 99909997 </span><br><span class="line">VmPeak:  6912748 kB</span><br><span class="line">VmSize:  6844832 kB</span><br><span class="line">VmLck:         0 kB</span><br><span class="line">VmPin:         0 kB</span><br><span class="line">VmHWM:    176600 kB</span><br><span class="line">VmRSS:    173880 kB</span><br><span class="line">RssAnon:           48700 kB</span><br><span class="line">RssFile:          123828 kB</span><br><span class="line">RssShmem:           1352 kB</span><br><span class="line">VmData:  1300552 kB</span><br><span class="line">VmStk:      8192 kB</span><br><span class="line">VmExe:         4 kB</span><br><span class="line">VmLib:    179852 kB</span><br><span class="line">VmPTE:      1252 kB</span><br><span class="line">VmSwap:    25156 kB</span><br><span class="line">CoreDumping:    0</span><br><span class="line">THP_enabled:    1</span><br><span class="line">Threads:        27</span><br><span class="line">SigQ:   0/26248</span><br><span class="line">SigPnd: 0000000000000000</span><br><span class="line">ShdPnd: 0000000000000000</span><br><span class="line">SigBlk: 0000000080001204</span><br><span class="line">SigIgn: 0000000000000001</span><br><span class="line">SigCgt: 0000006e400084f8</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 0000000000000000</span><br><span class="line">CapEff: 0000000000000000</span><br><span class="line">CapBnd: 0000000000000000</span><br><span class="line">CapAmb: 0000000000000000</span><br><span class="line">NoNewPrivs:     0</span><br><span class="line">Seccomp:        2</span><br><span class="line">Seccomp_filters:        1</span><br><span class="line">Speculation_Store_Bypass:       thread vulnerable</span><br><span class="line">Cpus_allowed:   ff</span><br><span class="line">Cpus_allowed_list:      0-7</span><br><span class="line">Mems_allowed:   1</span><br><span class="line">Mems_allowed_list:      0</span><br><span class="line">voluntary_ctxt_switches:        169</span><br><span class="line">nonvoluntary_ctxt_switches:     123</span><br></pre></td></tr></table></figure>
<p>参数解析</p>
<blockquote>
<p>当前Threads: 27</p>
</blockquote>
<h4 id="命令-扩展"><a href="#命令-扩展" class="headerlink" title="命令-扩展"></a>命令-扩展</h4><p>ps -ef看到的是进程列表<br>线程可以通过ps -eLf来查看</p>
<p>根据包名查看当前进程</p>
<blockquote>
<p>adb shell ps | grep xxx </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u0_a376      22592&#123;PID&#125;   825 6628656 169584 0  0 S com.study.pingindemo</span><br></pre></td></tr></table></figure>


<p>得到当前进程pid或名字则查看当前所有的线程</p>
<blockquote>
<p>adb shell ps -T | grep {PID} </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u0_a377      26204 26204   825 6804816 189004 0                   0 S tudy.pingindemo</span><br><span class="line">u0_a377      26204 26227   825 6804816 189004 0                   0 S Signal Catcher</span><br><span class="line">u0_a377      26204 26228   825 6804816 189004 0                   0 S perfetto_hprof_</span><br><span class="line">u0_a377      26204 26229   825 6804816 189004 0                   0 S ADB-JDWP Connec</span><br><span class="line">u0_a377      26204 26230   825 6804816 189004 0                   0 S Jit thread pool</span><br><span class="line">u0_a377      26204 26231   825 6804816 189004 0                   0 S HeapTaskDaemon</span><br><span class="line">u0_a377      26204 26232   825 6804816 189004 0                   0 S ReferenceQueueD</span><br><span class="line">u0_a377      26204 26233   825 6804816 189004 0                   0 S FinalizerDaemon</span><br><span class="line">u0_a377      26204 26234   825 6804816 189004 0                   0 S FinalizerWatchd</span><br><span class="line">u0_a377      26204 26235   825 6804816 189004 0                   0 S binder:26204_1</span><br><span class="line">u0_a377      26204 26236   825 6804816 189004 0                   0 S binder:26204_2</span><br><span class="line">u0_a377      26204 26237   825 6804816 189004 0                   0 S binder:26204_3</span><br><span class="line">u0_a377      26204 26244   825 6804816 189004 0                   0 S Profile Saver</span><br><span class="line">u0_a377      26204 26247   825 6804816 189004 0                   0 S RenderThread</span><br><span class="line">u0_a377      26204 26262   825 6804816 189004 0                   0 S Binder:intercep</span><br><span class="line">u0_a377      26204 26263   825 6804816 189004 0                   0 S Timer-0</span><br><span class="line">u0_a377      26204 26264   825 6804816 189004 0                   0 S Timer-1</span><br><span class="line">u0_a377      26204 26265   825 6804816 189004 0                   0 S FramePolicy</span><br><span class="line">u0_a377      26204 26266   825 6804816 189004 0                   0 S launch</span><br><span class="line">u0_a377      26204 26271   825 6804816 189004 0                   0 S mali-event-hand</span><br><span class="line">u0_a377      26204 26272   825 6804816 189004 0                   0 S mali-mem-purge</span><br><span class="line">u0_a377      26204 26273   825 6804816 189004 0                   0 S mali-cpu-comman</span><br><span class="line">u0_a377      26204 26274   825 6804816 189004 0                   0 S ged-swd</span><br><span class="line">u0_a377      26204 26276   825 6804816 189004 0                   0 S hwuiTask0</span><br><span class="line">u0_a377      26204 26277   825 6804816 189004 0                   0 S hwuiTask1</span><br><span class="line">u0_a377      26204 26279   825 6804816 189004 0                   0 S RenderThread</span><br><span class="line">u0_a377      26204 26288   825 6804816 189004 0                   0 S binder:26204_2</span><br><span class="line">u0_a377      26204 26320   825 6804816 189004 0                   0 S queued-work-loo</span><br><span class="line">u0_a377      26204 26346   825 6804816 189004 0                   0 S binder:26204_4</span><br><span class="line">u0_a377      26204 26427   825 6804816 189004 0                   0 S binder:26204_5</span><br><span class="line">u0_a377      26204 26429   825 6804816 189004 0                   0 S 26204-ScoutStat</span><br></pre></td></tr></table></figure>

<h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>在 Android 中，可以使用如下代码来获取当前线程数：</p>
<blockquote>
<p>int threadCount = Thread.activeCount();<br>activeCount() 方法返回当前活动线程的数量，也就是当前线程数。</p>
</blockquote>
<p><strong>注意</strong>：activeCount() 方法只能获取到在 Java 虚拟机中创建的线程数，无法获取到其他线程（例如 C++ 创建的线程）的数量。</p>
<h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p>我们并不清楚到底是哪个部分有问题导致的线程数的增长，所以我们需要一个每1s可以打印一下当前的线程数再通过页面交互来确定到底是哪里出现的问题，可以使用watch命令来完成我们的想法，如下所示：</p>
<blockquote>
<p>watch -n 1 -d ‘adb shell ps -T | grep u0_a589 | wc -l’</p>
</blockquote>
<blockquote>
<p>watch -n 1 -d ‘adb shell ps -T | grep u0_a377 | wc -l’</p>
</blockquote>
<p>操作APP时可以试试的看到线程数的大小，并且通过观察看到那类的线程名字在增多.</p>
<h3 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h3><p>禁用 new Thread<br>不过这种方式存在两个问题：</p>
<p>无法解决老代码的new Thread；<br>对于第三方库无法控制。  </p>
<h3 id="无侵入性的new-Thread-优化"><a href="#无侵入性的new-Thread-优化" class="headerlink" title="无侵入性的new Thread 优化"></a>无侵入性的new Thread 优化</h3><p>创建一个Thread的子类叫ShadowThread吧，重写start方法，调用自定义的线程池CustomThreadPool来执行任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ShadowThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void start() &#123;</span><br><span class="line">        Log.i(&quot;ShadowThread&quot;, &quot;start,name=&quot;+ getName());</span><br><span class="line">        CustomThreadPool.THREAD_POOL_EXECUTOR.execute(new MyRunnable(getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line">        public MyRunnable(String name)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ShadowThread.this.run();</span><br><span class="line">                Log.d(&quot;ShadowThread&quot;,&quot;run name=&quot;+name);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Log.w(&quot;ShadowThread&quot;,&quot;name=&quot;+name+&quot;,exception:&quot;+ e.getMessage());</span><br><span class="line">                RuntimeException exception = new RuntimeException(&quot;threadName=&quot;+name+&quot;,exception:&quot;+ e.getMessage());</span><br><span class="line">                exception.setStackTrace(e.getStackTrace());</span><br><span class="line">                throw exception;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在编译期，hook 所有new Thread字节码，全部替换成我们自定义的ShadowThread，这个难度应该不大，按部就班，<br>我们先确认new Thread和new ShadowThread对应字节码差异，可以安装一个ASM Bytecode Viewer插件，如下所示  </p>
<p>由于将任务放到线程池去执行，假如线程奔溃了，我们不知道是哪个线程出问题，所以自定义ShadowThread中的内部类MyRunnable 的作用是：在线程出现异常的时候，将异常捕获，还原它的名字，重新抛出一个信息更全的异常。</p>
<h1 id="分析线程词"><a href="#分析线程词" class="headerlink" title="分析线程词"></a>分析线程词</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>1.corePoolSize：核心线程数量。核心线程默认情况下即使空闲也不会释放，除非设置allowCoreThreadTimeOut为true。<br>2.maximumPoolSize：最大线程数量。任务数量超过核心线程数，就会将任务放到队列中，队列满了，就会启动非核心线程执行任务，线程数超过这个限制就会走拒绝策略；<br>3.keepAliveTime：空闲线程存活时间<br>4.unit：时间单位<br>5.workQueue：队列。任务数量超过核心线程数，就会将任务放到这个队列中，直到队列满，就开启新线程，执行队列第一个任务。<br>6.threadFactory：线程工厂。实现new Thread方法创建线程  </p>
<h1 id="线程泄露"><a href="#线程泄露" class="headerlink" title="线程泄露"></a>线程泄露</h1><p>1.主要监控native线程的几个生命周期方法：pthread_create、pthread_detach、pthread_join、pthread_exit</p>
<p>2.hook 以上几个方法，用于记录线程的生命周期和堆栈，名称等信息；</p>
<p>3.当发现一个joinable的线程在没有detach或者join的情况下，执行了pthread_exit，则记录下泄露线程信息；</p>
<p>4.在合适的时机，上报线程泄露信息</p>
<p>3 打开太多文件<br>Linux 系统一切皆文件，进程每打开一个文件就会产生一个文件描述符fd（记录在/proc/pid/fd下面）</p>
<p>cd /proc/10654/fd</p>
<p>ls</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Activity启动过程</title>
    <url>/2023/11/02/Android-Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="代理方式"><a href="#代理方式" class="headerlink" title="代理方式"></a>代理方式</h1><p>1.代理方式插件化实现</p>
<p>未安装的 APK文件是可以通过 DexClassLoader 来加载、运行的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private DexClassLoader createDexClassloader(String apkPath) &#123;</span><br><span class="line">        File file = mContext.getDir(&quot;dex&quot;,Context.MODE_PRIVATE);</span><br><span class="line">        return new DexClassLoader(apkPath,file.getAbsolutePath(),null,mContext.getClassLoader());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中 ：<br>1、mContext 是一个 Context类型的对象。<br>2、apkPath 就是 apk 在手机中的绝对路径（示例中是从 assets 中复制到手机中的）。 3、file.getAbsolutePath() 就是 APK 解压出的 dex 的存放目录。</p>
<p>这里返回的 loader 就是一个可以加载 APK 的 ClassLoader。然后通过 ClassLoader 加载这个 APK 的默认启动的 Activity，并且通过反射调用这个插件 Activity 的 onCreate,onStart,onResume 函数就可以加载这个应用。</p>
<p>资源加载</p>
<p>资源的加载需要 Resouces ，而创建 Resouces 需要 AssetManager，因此，先创建 AssetManager，再创建 Resouces.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private AssetManager createAssetManager(String apkPath) &#123;</span><br><span class="line">      AssetManager am = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          //反射构造 AssetManager</span><br><span class="line">           am =  AssetManager.class.newInstance();</span><br><span class="line">          Method method = AssetManager.class.getDeclaredMethod(&quot;addAssetPath&quot;,String.class);</span><br><span class="line">          //通过反射 将 apk 的目录添加到 AssetManager 的资源路径下</span><br><span class="line">          method.invoke(am,apkPath);</span><br><span class="line">          return am;</span><br><span class="line"></span><br><span class="line">      &#125; catch (InstantiationException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      return am;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>2.Hook方式实现</p>
<p>Hook目的是替换掉系统默认逻辑</p>
<h1 id="Activity-启动过程"><a href="#Activity-启动过程" class="headerlink" title="Activity 启动过程"></a>Activity 启动过程</h1><p>插件化支持首先要解决的一点就是插件里的 Activity 并未在宿主程序的 AndroidMainfest.xml 注册。常规方法肯定无法直接启动插件的 Activity，这个时候就需要去了解 Activity 的启动流程。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>Activity 调用 startActivity，实际会调用 Instrumentation 类的 execStartActivity 方法，<br>Instrumentation 是系统用来监控 Activity 运行的一个类，</p>
<p>1.Activity 调用 startActivity，实际会调用 Instrumentation 类的 execStartActivity 方法，Instrumentation 是系统用来监控 Activity 运行的一个类，Activity 的整个生命周期都有它的影子。<br>2.通过跨进程的 Binder 调用，进入到 ActivityManagerService 中，其内部会处理 Activity 栈。之后又通过跨进程调用进入到需要调用的 Activity 所在的进程中。<br>3.ApplicationThread 是一个 Binder 对象，其运行在 Binder 线程池中，内部包含一个 H 类，该类继承于类 Handler。ApplicationThread 将启动需要调用的 Activity 的信息通过 H 对象发送给主线程。<br>4.主线程拿到需要调用的 Activity 的信息后，调用 Instrumentation 类的 newActivity 方法，其内通过 ClassLoader 创建 Activity 实例。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>SDK-Server</title>
    <url>/2023/10/30/SDK-Server/</url>
    <content><![CDATA[<h1 id="sdkserver"><a href="#sdkserver" class="headerlink" title="sdkserver"></a>sdkserver</h1><p>聚合sdk<br>SDK接入主要是接第三方平台的登录和支付流程，以手机游戏为例，第三方平台就是国内较大的游戏中心和手机应用商店。<br>游戏商开发手机游戏的流程：<br>1、开发完游戏逻辑<br>2、接入第三方SDK渠道的登录和支付，并且和第三方联调完成后打包客户端——<br>3、客户端上传到第三方游戏平台<br>4、第三方游戏平台审核通过后上架到游戏中心或者手机应用商店供玩家下载——<br>5、玩家安装客户端后采用滚服的方式来分散玩家，同时每个服每周更新新的活动<br>6、玩家支付，会根据手机的渠道类型调用对应的第三方SDK支付工具进行支付，然后返回支付信息给游戏商的支付服确认支付信息，游戏商支付服确认支付信息完成后调用游戏服发放充值道具<br>注意：<br>1、客户端一般都是定义一个抽象的SDK接入接口，然后不同渠道的SDK接入到客户端时都实现这个接口。<br>2、目前出现较多的专门做SDK接入的公司和机构，这种统一的SDK接入渠道有：棱镜sdk，AnySDK，易接，U8SDK（第三方渠道SDK接入框架）。但是统一的SDK接入渠道并不能支持所有的SDK接入，所有不支持的SDK还是需要游戏商自己去接入。<br>3、统一的SDK接入框架相当于是将游戏客户端接入到一个代理SDK接入的工具上，这个工具会自动帮你登录和支付的接入，从而简化流程。<br>4、但是带来的问题就是游戏商的登录和支付玩家数据要走代理SDK接入的工具，这样就会让除游戏平台和游戏商之外的专门做SDK接入代理的公司掌握你的游戏玩家数据。棱镜sdk，AnySDK，易接三大公司都是这样的模式。 但是不一样的是U8SDK，U8SDK是代码完全开源的，也就是说游戏商可以下载到这个SDK接入代理工具的所有源码，在自己的游戏商本地搭建一个U8SDK服务器（U8Server渠道SDK统一用户登录认证中心和支付中心)，这样数据走的就是自己的U8SDK服务器，不会担心泄露的问题。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">手机游戏的登录过程：  </span><br><span class="line">手机游戏的用户账户信息主要是由SDK也就是第三方游戏平台提供。SDK客户端是封装在客户端里面的。手机游戏包里面用的都是SDK客户端的登录页面，游戏本身没有登录机制  </span><br><span class="line">1、游戏客户端在SDK客户端上注册账户信息，SDK客户端发送请求把用户名和密码给SDK服务器，SDK服务器收到后和数据库中信息进行验证，验证通过后，将用户账户信息存入session中，并生成唯一标示sessionId。然后SDK服务器返回响应给客户端验证是通过unionid（渠道ID）和sessionId。  </span><br><span class="line">2、SDK客户端拿到sessionId，因为游戏客户端和SDK客户端是封装在一起的，所以也相当于游戏客户端拿到SessionId。客户端将SessionId存放在本地的cookies中。  </span><br><span class="line">以上就完成整个注册和第一次的登陆过程。  </span><br><span class="line">3、用户第二次打开客户端登录页面（登录页面尚未加载完）时，客户端发送请求给游戏服务器请求登录，此时会将cookies中的数据作为请求的一个字段发送给游戏服务器。也就是发送uid（unionId--渠道Id）和sessionId给游戏服务器。  </span><br><span class="line">以下部分就是游戏服务器登录流程要做的工作。  </span><br><span class="line">4、游戏服务器将uid和SessionId，MD5编码成签名sign字段（编码成sign字段的目的是防止在发送请求的过程中uid和sessionId被篡改），发给SDK服务器校验。  </span><br><span class="line">5、SDK服务端根据sessionId找到对应的session，然后验证uuid是否一致。返回校验结果  </span><br><span class="line">6、校验正确后，游戏服务器保存用户登录信息到LoginBean中，返回服务器列表给游戏客户端。  </span><br></pre></td></tr></table></figure>
<p><a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>游戏SDK解释：<br>手机游戏中sdk接入简单理解就是用他们的平台登录，比如91sdk是91助手平台，360sdk是360平台。<br>软件开发工具包广义上指辅助开发某一类软件的相关文档、范例和工具的集合。<br>软件开发工具包是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等创建应用软件的开发工具的集合，一般而言SDK即开发 Windows 平台下的应用程序所使用的 SDK。它可以简单的为某个程序设计语言提供应用程序接口 API 的一些文件，但也可能包括能与某种嵌入式系统通讯的复杂的硬件。一般的工具包括用于调试和其他用途的实用工具。SDK 还经常包括示例代码、支持性的技术注解或者其他的为基本参考资料澄清疑点的支持文档。<br>为了鼓励开发者使用其系统或者语言，许多 SDK 是免费提供的。软件工程师通常从目标系统开发者那里获得软件开发包，也可以直接从互联网下载，有时也被作为营销手段。例如，营销公司会免费提供构建SDK 以鼓励人们使用它，从而会吸引更多人由于能免费为其编程而购买其构件。<br>SDK 可能附带了使其不能在不兼容的许可证下开发软件的许可证。例如产品供应商提供一个专有的 SDK 可能与自由软件开发抵触。GPL 能使 SDK 与专有软件开发近乎不兼容。LGPL 下的 SDK 则没有这个问题。  </p>
]]></content>
  </entry>
  <entry>
    <title>逆向基础-Android</title>
    <url>/2023/10/28/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80-Android/</url>
    <content><![CDATA[<h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>核心技术</p>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>静态检测<br>动态检测  </p>
<h3 id="Java代码保护"><a href="#Java代码保护" class="headerlink" title="Java代码保护:"></a>Java代码保护:</h3><p>1.JAR文件加壳<br>2.JAR文件代码抽离<br>3.JAR文件代码虚拟化。  </p>
<h3 id="SO文件保护"><a href="#SO文件保护" class="headerlink" title="SO文件保护:"></a>SO文件保护:</h3><p>1.SO加壳。<br>2.SO Linker。<br>3.SO防调用。<br>4.SO VMP。  </p>
<h4 id="SO处理思路"><a href="#SO处理思路" class="headerlink" title="SO处理思路"></a>SO处理思路</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.SO加壳	</span><br><span class="line">对C/C++源码编译出来的SO文件进行加壳，使SO文件无法正确反编译和反汇编。</span><br><span class="line">2.SO源码虚拟化保护	</span><br><span class="line">对SO文件进行虚拟化保护，实现数据隐藏、防篡改、防Dump，增加逆向分析的难度。</span><br><span class="line">3.SO防调用	</span><br><span class="line">对SO文件进行授权绑定，防止SO文件被非授权应用调用运行。</span><br><span class="line">4.SO Linker	</span><br><span class="line">代码段加密压缩、字符串加密压缩、导出表加密压缩、函数动态加解密。</span><br><span class="line">5.SO源码混淆	</span><br><span class="line">常量字符串加密、控制流扁平化、分裂基本块、等价指令替换、虚假控制流、控制流间接化。</span><br></pre></td></tr></table></figure>


<h3 id="防Java层调试"><a href="#防Java层调试" class="headerlink" title="防Java层调试"></a>防Java层调试</h3><p>防止集成SDK时通过IDE（Eclipse/Android Studio等）调试SDK的Java代码，防止逆向调试Dex中的smali代码。</p>
<h3 id="防调用"><a href="#防调用" class="headerlink" title="防调用"></a>防调用</h3><p>防止SDK被非授权的第三方应用进行非法集成调用。</p>
<h3 id="防native层调试"><a href="#防native层调试" class="headerlink" title="防native层调试"></a>防native层调试</h3><p>通过对进程状态、端口、信号的实时监听探测保护SDK不被native层动态调试。</p>
<h1 id="so科普篇"><a href="#so科普篇" class="headerlink" title="so科普篇"></a>so科普篇</h1><p>so文件本质上也是一种ELF文件。<br>ELF（Executable and Linkable Format）文件是一种常见的二进制文件格式，用于在类Unix系统中表示可执行程序、共享库、目标文件和其他可加载的二进制文件。它是一种灵活的文件格式，广泛用于Linux、Unix和类Unix操作系统，以及一些嵌入式系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查看手机进程</span><br><span class="line">adb shell ps</span><br><span class="line">// --找到当前包名对应的pid,比如是1001</span><br><span class="line"></span><br><span class="line">// 进入手机控制台</span><br><span class="line">adb shell</span><br><span class="line">1960</span><br><span class="line">cd /proc/1001  //上面找到的pid 1001</span><br><span class="line">su // 直接查看cat maps可能提示无权限，所以需要提升权限</span><br><span class="line">cat maps  </span><br><span class="line"></span><br><span class="line">//以下是cat maps的结果</span><br><span class="line">....</span><br><span class="line">8fb8c000-8fb93000 r-xp 00000000 fd:20 22465 /data/app/com.kongge.solibencryption-ns70YbB0b5JyL9sKnYs4Q==/lib/x86/libDataEncryptionLib.so</span><br><span class="line">8fb93000-8fb95000 r-xp 00007000 fd:20 22465 /data/app/com.kongge.solibencryption-ns70YbB0b5JyL9sKnYs4Q==/lib/x86/libDataEncryptionLib.so</span><br><span class="line">...</span><br><span class="line">// 第一个8fb8c000就是基地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title>JL</title>
    <url>/2023/10/24/JL/</url>
    <content><![CDATA[<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历，希望能有个面试机会，也期待能有机会和您共事。</p>
<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul>
<li>朱蓬勃/男/1996 </li>
<li>专/广东岭南职业技术学院-计算机系 </li>
<li>工作年限：5年</li>
<li>技术博客：<a href="http://zhupengbo.com/2023/10/24/JL">Elroy-Pb</a> 已适配移动端）</li>
<li>期望职位：Android高级程序员</li>
<li>自我评价 </li>
</ul>
<ol>
<li>学习能力和适应能力强，能独立钻研并解决问题</li>
<li>为人随和，善于沟通，具备团队合作精神及责任感</li>
<li>对游戏逆向有兴趣</li>
</ol>
<hr>
<h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>主攻Android</p>
<h2 id="广州拓动网络科技有限公司-研发一体"><a href="#广州拓动网络科技有限公司-研发一体" class="headerlink" title="广州拓动网络科技有限公司(研发一体)"></a>广州拓动网络科技有限公司(研发一体)</h2><p>时间：2018年5月 - 2019年8月<br>公司：广州拓动网络科技有限公司(研发一体)<br>部门：技术支持部门<br>岗位：Android开发工程师</p>
<h3 id="烈火皇城-国内"><a href="#烈火皇城-国内" class="headerlink" title="烈火皇城-国内"></a>烈火皇城-国内</h3><p>简介：烈火皇城是Cocos2d-x研发的大型MMORPG传奇手游。<br>工作内容：<br>1.解决游戏与SDK(Qucik,易接等等)接入的开发问题，BUG，机型适配和不同版本的兼容。<br>2.主要负责处理游戏产品Android渠道(5+7+长尾)上线的要求。<br>3.对AppStore合作游戏主要做二次混淆方面的处理</p>
<h3 id="自研SDK"><a href="#自研SDK" class="headerlink" title="自研SDK"></a>自研SDK</h3><p>简介：拓动<strong>渠道SDK</strong>，主要提供给CP接入。<br>项目职责：<br>1.配合产品的需求完成架构和模块设计、编码、测试工作，从0到1完成SDK的开发。<br>2.接入我方公司SDK发行公司提供技术支持，线上问题定位，<br>3.根据运营的需求维护，更新，优化SDK。  </p>
<h5 id="技术点："><a href="#技术点：" class="headerlink" title="技术点："></a>技术点：</h5><p>1.项目使用MVP模式作架构。<br>2.集成微信支付、支付宝支付功能。<br>3.使用Git作为整个SDK项目的代码版本控制。    </p>
<h2 id="广州千熙网络科技有限公司"><a href="#广州千熙网络科技有限公司" class="headerlink" title="广州千熙网络科技有限公司"></a>广州千熙网络科技有限公司</h2><p>时间：2019年9月 - 2020年6月<br>部门：发行技术部门<br>任职：Android开发工程师   </p>
<h3 id="聚合sdk"><a href="#聚合sdk" class="headerlink" title="聚合sdk"></a>聚合sdk</h3><p>项目职责:<br>1.对接投放和市场的上线推广计划，投放买量的计划，接入对应SDK(巨量引擎，腾讯广点通等等)<br>2.Android游戏接入SDK,反编译和重打包，签名。<br>3.配合运营，聚合SDK接入渠道SDK。<br>4.对聚合打包（Python）工具开发和升级。<br>5.定期整合更新技术文档，运营及商务对接文档。  </p>
<h5 id="技术点"><a href="#技术点" class="headerlink" title="技术点:"></a>技术点:</h5><p>1.把原有MVC的聚合SDK调整为MVP模式架构。<br>2.使用Python-进行多渠道自动化打包。<br>3.对Apk反编译和重打包，签名，渠道资源并入。<br>4.使用模块化管理工程，基于AndroidStudio的Gradle构建系统进行单模块的处理。  </p>
<h2 id="广州烁日网络科技有限公司-研发"><a href="#广州烁日网络科技有限公司-研发" class="headerlink" title="广州烁日网络科技有限公司(研发)"></a>广州烁日网络科技有限公司(研发)</h2><p>时间：2020年9⽉ - 2022年5⽉<br>任职：Android游戏工程师<br>项目：彩虹物语 - Unity3d研发的大型MMORPG手游(海外+国内)。<br>项目职责:<br>1.适配Android新版本特性和兼容，主要针对海外市场需求，如Google强制要求aab格式。<br>2.负责完成SDK的对接，调试，配置参数，上线，维护等工作。<br>3.根据运营需求，配合Unity技术开发人员，构建游戏中台。<br>4.负责公司Android/IOS包体对接渠道sdk登录/支付等的游戏交互接口设计。  </p>
<h5 id="技术点-1"><a href="#技术点-1" class="headerlink" title="技术点:"></a>技术点:</h5><p>1.把原有Android项目架构调整为成MVVM结构。<br>2.把原本.net打包系统升级为基于集成（CI/CD）Jenkins，使用Shell+Python脚本和引擎自带命令实现游戏自动构建，自动编译，多渠道打包。<br>3.对OC进行混淆，SDK层面混淆，方法名，类名，垃圾代码，上架Appstore。  </p>
<hr>
<hr>
<h2 id="广州星朔网络科技有限公司"><a href="#广州星朔网络科技有限公司" class="headerlink" title="广州星朔网络科技有限公司"></a>广州星朔网络科技有限公司</h2><p>任职：SDK游戏工程师<br>时间：2022年 5⽉- 至今<br>参与项目:   </p>
<ol>
<li>《全民祖玛》Cocos2d-x   </li>
</ol>
<ul>
<li>《全民祖玛》负责游戏研发项目的技术项目管理工作，从研发到上线运营的完整经验。  </li>
</ul>
<ol start="2">
<li>AndroidSDK-发行工具组</li>
</ol>
<ul>
<li>对接海外google-play功能。 </li>
<li>对接国内的Android广告业务，包含内购和广告。</li>
</ul>
<p>负责内容：<br>1.对广告核心组件的设计，如联调后台实现广告逻辑的控制。<br>2.负责游戏SDK产品的打包，维护与更新打包工具。(海外为gradle-aar打包，国内为反编译打包)<br>3.负责游戏SDK发行渠道接入跟进，开发与维护工作。<br>4.对接海外Google-play的功能。<br>5.负责海外谷歌AB面切换。<br>6.处理游戏与设备兼容的版本问题。</p>
<h1 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h1><p>了解游戏SDK设计和逻辑<br>熟悉Android存储的机制，Android内存管理，进程通信<br>对主流引擎Unity3d，Cocos2d-x的引擎有了解<br>熟练动态调试Apk，处理Android中的OOM、ANR异常<br>熟悉聚合SDK,如U8SDK,QuickSDK<br>熟悉Gradle自动构建工具</p>
<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul>
<li>手机：15815337432  </li>
<li>Email：<a href="mailto:&#122;&#x68;&#117;&#112;&#x65;&#x6e;&#103;&#x62;&#111;&#x31;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#122;&#x68;&#117;&#112;&#x65;&#x6e;&#103;&#x62;&#111;&#x31;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a> (海外)/ <a href="mailto:&#x31;&#53;&#x38;&#49;&#53;&#51;&#x33;&#55;&#x34;&#x33;&#50;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;">&#x31;&#53;&#x38;&#49;&#53;&#51;&#x33;&#55;&#x34;&#x33;&#50;&#x40;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a>(国内)  </li>
<li>微信号：Elroy-Pb  </li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>个人成长</tag>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-性能优化的基本思路</title>
    <url>/2023/10/22/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h1><h1 id="如何监视性能？"><a href="#如何监视性能？" class="headerlink" title="如何监视性能？"></a>如何监视性能？</h1><h1 id="一般常用的检测性能方式是什么？"><a href="#一般常用的检测性能方式是什么？" class="headerlink" title="一般常用的检测性能方式是什么？"></a>一般常用的检测性能方式是什么？</h1><h1 id="监视性能的框架的架构？"><a href="#监视性能的框架的架构？" class="headerlink" title="监视性能的框架的架构？"></a>监视性能的框架的架构？</h1><h1 id="如何提前评估"><a href="#如何提前评估" class="headerlink" title="如何提前评估"></a>如何提前评估</h1><p>leakcannery原理，block检测，crash监视，ANR产生的原因</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android-2023-10-23权限申请的变更</title>
    <url>/2023/10/17/Android-2023-10-23%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E7%9A%84%E5%8F%98%E6%9B%B4/</url>
    <content><![CDATA[<h1 id="Android-权限申请的变更"><a href="#Android-权限申请的变更" class="headerlink" title="Android-权限申请的变更"></a>Android-权限申请的变更</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Android 13 代号「提拉米苏（Tiramisu）」</span><br></pre></td></tr></table></figure>
<p>Android-13 对比 Android-12的变化，</p>
<h2 id="更严格的通知权限"><a href="#更严格的通知权限" class="headerlink" title="更严格的通知权限"></a>更严格的通知权限</h2><p>为什么要限制前台服务？</p>
<p>App通过通知系统来告知用户，让应用得以获取用户的注意焦点来提升运行<strong>优先级</strong>，并最终得以完成任务。在我看来这是很聪明的做法，如今这样的机制也已经成为应用确保任务完成的重要手段。</p>
<p>所以将二者结合起来可以得出的另一种事实却是，只要应用保证通知正常显示，它的前台服务就能持续保持运行。只要规律存在漏洞，就会被有心人利用，对用户的隐私会造成隐患。</p>
<p>针对这类情况，必要的检测和停用手段是必须的。Android 13 这次引入的前台服务管理器终于补上了这一环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用会在首次运行时向弹出请求窗口向用户请求许可，然后由用户决定是拒绝还是许可。但在 Android 12 或更早的系统版本中，通知权限则是一个安装时默认授予权限，具体的行为也是可以由应用开发者自己来定义的</span><br></pre></td></tr></table></figure>
<p>不过从上面的介绍中也不难看出，前台服务主要有两大特点：<br>1.即使用户停止与应用的交互，仍能继续运行<br>2.执行过程中必须显示通知</p>
<h3 id="如何检测和停用"><a href="#如何检测和停用" class="headerlink" title="如何检测和停用"></a>如何检测和停用</h3><p><img src="android-13.jpg" alt="Android-13 前台管理器"></p>
<p>Android 13 这次引入的 FGS前台任务管理器</p>
<p>防范管控的第一步，自然是先将所有前台服务的应用罗列出来。Android 13 的快速开关面板在重新布局的同时，底部也多出了一栏「前台服务管理器」，点击展开后即可看到当前正在活跃的应用，点击对应的「停止」按钮就能一键让应用停止运行，可谓是相当「快准狠」的管理方式。</p>
<p>Android 13 为 App 的通知新增了运行时权限「POST_NOTIFICATIONS」，用户能够自由的选择通知的时间、位置，甚至是设置为「不用时移除权限」。这种限制类似于对于位置、话筒、相机、应用列表的权限设置。</p>
<p>其次 Android 系统也会帮助用户对前台服务进行监督，具体的机制是，在以 24 小时为单位的时间长度内，如果某应用的前台服务运行超过 20 小时，系统就会发送通知告诉「XX 已经长时间后台运行，点击查看详情」。这时点击通知也会跳转到上述前台服务任务管理器当中。</p>
<p>根据 Android 13 现阶段的设计，针对同一应用这样的警告通知不会在 30 天内重复出现。另外也不是所有应用都会出现在前台服务管理器中，系统级应用、紧急安全相关应用不会出现在这个列表中；部分应用会出现在这个列表中但没有「停止」按钮，比如激活设备所有方的应用、拨号应用等。</p>
<h3 id="与「划卡强杀」的区别"><a href="#与「划卡强杀」的区别" class="headerlink" title="与「划卡强杀」的区别"></a>与「划卡强杀」的区别</h3><p><img src="diff.png" alt="划卡强杀"></p>
<p>在关于前台服务管理器的相关文档中，我们也得以第一次看到现代 Android 对「多任务界面上划应用卡片」这个行为的定义，以及它和前台服务管理器的实际区别</p>
<p>绿色守护和部分厂商的「划卡强杀」其实更接近最右侧的 Force stop，也就是强行停止。现在进入到应用管理的详情页也依旧能够看到这个按钮，被强行停止的应用会停止一切活动，一般来说不能再自行启动，只能用户手动或其余应用拉起才能恢复运行。</p>
<p>前台服务管理器的停止按钮除了会暂停前台服务，也会将应用从 RAM 中驱离。需要注意的是，此时应用只是停止了运行，并不会从多任务窗口中移除，这一考虑或许是为了方便用户快速恢复任务，同时减少系统资源消耗。</p>
<h2 id="严格控电-续航"><a href="#严格控电-续航" class="headerlink" title="严格控电-续航"></a>严格控电-续航</h2><p>Android 13的目标之一是通过全新的、更严格的电池控制方案，来优化熄屏后App的电源消耗，从而最大化设备体验</p>
<h3 id="Android-13对文件权限的改进"><a href="#Android-13对文件权限的改进" class="headerlink" title="Android-13对文件权限的改进"></a>Android-13对文件权限的改进</h3><p><img src="%E5%8F%82%E8%80%83%E5%BB%BA%E8%AE%AE.png" alt="统一适配参考建议"></p>
<p>尽管 Android 11 引入了很多人心心念念的分区存储机制来改善私有目录滥用的乱象，但部分国产应用很快又学会了将用户和设备标识文件伪装成图片，然后将 /Pictures 这类公有目录变成新的用户隐私数据交换中心的新方案。</p>
<p>针对需要访问文件权限的做法，Android 13 这次将媒体文件权限进一步细分。已经适配 Android 11的应用（目标 API 等级 33）在 Android 13 中能够获取到的文件读写权限被分成了音频2、视频3和图片4，在实际使用过程中，应用可以根据实际情况将这三种权限灵活组合起来。</p>
<h2 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h2><p>Android 操作系统版本的更新通常伴随着对应用程序权限系统的调整和改变。这些变更旨在增强用户的隐私保护和提供更细粒度的权限控制。以下是一些 Android 权限系统的变更和改进的常见示例：</p>
<p>运行时权限控制：从 Android 6.0（Marshmallow）开始，Android 引入了运行时权限控制，允许用户在应用程序安装后，根据需要授予或拒绝应用程序特定权限的访问权，如访问相机、位置、联系人等。</p>
<p>危险权限：Android 权限被分为普通权限和危险权限。危险权限需要用户明确同意，而普通权限在应用安装时自动授予。在较新的 Android 版本中，某些危险权限的使用受到更严格的控制。</p>
<p>存储权限：在 Android 10 及更高版本中，存储权限发生了重大变化。应用程序需要逐个请求访问外部存储的权限，并在其清单文件中声明 MANAGE_EXTERNAL_STORAGE权限以访问全部存储。这是为了增强隐私保护和减少对外部存储的滥用。</p>
<p>一次性权限：在 Android 11 及更高版本中，用户可以授予应用程序一次性访问位置、麦克风和相机等权限，而不是永久性地授予权限。</p>
<p>位置权限：在较新的 Android 版本中，位置权限的访问变得更加严格，用户可以选择只允许应用程序在使用时访问位置数据，而不是一直允许。</p>
<p>通知权限：在 Android 版本中，通知权限系统也有所改进，用户可以更好地控制和管理应用程序的通知。</p>
<p>访问后台位置：在 Android 11 及更高版本中，访问后台位置数据的权限更加受到限制，应用程序需要满足更高的要求才能访问后台位置数据。</p>
<p>请注意，每个 Android 版本的权限系统可能有所不同，具体的变化和改进可能会因版本而异。要了解特定 Android 版本的权限变更，请查阅相关的 Android 开发者文档或官方发布说明。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome-to-C++</title>
    <url>/2023/10/05/Welcome-to-C/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>code ==&gt; compiler ==&gt; produces mechine code for your target platform（为目标平台生成机器代码)</p>
<p>mechine code then contains the actual instructions that the target CPU can execute。(机器代码包含目标CPU可以执行的指令)</p>
<p>所以使用C++是可以单独控制目标CPU每条指令。</p>
<h2 id="How-C-Works"><a href="#How-C-Works" class="headerlink" title="How C++ Works"></a>How C++ Works</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int num = 42;</span><br><span class="line">    cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The value of num is: &quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br></pre></td></tr></table></figure>
<p>C++中的#符号通常被用于预处理器指令，这些指令在编译实际的C++代码之前被执行<br>#include &lt;该文件的所有内容&gt; ==<br>include will look for a file and will simply take the entire contents of the iostream file and paste it into our main.cpp. </p>
<p>Once preprocessing is finished,our file will be complied,</p>
]]></content>
  </entry>
  <entry>
    <title>Linux-进程管理</title>
    <url>/2023/08/23/Linux-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>Linux中的进程于Windows相比是很轻量级的，而且不严格区分进程和线程，线程不过是一种特殊的进程。</p>
</blockquote>
<h1 id="Linux-进程管理"><a href="#Linux-进程管理" class="headerlink" title="Linux-进程管理"></a>Linux-进程管理</h1><p>现代的操作系统提供2种虚拟机制，虚拟处理器和虚拟内存。</p>
<h1 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h1><blockquote>
<p>进程描述符的存放–PID<br>内核通过一个唯一的进程标识值(process identification value)或PID来标识每个进程。<br>PID是一个数，表示为pid_t隐含类型，实际上就是一个int类型。<br>PID实际上就是系统中允许同时存在的进程的最大数目。<br>PID的最大默认值为32768（受&lt;linux/thread.h&gt;中所定义PID最大值的限制），可通过/proc/sys/kernel/pid_max来查看</p>
</blockquote>
<h2 id="Andorid的进程描述符"><a href="#Andorid的进程描述符" class="headerlink" title="Andorid的进程描述符"></a>Andorid的进程描述符</h2><p>PID同样在Android上可以体现到，当你用AS启动调试App，在调试处可以看到这个值。</p>
<blockquote>
<p>内核把进程的列表存放在任务队列的双向循环链表中</p>
</blockquote>
<ul>
<li>每一项都是类型为 task_struct , 称为进程描述符的结构. 在 &lt;linux/sched.h&gt; 文件中<br>task_struct 在 32 位机器上, 大约为 1.7KB</li>
<li>通过 slab 分配器分配 task_struct 结构</li>
<li>用 PID 来标识每个进程. 最大值为 32768 (short int 的最大值). PID 存放在进程描述符中. cat /proc/sys/kernel/pid_max</li>
<li>进程描述符中的 state 描述了进程的当前状态</li>
<li>TASK_RUNNING : 这是在用户空间唯一的可能状态</li>
<li>TASK_INTERRUPTIBLE : 可中断 – 进程正在睡眠(也称为阻塞), 等待某些条件达成. 一旦达成, 内核就会把进程状态设置为运行.</li>
<li>TASK_UNINTERRUPTIBLE : 不可中断 – 除了就算接收到信号也不会被唤醒或准备投入运行外, 这个状态与可中断状态相同.</li>
<li>_TASK_TRACED : 被其他进程跟踪. 例如通过 ptrace 对调试程度进行跟踪</li>
<li>_TASK_STOPPED : 停止. 进程停止执行. 通常是接收到信号: SIGSTOP, SIGTSTP, SIGTTIN, SIGTOU 等.</li>
<li>进程家族树. 所有进程都是 PID 为 1 的 init 进程的后代. task_struct 中的 parent 指向父进程. children 指向子进程链表</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder-老生常谈</title>
    <url>/2023/08/15/Binder-%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88/</url>
    <content><![CDATA[<h1 id="Binder起源"><a href="#Binder起源" class="headerlink" title="Binder起源"></a>Binder起源</h1><p>Android系统中使用的 <strong>Binder</strong> 机制，实际上是起源于一个叫 <strong>BeOS 操作系统</strong> 中的一个功能，后来 <strong>BeOS</strong> 被<strong>Palm</strong>收购了。这个<strong>Palm</strong> 就是鼎鼎大名的 <strong>Andy Rubin</strong> 创建的。后来 <strong>Palm</strong> 又被其他公司收购了，之后 <strong>Andy Rubin</strong> 就去创建了 <strong>Android</strong>。同时他还带走了原本在 Palm 公司的一些人，其中就有这个Binder框架的开发者 <strong>Dainne Hackborn</strong>。</p>
<h2 id="内核扩展"><a href="#内核扩展" class="headerlink" title="内核扩展"></a>内核扩展</h2><p>AOSP（Android Open Source Project，和我们常说的 Android 是一个意思）所使用的操作系统内核就是 Linux。</p>
<p><strong>AOSP 通用内核</strong>（也称为 Android 通用内核或ACK ）是kernel.org内核的下游。</p>
<p>但 AOSP 使用的 Linux 内核是在原生 Linux 内核上加上了一些自己的东西。所以严格地说 Android 的内核和 Linux 还不是一回事，本文中我们叫它 AOSP 内核 以示区别，而 Linux 则称之为 Linux 内核。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Diffusion-如何写好一份提示词</title>
    <url>/2023/07/28/Diffusion-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E4%BB%BD%E6%8F%90%E7%A4%BA%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>要写好一份提示词，遵循原则为尽可能详细并且具体，从不同角度进行详细描述。下面从9个角度来介绍输入关键词。常用的关键词类别包括如下：<br>(1) 主体subject<br>(2) 媒介 medium<br>(3) 风格 style<br>(4) 画家 artist<br>(5) website<br>(6) 分辨率 resolution<br>(7) 额外细节 additional details<br>(8) 色调 color<br>(9) 光影 lighting  </p>
]]></content>
  </entry>
  <entry>
    <title>Java-泛型</title>
    <url>/2023/04/09/Java-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>On-Java-8 : 你可以了解 Java 泛型的局限是什么，以及为什么会有这些局限。最终的目标是明确 Java 泛型的边界，让你成为一个程序高手。</p>
</blockquote>
<blockquote>
<p>只有知道了某个技术不能做什么，你才能更好地做到所能做的（部分原因是，不必浪费时间在死胡同里）。</p>
</blockquote>
<h1 id="java泛型设计背景"><a href="#java泛型设计背景" class="headerlink" title="java泛型设计背景"></a>java泛型设计背景</h1><p>在早期的Java版本中，集合类（如ArrayList、LinkedList等）中的元素类型是Object类型，这意味着集合类可以容纳任何类型的对象，但是在使用集合类时需要进行频繁的类型转换，这可能导致程序在运行时出现类型转换错误。同时，由于编译器无法检查程序员的类型安全性错误，这些错误可能会在程序运行时才被发现。</p>
<p>为了解决这些问题，Java SE 5引入了泛型。Java泛型通过在定义集合类时使用类型参数来指定集合中元素的类型，从而避免了在使用集合类时进行频繁的类型转换。在编译时，编译器会检查集合中添加或获取元素的类型是否与类型参数所指定的类型相同，从而提高了程序的类型安全性。</p>
<p>当使用集合类（如ArrayList、LinkedList等）时，我们可以使用泛型来指定集合中元素的类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;Hello&quot;);</span><br><span class="line">list.add(&quot;World&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用了List<String>来指定集合中元素的类型为String类型。这样，在编译时编译器会检查集合中添加的元素是否为String类型，从而提高程序的类型安全性。同时，我们不需要在使用集合中的元素时进行类型转换，这可以使代码更加简洁易读。</p>
<p>另外一个例子是在使用Map集合时，我们可以使用泛型来指定键值对的类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(&quot;apple&quot;, 1);</span><br><span class="line">map.put(&quot;banana&quot;, 2);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用了Map&lt;String, Integer&gt;来指定键值对的类型为String和Integer类型。这样，在编译时编译器会检查键和值的类型是否正确，从而提高程序的类型安全性。同时，我们在使用Map中的键或值时也不需要进行类型转换，这可以使代码更加简洁易读。</p>
<blockquote>
<p>如果我们错误地将一个非String类型的对象添加到集合中，编译器会在编译时报告错误。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Java泛型的设计背景可以概括为以下几点：</p>
<p>提高程序的类型安全性<br>减少类型转换的次数<br>提高程序的可读性和可维护性<br>允许程序员编写更加通用的代码<br>在集合类等常用API中使用泛型可以提高API的可用性和可靠性.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-碎碎念</title>
    <url>/2023/02/05/Java-%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在枚举出现之前，如果想要表示一组特定的离散值，往往使用一些常量。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Entity &#123;</span><br><span class="line"> </span><br><span class="line">    public static final int VIDEO = 1;//视频</span><br><span class="line">    public static final int AUDIO = 2;//音频</span><br><span class="line">    public static final int TEXT = 3;//文字</span><br><span class="line">    public static final int IMAGE = 4;//图片</span><br><span class="line"> </span><br><span class="line">    private int id;</span><br><span class="line">    private int type;</span><br><span class="line"> </span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setType(int type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「爱学习的小肥猪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/heima201907/article/details/105651722</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样做的缺点有：<br>（1）代码可读性差、易用性低。由于setType()方法的参数是int型的，在阅读代码的时候往往会让读者感到一头雾水，根本不明白这个2到底是什么意思，代表的是什么类型。当然，要保证可读性，还有这样一个办法：<br>e.setType(Entity.AUDIO);<br>而这样的话，问题又来了。这样做，客户端必须对这些常量去建立理解，才能了解如何去使用这个东西。说白了，在调用的时候，如果用户不到Entity类中去看看，还真不知道这个参数应该怎么传、怎么调。像是setType(2)这种用法也是在所难免，因为它完全合法，不是每个人都能够建立起用常量名代替数值，从而增加程序可读性、降低耦合性的意识。<br>（2）类型不安全。在用户去调用的时候，必须保证类型完全一致，同时取值范围也要正确。像是setType(-1)这样的调用是合法的，但它并不合理，今后会为程序带来种种问题。也许你会说，加一个有效性验证嘛，但是，这样做的话，又会引出下面的第(3)个问题。<br>（3）耦合性高，扩展性差。假如，因为某些原因，需要修改Entity类中常量的值，那么，所有用到这些常量的代码也就都需要修改——当然，要仔细地修改，万一漏了一个，那可不是开玩笑的。同时，这样做也不利于扩展。例如，假如针对类别做了一个有效性验证，如果类别增加了或者有所变动，则有效性验证也需要做对应的修改，不利于后期维护。<br>————————————————<br>版权声明：本文为CSDN博主「爱学习的小肥猪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/heima201907/article/details/105651722">https://blog.csdn.net/heima201907/article/details/105651722</a>  </p>
</blockquote>
<p>枚举设计的目的是为了解决以上的问题。  </p>
<p>基本总结一下，大概有2个特性</p>
<ul>
<li>枚举的两个特性：</li>
</ul>
<ul>
<li>可被列举的集合（不能是无穷尽的）</li>
<li>不可变性（一天24H我有生之年应该不会变了）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-plan</title>
    <url>/2023/01/14/2023-plan/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    GNU/gcc、</span><br><span class="line">    通用汇编、</span><br><span class="line">    CPU Architecture、</span><br><span class="line">    ARM/X86 汇编、</span><br><span class="line">    C/C++、</span><br><span class="line">    OS、</span><br><span class="line">    Linux、</span><br><span class="line">    图形学原理、</span><br><span class="line">    JVM、</span><br><span class="line">    多线程、</span><br><span class="line">    Android OS</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>在正式启动之前，一定要想清楚为什么做和怎么做的问题，且这些问题的答案一定要结合自身的实际情况获得，而不是模仿他人。</p>
]]></content>
      <tags>
        <tag>个人成长</tag>
      </tags>
  </entry>
  <entry>
    <title>Game.1</title>
    <url>/2022/12/08/Game-1/</url>
    <content><![CDATA[<blockquote>
<p>一切商业化价值最大化其实都是人性在推动!</p>
</blockquote>
<h1 id="游戏优化结点"><a href="#游戏优化结点" class="headerlink" title="游戏优化结点"></a>游戏优化结点</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">游戏内可以优化的地方:</span><br><span class="line">1.转生 </span><br><span class="line">2.寻宝 </span><br><span class="line">3.邮件 领取状态 邮件内容 </span><br><span class="line">4.红包 如果按照红包流量词去划分 那么大部分的玩家将涌向冠名区服</span><br><span class="line">5.大米 </span><br><span class="line">6.交易 交易物品，玩家信息</span><br><span class="line">7.聊天 </span><br><span class="line">8.玩家流失结点 </span><br><span class="line">    8.1 活动</span><br><span class="line">    8.2 Npc</span><br><span class="line">    8.3 玩家登记结点  角色，信息，区服。</span><br><span class="line">    8.4 退出时间</span><br><span class="line">9.拍卖行  </span><br></pre></td></tr></table></figure>
<h1 id="商业流程"><a href="#商业流程" class="headerlink" title="商业流程"></a>商业流程</h1><p>从Cp角度出发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">源码 Cocos </span><br><span class="line">Gm后台</span><br><span class="line">前端 : </span><br><span class="line">后端 : </span><br><span class="line">sdk : Android,Ios.H5</span><br><span class="line">后台 : 玩家信息，聊天监控.</span><br><span class="line">美术 : 场景，原画，动作</span><br><span class="line">策划 : 执行策划,数值策划,系统策划 </span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>编程指南</title>
    <url>/2022/11/19/%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机-固态硬盘</title>
    <url>/2022/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任何技术都绝非凭空存在，一项技术的存在，必有其存在缘由 —— 为了在特定场景下 解决某个或某些问题。</span><br><span class="line"></span><br><span class="line">换言之，认识技术，必从认识背景做起 —— 当我们确知了某项技术在特定场景下的不可替代，便是抓住了该技术的本质</span><br></pre></td></tr></table></figure>

<iframe src="//player.bilibili.com/player.html?aid=262805896&bvid=BV1qY411o732&cid=895389434&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width:100%; align:center; padding:20px 0;"> </iframe>

<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><hr>
<p>固态硬盘中使用是NAND Flash存储颗粒，其需要搭载主控，缓存和存储颗粒，通过预先写入的固件来工作。<br>现在手机里用的emcp和UFS是基于NAND Flash深度开发而来的，其内部嵌入了主控和MDDR组件，是一种自我管理型的存储芯片。<br>这样手机厂商就不需要去管不同存储颗粒的厂商的技术差异。<br>这是手机硬盘和固态硬盘的区别。</p>
<p>NAND Flash的发明，我想更应该介绍一位华裔科学家，施敏<br>时间刻度表 </p>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><iframe src="//player.bilibili.com/player.html?aid=298568120&bvid=BV1aF411u7Ct&cid=717122780&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机-芯片</title>
    <url>/2022/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E8%8A%AF%E7%89%87/</url>
    <content><![CDATA[<h1 id="芯片的由来"><a href="#芯片的由来" class="headerlink" title="芯片的由来"></a>芯片的由来</h1>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>理财</title>
    <url>/2022/09/14/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/</url>
    <content><![CDATA[<h1 id="基本准则"><a href="#基本准则" class="headerlink" title="基本准则"></a>基本准则</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在自己身上下功夫  </span><br><span class="line">2.學會謙虛  </span><br><span class="line">3.了解擬將擁有的影響力  </span><br><span class="line">4.學習投資  </span><br><span class="line">5.了解興趣真正的所在  </span><br><span class="line">6.和志同道合的人做朋友  </span><br><span class="line">7.避免自滿  </span><br><span class="line">8.經歷勝過物品  </span><br><span class="line">9.節儉的生活  </span><br><span class="line">10.控制好你的自我  </span><br><span class="line">11.讓自己的錢生錢  </span><br><span class="line">12.控制自己的慾望  </span><br><span class="line">13.明白真正的所求  </span><br><span class="line">14.關注你的儲蓄金  </span><br><span class="line">15.設立清晰的目標  </span><br><span class="line">16.制定長期財務計畫  </span><br><span class="line">總結是能控制自己才是最大的本事  </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>个人成长</tag>
        <tag>Game-Develop</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏商务-启蒙</title>
    <url>/2022/09/14/%E6%B8%B8%E6%88%8F%E5%95%86%E5%8A%A1-%E5%90%AF%E8%92%99/</url>
    <content><![CDATA[<h1 id="对接流程"><a href="#对接流程" class="headerlink" title="对接流程"></a>对接流程</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">盛大 10个点 版本是以什么方式获取，授权</span><br><span class="line">娱美德 6个点</span><br></pre></td></tr></table></figure>

<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>游戏陀螺，游戏葡萄资讯网</p>
<h2 id="白包"><a href="#白包" class="headerlink" title="白包"></a>白包</h2><p>测试账号，扶持  </p>
<h2 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h2><p>渠道:Bt渠道(10)，硬核5+7()，长尾，公会(绿色公会)，主播,私服(私域流量)<br>评测周期 :<br>评测报告 :  </p>
<p>初次会面 : 商务</p>
<p>2次会面:</p>
<p>测试周期-上线数据测试</p>
<h1 id="话术"><a href="#话术" class="headerlink" title="话术"></a>话术</h1><h1 id="游戏评测关键点"><a href="#游戏评测关键点" class="headerlink" title="游戏评测关键点"></a>游戏评测关键点</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">节点</span><br><span class="line">1.客户端大小</span><br><span class="line">2.题材受众</span><br><span class="line">3.类型受众</span><br><span class="line">4.游戏界面/UI</span><br><span class="line">5.角色设计</span><br><span class="line">6.装备设计</span><br><span class="line">7.游戏装备设计:美观程度，和市面其他传奇对比，特殊装备阶级UI分层明显，有特殊视觉效果处理</span><br><span class="line">8.场景地图设计:完善</span><br><span class="line">9.技能特效表现力 ：装备及时回收</span><br><span class="line">10.画面融合度 : </span><br><span class="line">11.新手引导</span><br><span class="line">12.音乐及音效</span><br><span class="line">13.操作方式/手感</span><br><span class="line">14.上手难度:完整的新手引导</span><br><span class="line">15.游戏节奏：适中</span><br><span class="line">16.战斗系统</span><br><span class="line">17.副本/关卡系统</span><br><span class="line">18.升级系统</span><br><span class="line">19.PVP系统</span><br><span class="line">20.道具系统</span><br><span class="line">21.交流机制</span><br><span class="line">22.帮助系统 ：游戏的攻略</span><br><span class="line">23.创新点:战宠 </span><br><span class="line">24.用户激励:</span><br><span class="line">25.游戏目标/追求</span><br><span class="line">26.社交关系</span><br><span class="line">27.次日留存</span><br><span class="line">28.首充奖励</span><br><span class="line">29.运营活动</span><br><span class="line">30.日常活动</span><br><span class="line">31.消费体验:消费深度足够</span><br><span class="line">32.客户端兼容性:Android,IOS</span><br><span class="line">33.加载:加载很流畅，游戏内各个功能切换、关卡加载读取流畅</span><br><span class="line">34.产品完成度</span><br><span class="line">35.游戏稳定性</span><br><span class="line">36.数值</span><br><span class="line">37:对标竞品</span><br><span class="line">38:版本计划 硬核,买量,BT，长尾，信息流</span><br><span class="line">39:跨服 3个服 1500的量</span><br><span class="line">40:底层由来</span><br><span class="line">端游-2018-手游-2020-引擎</span><br></pre></td></tr></table></figure>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.后台 </span><br><span class="line">技术结点</span><br><span class="line">需要统计出玩家流失结点，分析数据.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自己发的话，研发：渠道=5：5，</span><br><span class="line">找发行去发，研发：发行：渠道=2：3：5</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>个人成长</tag>
        <tag>Game-Develop</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏篇章-AAB实践说明</title>
    <url>/2022/05/30/%E6%B8%B8%E6%88%8F%E7%AF%87%E7%AB%A0-AAB%E5%AE%9E%E8%B7%B5%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="Google-Android-App-Bundles"><a href="#Google-Android-App-Bundles" class="headerlink" title="Google - Android App Bundles"></a>Google - Android App Bundles</h1><p>2018 年的 Google I/O ，Google 向 Android 引入了新 App 动态化框架（即 Android App Bundle，缩写为<strong>AAB</strong>)</p>
<blockquote>
<p>App 动态化框架，动态化概念指的是 Play Dynamic Delivery </p>
<blockquote>
<p><strong>上线要求</strong>:从 2021 年 8 月起，新应用需要使用 Android App Bundle 才能在 Google Play 中发布。  </p>
</blockquote>
</blockquote>
<h2 id="About-Android-App-Bundles"><a href="#About-Android-App-Bundles" class="headerlink" title="About Android App Bundles"></a>About Android App Bundles</h2><blockquote>
<p>Android App Bundle 是一种包含编译后代码和资源文件的新的上传格式（.aab） </p>
</blockquote>
<p>补充:<strong>Android Application Bundle</strong> != <strong>Apk</strong><br>App Bundle 纯粹是为了上传设计的文件，用户无法直接安装和使用它。<br>虽然AAB和Apk本质上都是压缩包,但是内部的目录结构完全不同，以下是一个Abb正常的aab文件结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–BundleConfig.pb ： 打包bundle的时候，自动生成</span><br><span class="line">–base : base目录</span><br><span class="line">——assets: 对应apk的assets目录</span><br><span class="line">——dex: 原apk中classes.dex,classes2.dex…都放这里</span><br><span class="line">——lib: 原apk中lib目录都放这里</span><br><span class="line">——manifest: 原apk的AndroidManifest.xml放这里，需要是编译后的AndroidManifest.xml</span><br><span class="line">——res：apk中的资源放这里，需要是编译后的资源</span><br><span class="line">——root: apk中相对于根目录的其他资源文件</span><br><span class="line">——resources.pb：编译资源的时候会生成的</span><br><span class="line">——assets.pb:编译bundle的时候会生成的</span><br><span class="line">——native.pb: 编译bundle的时候会生成的</span><br></pre></td></tr></table></figure>

<h2 id="Google-Play-Dynamic-Delivery"><a href="#Google-Play-Dynamic-Delivery" class="headerlink" title="Google Play Dynamic Delivery"></a>Google Play Dynamic Delivery</h2><blockquote>
<p>简介:Google Play 推出新 app 交付模式，叫做动态交付 (Dynamic Delivery)，它根据每个用户的设备信息，使用开发者上传的 app bundle 来生成对应的 apk 文件。</p>
<blockquote>
<p><img src="https://conorlee.top/images/blogimages/2019/640.gif" alt="AAB">  </p>
</blockquote>
</blockquote>
<h2 id="Play-Asset-Delivery"><a href="#Play-Asset-Delivery" class="headerlink" title="Play Asset Delivery"></a>Play Asset Delivery</h2><blockquote>
<p>Play Asset Delivery (PAD)可以让依靠 Google Play 来托管和提供你的资产包，PAD提供灵活的分发模式，本质上减少包的体积，让用户更佳的体验,目前分发模式有3种，分别为<br><strong>1.install-time 2.fast-follow 3.on-demand</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分发模式</th>
<th align="center">大小限制</th>
<th align="left">简介</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">install-time  =&gt; 安装时分发</td>
<td align="center">总下载大小上限为1GB</td>
<td align="left">资源包在用户安装应用时进行分发，”预先”资源包</td>
<td align="left">在应用启动是使用，用户无法修改或删除这些资源包</td>
</tr>
<tr>
<td align="left">fast-follow =&gt; 快速跟进式分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包在用户安装应用后立即自动下载</td>
<td align="left">用户无需打开应用即可开始 fast-follow 下载。此类下载不会阻止用户访问应用。</td>
</tr>
<tr>
<td align="left">on-demand =&gt; 按需分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包会在应用运行时进行下载</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意 ！！！</strong>：如果为资源包选择 <strong>install-time 分发类型</strong>，就无需在游戏中使用 <strong>Play Asset Delivery API</strong>。这些资源包与主应用 APK同时安装。<br>目前公司项目使用就是分发模式就是 <strong>install-time</strong></p>
<p>由于google规定需要apk&lt;150m，等于aab中的base目录&lt;150m，如果超出限制，需要把多出的资源迁移到install-time，让google去动态下发资源</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>由<strong>S1-EN</strong>项目举例，该项目使用模块化，该项目包含以下的模块</p>
<h2 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h2><table>
<thead>
<tr>
<th align="left">模块</th>
<th align="center">类型</th>
<th align="left">简介</th>
<th align="left">包含依赖</th>
</tr>
</thead>
<tbody><tr>
<td align="left">EN</td>
<td align="center">APP</td>
<td align="left">完整项目</td>
<td align="left">ENGameResource</td>
</tr>
<tr>
<td align="left">EN_HW</td>
<td align="center">AAB</td>
<td align="left"></td>
<td align="left">ENGameResource,install_time</td>
</tr>
<tr>
<td align="left">ENGameResource</td>
<td align="center">游戏资源</td>
<td align="left">对应替换游戏资源</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">ENAPPLib</td>
<td align="center">LIB</td>
<td align="left"></td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">install_time</td>
<td align="center">AAB-分发模式</td>
<td align="left">安装时分发</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">on_demand</td>
<td align="center">AAB-分发模式</td>
<td align="left">按需分发</td>
<td align="left">无</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABB = ENGameResource + EN_HW + install_time</span><br></pre></td></tr></table></figure>

<h2 id="出包需求"><a href="#出包需求" class="headerlink" title="出包需求"></a>出包需求</h2><p>我们以S1-EN 欧美出包来举例，一般需要出2个类型的包，一直为正常的APK，给运营测试，另外一种为AAB给发行上架应用。</p>
<p>对应出包格式和命名可以查看此目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\192.168.1.181\apk\欧美\</span><br></pre></td></tr></table></figure>

<h2 id="出包需求-1"><a href="#出包需求-1" class="headerlink" title="出包需求"></a>出包需求</h2><p>我们以S1-EN 欧美出包来举例，一般需要出2个类型的包，一直为正常的APK，给运营测试，另外一种为AAB给发行上架应用。</p>
<p>对应出包格式和命名可以查看此目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\192.168.1.181\apk\欧美\</span><br></pre></td></tr></table></figure>
<p>一般我们是先出APK,后出AAB。</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>我们是先从145打包机上，打包一个完整的APK，复制到本地进行解压出对应的游戏资源。<br>解压的过程可以自由发挥，在我的电脑我是内置了解压的Apk的程序。<br>使用APKDB编辑,会出现以下页面，回车即可</p>
<p><img src="APKDB.png" alt="Android-AAB"></p>
<p>右键Apk-&gt;使用APKDB编辑-&gt;按下回车</p>
<p><img src="%E8%A7%A3%E5%8E%8B%E5%90%8E.png" alt="Android-AAB"></p>
<p>实际上我们只需要用到截图中的几个目录</p>
<p><strong>ABB = ENGameResource + EN_HW + install_time</strong></p>
<p>所以对应项目替换的路径，看下图</p>
<p><img src="ABB%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5.png" alt="Android-AAB"></p>
<h1 id="install-time"><a href="#install-time" class="headerlink" title="install-time"></a>install-time</h1><blockquote>
<p>由于google规定需要apk&lt;150m，等于aab中的base目录&lt;150m，如果超出限制，需要把多出的资源迁移到install-time，让google去动态下发资源</p>
</blockquote>
<p>我们S1-EN欧美打包的AAB主要是使用了install_time分发模式，我们把原本asset资源下的部分游戏资源迁移到 install-time模块下，</p>
<!-- # 项目 -->

<!-- # 软件使用说明
### 需要提前安装的环境   
* 需要自己额外再安装的路径  
    1. python3
    2. aapt  
    3. gradle 
    4. as-pro  ==> 模板工程 
* 该工具内置了反编译的环境 请勿随意修改路径  
    1. apktool  
    2. dex2jar  
    3. smali  

2 需要在该工具路径下/tool/apktool/signature/config/apk.ini文件配置以下路径

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置项 后续看项目的需求支持可增加参数</span><br><span class="line">[config]</span><br><span class="line"># 注意所有配置项需要顶行写，&quot;=&quot; 号两边和行首尾不能有空格</span><br><span class="line"># AS 路径 </span><br><span class="line">as_path=/Users/zhupengbo/Desktop/S3/S3_Hw</span><br><span class="line"># AAB 生成的路径 必填</span><br><span class="line">abb_path=/Users/zhupengbo/tool/apktool/apk/abb</span><br><span class="line"># 版本号和版本名</span><br><span class="line">versionCode=1</span><br><span class="line">versionName=1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.该项目增加了pad配置表<br>3.1 <strong>aab_pad.xls</strong> 配置表路径在 <strong>/apktool/signature/config</strong> 的路径下<br>3.2 配置的方法<br>支持配置<strong>文件路径</strong>和<strong>文件夹</strong><br>S3项目以resource路径下进行配表，该路径包含了游戏内的资源  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置形式为:resource/路径</span><br></pre></td></tr></table></figure>

<p><strong>aab_pad.xls 格式如下-示例</strong></p>
<table>
<thead>
<tr>
<th align="left">Path</th>
</tr>
</thead>
<tbody><tr>
<td align="left">resource/model</td>
</tr>
<tr>
<td align="left">resource/Video</td>
</tr>
<tr>
<td align="left">resource/allRes.json</td>
</tr>
<tr>
<td align="left">resource/ui</td>
</tr>
</tbody></table>
<p>4 该工具支持下终端下执行，调用示例</p>
<pre><code>/Users/zhupengbo/tool/apktool/android_pack.sh /Users/zhupengbo/tool/apktool/apk/apk/AAA.apk
``` --&gt;




</code></pre>
]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏篇章-Unity与SDK交互</title>
    <url>/2022/03/24/%E6%B8%B8%E6%88%8F%E7%AF%87%E7%AB%A0-Unity%E4%B8%8ESDK%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h1 id="游戏启动篇"><a href="#游戏启动篇" class="headerlink" title="游戏启动篇"></a>游戏启动篇</h1><h2 id="CP视角"><a href="#CP视角" class="headerlink" title="CP视角"></a>CP视角</h2><p>游戏App分为2种类型，分包与整包。<br>游戏模式可以大致分成2类，测试模式(内网)与线上模式(外网)。</p>
<ul>
<li>游戏的初始化</li>
</ul>
<ol>
<li>检查游戏版本更新  </li>
<li>1 一般是通过利用<strong>SVN</strong>主分支的版本号，进行线上环境游戏资源的更新。  </li>
<li>2 获取有序更新URL  </li>
</ol>
<p>2.加载本地资源  </p>
<hr>
<p>SDK视角</p>
]]></content>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/23/Activity%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%203%20%E4%B8%AA%E8%BE%9F%E8%B0%A3/</url>
    <content><![CDATA[<h1 id="技术文章参考"><a href="#技术文章参考" class="headerlink" title="技术文章参考"></a>技术文章参考</h1><p><a href="%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93">https://xiaozhuanlan.com/topic/0213584967</a></p>
<h1 id="进程模式"><a href="#进程模式" class="headerlink" title="进程模式"></a>进程模式</h1><p>Android 平台的 App，通常情况下都是单进程。</p>
<p>由于 Android 平台资源有限，需要为不同进程设置优先级，以便在系统资源紧张的情况下，将优先级较低的进程杀死，以释放资源。</p>
<p>因而，进程模式的存在就是为了标记和区分进程的优先级。</p>
<h1 id="存在哪几种进程模式？"><a href="#存在哪几种进程模式？" class="headerlink" title="存在哪几种进程模式？"></a>存在哪几种进程模式？</h1><p>按优先级从高到低，进程模式主要包含：</p>
<p>前景进程、可见进程、服务进程、背景进程、空白进程 这 5 大类别 </p>
<p><img src="%E9%87%8D%E5%AD%A6%E5%AE%89%E5%8D%93" alt="https://images.xiaozhuanlan.com/photo/2021/a1e4a82bc9771970300307a37fcd2476.png"></p>
<p>通常，App 进程的级别，由其活跃的或处于栈顶的组件的活动状况（比如所处生命周期）决定。</p>
<p>例如，当一个 App 的 Activity 处于 onResume，那么该 Activity 所在的整个进程都会成为前景进程。</p>
<blockquote>
<p>划重点 👆 👆 👆</p>
</blockquote>
<p>于此同时，需要再次强调的是，当系统回收资源时，针对的是 App 的进程，而不是针对 App 进程中的某个组件。（此处对应文末的 “辟谣 2”）</p>
<blockquote>
<p>划重点 👆 👆 👆 </p>
</blockquote>
<h1 id="前景模式、可见模式，二者的区别？"><a href="#前景模式、可见模式，二者的区别？" class="headerlink" title="前景模式、可见模式，二者的区别？"></a>前景模式、可见模式，二者的区别？</h1><p>由于手机屏幕空间有限，一次只能展示一个窗口，但如果你拿 PC 来考虑，就不难理解为何要同时存在 “前景” 和 “可见” 这两种概念。</p>
<p>前景模式就相当于 PC 中 “获得焦点” 的窗口。</p>
<p>可见模式即是那些你可以看见，但 “失去焦点” 的窗口</p>
<h1 id="官方的可见模式的含义"><a href="#官方的可见模式的含义" class="headerlink" title="官方的可见模式的含义"></a>官方的可见模式的含义</h1><p>可见模式，不如我们称其为 “失焦模式”<br>为保持称谓的一致，本文在正文中沿用了 “官方文档” 对其所定义的各进程模式的称谓，同时本文也另辟蹊径地通过 “类比” 的方式来分析 “前景”、“可见” 等模式的本质和设计依据。</p>
<p>为此有小伙伴在理解了本文思路后，因官方 “可见模式” 这个概念的语义而产生困扰，毕竟确实如其所说，从字面上看，“可见” 即包含了 “前景可见” 和 “被部分遮挡但可见” 这两种情况，</p>
<p>其实我个人猜测，所谓 “前景模式” 和 “可见模式” 的概念，大概率是继承于 PC 操作系统中窗体的相关概念，然而 Android 又不想和它重名，就像鸿蒙手机系统的 Framework “换汤不换药” 地将 Activity 等组件改名为 Ability 一样，</p>
<p>因而综上，我们不妨结合本文的思路，来给 “可见模式” 取个更为恰当的名称 —— “失焦模式” —— 失去焦点的模式，与之相对的就是 “获焦模式”，这样无论从哪个角度来看，都是恰当的，毕竟 获焦或失焦隐含的潜台词就是 “页面已经可见了”。</p>
<h1 id="Activity-被系统回收"><a href="#Activity-被系统回收" class="headerlink" title="Activity 被系统回收"></a>Activity 被系统回收</h1><p>系统回收的是进程，系统回收的是进程，系统回收的是进程！<br>重要的事情要讲三遍 👆👆👆</p>
<p>请不要再使用 “Activity 被系统回收” 等与客观实际有一定出入的描述（尤其在面试时，因为此处无意间流露了对 “计算机操作系统” 等基础知识的掌握程度，容易给人留下专业基础不扎实的印象。当然如果你是有意借此试探面试官的反应，看他到底 “行不行”，那就当我没说）</p>
<p>具体而言，如果 Activity A 和 B 分属于同一个 App 的两个进程，且 A 在后台进程，那么内存不足时 A 可能因为进程被回收而 受牵连；而如果 A 和 B 在同一个进程内，且 B 乃至 B 所处的进程处于前景或可见，那 A 则不会 受牵连。</p>
<p>简言之，这类事情的本质是 “进程被系统回收”。也即，只要 Activity 是保持在 Stop 而未步入 Destroy（例如处于非栈顶的位置），那么该 Activity 此时 “被回收” 只可能是因为所在进程被系统回收。</p>
<p>划重点 👆👆👆</p>
<h1 id="如何理解Android手机内存"><a href="#如何理解Android手机内存" class="headerlink" title="如何理解Android手机内存"></a>如何理解Android手机内存</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/23/%E7%AE%A1%E7%A8%8B%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%87%E8%83%BD%E9%92%A5%E5%8C%99/</url>
    <content><![CDATA[<h1 id="技术文章参考"><a href="#技术文章参考" class="headerlink" title="技术文章参考"></a>技术文章参考</h1><p><a href="%E6%9E%81%E5%AE%A2%E4%B9%8B%E5%AE%B6">https://time.geekbang.org/column/article/86089</a></p>
<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>1.管程是一种概念，任何语言都可以通用。</p>
<p>java采用的是管程技术，synchronized 关键字及 wait notify notifyAll 三个方法都是管程的组成部分。</p>
<p>而管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。</p>
<p>管程，对应的英文是 Monitor，很多 Java 领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这个是意译，而我自己也更倾向于使用“管程”。</p>
<h1 id="MESA模型"><a href="#MESA模型" class="headerlink" title="MESA模型"></a>MESA模型</h1><p>java管程实现参考的是MESA模型。</p>
<p>有两大核心问题：<br>一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。 </p>
<h1 id="管程解决“互斥”问题的解决方案"><a href="#管程解决“互斥”问题的解决方案" class="headerlink" title="管程解决“互斥”问题的解决方案"></a>管程解决“互斥”问题的解决方案</h1><p>管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。</p>
<p>假如我们要实现一个线程安全的阻塞队列，一个最直观的想法就是：将线程不安全的队列封装起来，对外提供线程安全的操作方法，例如入队操作和出队操作。</p>
]]></content>
  </entry>
  <entry>
    <title>Android-内存管理机制-2</title>
    <url>/2022/02/18/Android-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-2/</url>
    <content><![CDATA[<h1 id="内存指标概念"><a href="#内存指标概念" class="headerlink" title="内存指标概念"></a>内存指标概念</h1><p>USS(Unique Set Size): 物理内存，进程独占的内存<br>PSS(Proportional Set Size): 物理内存，PSS = USS + 按比例包含共享库<br>RSS(Resident Set Size): 物理内存，RSS = USS + 包含共享库<br>VSS(Virtual Set Size): 虚拟内存，VSS = RSS + 未分配实际物理内存  </p>
<h1 id="设备物理内存"><a href="#设备物理内存" class="headerlink" title="设备物理内存"></a>设备物理内存</h1><p>设备的物理内存被分为很多页（Page），每页 4KB。不同的页用来做不同的事情。</p>
<p><img src="physical-type.png" alt="物理内存"> </p>
<p>橘色的是已使用页，黄色的是缓存页（数据在磁盘上有备份，所以 Cache Pages 是可以被回收的），绿色的是空闲页。 </p>
<hr>
<p>对于虚拟内存来说，页面共有以下几个状态：<br>Not Present：页面分配后未映射到物理内存；又或是作为干净页即将被内核清除。</p>
<p>Resident：当页面映射到物理内存后，需常驻于内存中，根据其内容是否存在文件备份，可划分为两种类型：<br>    Clean（干净页）：仅适用于文件映射，加载到内存后不曾被更改，当内存不足时可由内核进行清除<br>    Dirty（脏页）：匿名映射（不存在文件备份）或页面内容与磁盘不同。这种情况下无法由内核进行清除，因为会导致数据丢失，但可由Swapped机制进行交换处理</p>
<p>Swapped：脏页可被交换到磁盘上，当再次发生缺页中断时才被重新加载到内存；在Android中表示通过ZRAM进行了压缩，但仍会占用部分内存</p>
<p>RAM 分为多个“页面”。通常，每个页面为 4KB 的内存。<br>系统会将页面视为“可用”或“已使用”。可用页面是未使用的 RAM。已使用的页面是系统目前正在使用的 RAM，并分为以下类别：</p>
<p>缓存页：有存储器中的文件（例如代码或内存映射文件）支持的内存。缓存内存有两种类型：</p>
<ul>
<li>私有页：由一个进程拥有且未共享<ul>
<li>干净页：存储器中未经修改的文件副本，可由 kswapd 删除以增加可用内存</li>
<li>脏页：存储器中经过修改的文件副本；可由 kswapd 移动到 zRAM 或在 zRAM 中进行压缩以增加可用内存</li>
</ul>
</li>
<li>共享页：由多个进程使用<ul>
<li>干净页：存储器中未经修改的文件副本，可由 kswapd 删除以增加可用内存</li>
<li>脏页：存储器中经过修改的文件副本；允许通过 kswapd 或者通过明确使用 msync() 或 munmap() 将更改写回存储器中的文件，以增加可用空间</li>
</ul>
</li>
<li>匿名页：没有存储器中的文件支持的内存（例如，由设置了 MAP_ANONYMOUS 标记的 mmap() 进行分配）<ul>
<li>脏页：可由 kswapd 移动到 zRAM/在 zRAM 中进行压缩以增加可用内存</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：干净页包含存在于存储器中的文件（或文件一部分）的精确副本。如果干净页不再包含文件的精确副本（例如，因应用操作所致），则会变成脏页。干净页可以删除，因为始终可以使用存储器中的数据重新生成它们；脏页则不能删除，否则数据将会丢失。</p>
</blockquote>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><img src="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="物理内存"> </p>
<p>1）这是一个 2G 内存的手机，X 轴表示使用时间，Y 轴表示内存使用情况。 </p>
<p>2）随着打开的应用越来越多，Used Pages 也越来越多，而 Cached Pages 和 Free Pages 则越来越少。 </p>
<p>3）当 Free Pages 低于 kswapd 的阈值时，Linux 内核就会通过 kswapd 进程对 Cached Pages 进行回收。 </p>
<p>4）当应用再次访问 Cached Pages 上的内容时，就需要从磁盘上重新加载。如果 Cached Pages 太少的话，设备就可能死机。</p>
<h2 id="Low-Memory-Killer"><a href="#Low-Memory-Killer" class="headerlink" title="Low Memory Killer"></a>Low Memory Killer</h2><p>1）在 Android 上我们有个机制叫 Low Memory Killer，当 Cached Pages 太少时，就会被触发。它的工作方式是挑一个进程杀掉，然后该进程占用的所有内存都会被回收。 </p>
<p>2）如果 LMK 杀掉的是用户关心的进程，那体验就非常不好，所以我们搞了一个表（由 SystemServer 进程维护），根据这张表来决定谁先被杀掉。</p>
<p><img src="android%E5%88%86%E7%BA%A7%E8%A1%A8.png" alt="Low Memory Killer 阎王爷账本"></p>
<p>1）当已用内存超过 LMK 阈值时，LMK 将从 Cached 列表底部开始杀进程。如果可用内存还是不足，那么就按照上表一种向上杀，直到 SystemServer，此时手机会直接重启。 </p>
<ul>
<li>分类： </li>
</ul>
<ul>
<li><p>Perceptible 指的是非直接交互的进程，比如后台放歌的播放器进程。 </p>
</li>
<li><p>Previous 指的是切换到当前与用户交互的上一个应用进程。 </p>
</li>
<li><p>Cached 指缓存的进程，可能是退至后台的应用，也可能是已经退出的应用，主要是为了实现应用间的快速切换。 </p>
</li>
</ul>
<p>3）如果低内存时，LMK 将一直处于活跃状态，具体表现就是黑屏、桌面重启，应用打不开等等</p>
<h2 id="评估-App-的内存占用"><a href="#评估-App-的内存占用" class="headerlink" title="评估 App 的内存占用"></a>评估 App 的内存占用</h2><p>物理内存追踪：Linux Kernel 将会持续跟踪每个进程使用的 Pages，所以只要对进程使用的 Pages 进行计数即可： </p>
<p><img src="share.png" alt="App memory impact"></p>
<p>但实际情况远比这要复杂的多，因为有些 Pages 是进程间共享的： </p>
<p><img src="app.png" alt="App memory impact with shared papes"></p>
<p>RSS（Resident Set Size）：App 完全负责</p>
<p><img src="rss.png" alt="RSS"></p>
<p>3）USS（Unique Set Size）：App 无责： </p>
<p><img src="uss.png" alt="USS"></p>
<p>但实际上，至少需要系统级别才能知道 RSS 与 USS 的情况。所以通常都是使用 PSS 来计算，这还可以避免多记或者少记 Shared Pages。</p>
<blockquote>
<p>adb shell dumpsys meminfo -s [process]</p>
</blockquote>
<h1 id="内存优化建议"><a href="#内存优化建议" class="headerlink" title="内存优化建议"></a>内存优化建议</h1><h2 id="优化-App-Java-Heap："><a href="#优化-App-Java-Heap：" class="headerlink" title="优化 App Java Heap："></a>优化 App Java Heap：</h2><p>很多内存虽然不在 Java 堆分配，但是其生命周期跟 Java 堆上分配的对象绑在了一起： </p>
<p><img src="%E4%BC%98%E5%8C%96java%E5%A0%86.png" alt="apk占据内存"></p>
<h2 id="减小-apk-体积：因为很多在-apk-中占据磁盘空间的文件，在运行期也会占据内存空间："><a href="#减小-apk-体积：因为很多在-apk-中占据磁盘空间的文件，在运行期也会占据内存空间：" class="headerlink" title="减小 apk 体积：因为很多在 apk 中占据磁盘空间的文件，在运行期也会占据内存空间："></a>减小 apk 体积：因为很多在 apk 中占据磁盘空间的文件，在运行期也会占据内存空间：</h2><p><img src="%E5%87%8F%E5%B0%91apk%E4%BD%93%E7%A7%AF.png" alt="apk占据内存"></p>
<h2 id="具体："><a href="#具体：" class="headerlink" title="具体："></a>具体：</h2><p>Vss - 虚拟集大小是进程的总可访问地址空间。它显示有多少虚拟内存与进程相关联。 </p>
<p>Rss - Resident Set Size 是分配给进程的物理页数。进程之间共享的页面被计算多次。 </p>
<p>Pss - Proportional Set Size 采用 Rss 数，但在共享进程之间平均分配共享页面。例如，如果三个进程共享 9MB，则每个进程在 Pss 中获得 3MB。 </p>
<p>Uss - Unique Set Size 也称为 Private Dirty，它基本上是进程内无法分页到磁盘的 RAM 量，因为它没有磁盘上的相同数据支持，并且不与任何其他进程共享</p>
<h1 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h1><p>私有脏内存 == 指的是 App 已用内存，以上物理内存，显示橘色的是已使用页。<br>私有干净内存 == 表明是 App 缓存内存，可以被 kswapd 回收的内存。  </p>
<h1 id="zram"><a href="#zram" class="headerlink" title="zram"></a>zram</h1>]]></content>
      <categories>
        <category>Linux</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于面试的一些思考🤔</title>
    <url>/2022/01/30/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%F0%9F%A4%94/</url>
    <content><![CDATA[<h1 id="记录一些值得思考的问题"><a href="#记录一些值得思考的问题" class="headerlink" title="记录一些值得思考的问题"></a>记录一些值得思考的问题</h1><h2 id="回答的思路"><a href="#回答的思路" class="headerlink" title="回答的思路"></a>回答的思路</h2><p>诞生背景</p>
<p>优势<br>缺点</p>
<p>硬件 (CPU,GPU) + 驱动 + 操作系统(linux,Android) + 操作系统API调用 + 应用层</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>程序： 程序就是一个可执行文件，是存储再硬盘上的一列列指令，就像 win 系统里的 .exe 文件，这是一个可执行的安装文件，解压缩我们可以看到好多好多的代码，只是这些代码现在都是静态的，都还没有运行起来。</p>
<p>进程： 当一个可执行文件(apk)被加载进内存，程序就变成了进程。进程就是已经被加载进内存的一系列相互关联的课执行指令。<br>进程把第一条指令加载进内存，然后按顺序一条条的执行指令。进程本质就是程序计数器+运行时数据程序  </p>
<p>线程： CPU 执行的任务就是一个个线程，线程中有栈帧，栈帧就是一个个将要运行的方法和临时数据</p>
<p>面试时这样回答：进程是操作系统资源分配、保护和调度的基本单位，线程是CPU调度的基本单位</p>
<h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p>编写 =&gt; 编译 =&gt; 可执行文件 =&gt; 加载 =&gt; 回收</p>
<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><ul>
<li>虚拟内存是操作系统内核为了对进程地址空间进行管理（process address space management）而精心设计的一个逻辑意义上的内存空间概念。我们程序中的指针其实都是这个虚拟内存空间中的地址。</li>
<li>物理地址：物理地址就是内存位真实的物理存储位置</li>
</ul>
<ul>
<li>虚拟地址： 这是说内存寻址的</li>
<li>虚拟内存： 这来源于 WIN 系统，说的是用硬盘来扩展内存的大小，把一部分硬盘当内存</li>
</ul>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>每个进程都拥有独立的虚拟地址空间，通过虚拟地址进行内存访问主要具备以下几点优势：</p>
<blockquote>
<p>1.进程可使用连续的地址空间来访问不连续的物理内存，内存管理方面得到了简化。<br> 2.实现进程与物理内存的隔离，对各个进程的内存数据起到了保护的作用。<br>3.程序可使用远大于可用物理内存的地址空间，虚拟地址在读写前不占用实际的物理内存，并为内存与磁盘的交换提供了便利。</p>
</blockquote>
<p>虚拟内存使用：分段、分页 技术进一步优化内存使用，具体由操作系统和CPU硬件中的MMU单元来管理</p>
<blockquote>
<p>在计算机系统中，映射的工作是由硬件和软件共同来完成的。承担这个任务的硬件部分叫做存储管理单元MMU，软件部分就是操作系统的内存管理模块了</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad8f0bc452b43b8a582bba6e5a36847~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="虚拟内存"> </p>
<h1 id="虚拟地址到物理地址的转换"><a href="#虚拟地址到物理地址的转换" class="headerlink" title="虚拟地址到物理地址的转换"></a>虚拟地址到物理地址的转换</h1><p>虚拟存储实现需要依靠硬件的支持<br>MMU (Memory Management unit)的部件进行页映射</p>
<blockquote>
<p>CPU -&gt; Virtual Address -&gt; MMU -&gt; Physical Address -&gt; Physical Memory</p>
</blockquote>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>通过分段技术，实现了进程间内存隔离，进程之间不能访问其他进程的内存了，因为每个进程虚拟地址都是独一份，单独维护的，单独和物理内存映射的，其他进程拿到也没用，没有虚拟内存映射关系你是找不到真实物理地址的</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3531693bda094446a7a9dd989ecf3f79~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="分段"></p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>linux把虚拟内存分为若干个大小相等的存储分区，分区称之为页。</p>
<p>为了换入换出方便，物理内存也是大小分为按块分配，物理内存块是存储虚容页的容器，所以物理容器称之为页框。</p>
<p>页中的页指的是内存管理单元把内存按页这个基本的单位分配，一页是4K大小，虚拟内存中的页叫页，物理内存中的页叫页框，记录页于页框之间映射关系的叫页表</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f4ff9bbe1144e54acf356531baade59~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="分页"></p>
<p>页的分配原则是按需分配，进程A告诉操作系统我需要60M内存，那么操作系统就先给了进程A60M虚拟内存，但是没给物理内存。在进程运行时计算真的需要1M内存，此时才分配1M物理内存给进程A，实现进程A虚拟内存于这1M物理内存的映射，等不够用了再分配物理内存，但是总量不能超过进程A启动时申请的60M虚拟内存这个阀值</p>
<h1 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h1><blockquote>
<p>每个进程都有自己独立的虚拟地址空间，这些地址空间需要通过页表映射到不同的物理地址</p>
</blockquote>
<p>偏移量 - 数据位于该页中的位置，一页是4K的大小，所以这个偏移量就是数据在这个页中内存位置的首地址。</p>
<p>可以理解为前面的是页码，后面偏移量数据代表着页中的行数</p>
<p>页表记录页于页框的映射关系，页和页框地址的偏移量，页表核心的就是记录页码和页框码了，看下图就是这个意思</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb450273073248ed8b405be4a318a5f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="页表"></p>
<h1 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h1><p>大家想想要是能在2个进程中，要是都是指向相同的物理内存上，是不是就能实现跨进程内存共享啦，内存共享是进程间通信的一种方式</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b30c6e3757e045f9943fa65154455dec~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="数据共享"></p>
<h1 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h1><p>Linux 提出 SWAP 的概念，Linux 中可以使用 SWAP 分区，在分配物理内存，但可用内存不足时，将暂时不用的内存数据先放到磁盘上，让有需要的进程先使用，等进程再需要使用这些数据时，再将这些数据加载到内存中，通过这种”交换”技术，Linux 可以让进程使用更多的内存。</p>
<p>物理内存管理要处理的事情就是页面的换出。每个进程都有自己的虚拟地址空间，虚拟地址空间都非常大，而不可能有这么多的物理内存。所以对于一些长时间不使用的页面，将其换出到磁盘，等到要使用的时候，将其换入到内存中，以此提高物理内存的使用率</p>
<h1 id="mmap理解"><a href="#mmap理解" class="headerlink" title="mmap理解"></a>mmap理解</h1><p>mmap 实现的是内核缓冲区与用户进程的地址空间的映射。</p>
<p>也就是说用户进程通过操作自己的<strong>逻辑虚拟地址</strong>就可以实现操作内核空间缓冲区，这样就不用再因为内核空间和用户空间相互隔离而需要将数据在内核缓冲区和用户进程所在内存之间来回拷贝。</p>
<p>mmap是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系；实现这样的映射关系后，进程就可以采用指针的方式读写操作这一块内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必调用read，write等系统调用函数，相反，内核空间堆这段区域的修改也直接反应到用户空间，从而可以实现不同进程间的文件共享。</p>
<p>日志常规方案的缺陷</p>
<p>数据从程序写入到磁盘的过程中，其实牵涉到两次数据拷贝：一次是用户空间内存拷贝到内核空间的缓存，一次是回写时内核空间的缓存到硬盘的拷贝。当发生回写时也涉及到了内核空间和用户空间频繁切换。<br>dirty page 回写的时机对应用层来说又是不可控的，所以性能瓶颈就出现了。</p>
<p>流畅性不仅包括了系统没有卡顿，还要尽量保证没有 CPU 峰值。</p>
<p>进一步思考</p>
<p>因为要写入大量的 IO 导致程序卡顿，那是否可以先把日志缓存到内存中，当到一定大小时再加密写进文件，为了进一步减少需要加密和写入的数据，在加密之前可以先进行压缩。</p>
<blockquote>
<p>方案描述：把日志写入到作为 log 中间 buffer 的内存中，达到一定条件后压缩加密写进文件。</p>
</blockquote>
<p>但这个方案却存在一个致命的问题：丢日志。</p>
<p>mars 的日志模块 xlog 就是在兼顾这四点的前提下做到：高性能高压缩率、不丢失任何一行日志、避免系统卡顿和 CPU 波峰</p>
<p>mmap 的回写时机：</p>
<p>内存不足</p>
<p>进程 crash</p>
<p>调用 msync 或者 munmap</p>
<p>不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</p>
<p>log -&gt; mmap -&gt; 明文 -&gt; 压缩 -&gt; 加密</p>
<p>就是怎么对单行日志进行压缩，也就是其他模块每写一行日志日志模块就必须进行压缩</p>
<p>性能问题：一开始日志的写入就是通过标准I/O直接写文件，当有一条日志要写入的时候，首先，打开文件，然后写入日志，最后关闭文件。但是写文件是 IO 操作，随着日志量的增加，更多的IO操作，一定会造成性能瓶颈。为什么这么说呢？因为数据从程序写入到磁盘的过程中，其实牵涉到两次数据拷贝：一次是用户空间内存拷贝到内核空间的缓存，一次是回写时内核空间的缓存到硬盘的拷贝。当发生回写时也涉及到了内核空间和用户空间频繁切换。<br>丢日志：为了解决性能问题，直接想到就是减少I/O操作，我们可以先把日志缓存到内存中，当达到一定数量或者在合适的时机将内存里的日志写入磁盘中。这样似乎可以减少I/O操作，但是在将内存里的日志写入磁盘的过程中，app被强杀了或者Crash了的话，这样会造成更严重的问题，日志丢失</p>
<p>减少系统调用。我们只需要一次 mmap() 系统调用，后续所有的调用像操作内存一样，而不会出现大量的 read/write 系统调用。</p>
<p>减少数据拷贝。普通的 read() 调用，数据需要经过两次拷贝；而 mmap 只需要从磁盘拷贝一次就可以了，并且由于做过内存映射，也不需要再拷贝回用户空间。</p>
<p>可靠性高。mmap 把数据写入页缓存后，跟缓存 I/O 的延迟写机制一样，可以依靠内核线程定期写回磁盘。</p>
<p>作者：喊我小飞哥<br>链接：<a href="https://juejin.cn/post/6844904118088105991">https://juejin.cn/post/6844904118088105991</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="手写一个单例"><a href="#手写一个单例" class="headerlink" title="手写一个单例"></a>手写一个单例</h2><p>这个基本上大多数公司都会考察的。<br>要写一个 基于懒汉式的 双重检测的单例。</p>
<ul>
<li>单例有三个比较关键的点：</li>
</ul>
<ul>
<li>私有构造方法，避免外部 new 出对象；</li>
<li>保证唯一性；</li>
<li>提供一个全局访问点。</li>
</ul>
<p>另外懒汉式双重检测的实现方式有三点需要注意的地方：</p>
<blockquote>
<p>全局访问点必须是静态的，外界使用可以通过类直接调用；<br>在进入锁之后还需要校验；<br>保存单例例对象的私有变量一定要用 volatile 修饰，这个地方 可以多说一些，<br>比如 volatile 防止指令重排序，保证内存可见性(JVM 层面 和 CPU 层面 可以分别说)。<br>volatile 这个地方能说的东西还是很多的，基本上可以与面试官再聊二十分钟了。</p>
</blockquote>
<p><a href="https://www.cnblogs.com/damonhuang/p/5431866.html">学习的链接</a></p>
<hr>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p>从调度、并发性、拥有的资源和系统开销四个方面回答的。</p>
<h2 id="JVM-四种引用类型"><a href="#JVM-四种引用类型" class="headerlink" title="JVM 四种引用类型"></a>JVM 四种引用类型</h2><p>这个问题比较简单，强引用、弱引用、软引用、虚引用，说一下它们各自的特点和 GC 对<br>它们的不同处理方式，再说一下常见的应用场景 或者 jdk 的实现中对它们的使用，比如<br>ThreadLoca 的静态内部类 ThreadLocalMap，它的 Key 是弱引用的，也可以说一下 在<br>你的理解中为什么它是弱引用的，假如不是会怎么样。</p>
<hr>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>加载、链接、初始化，链接又分为验证准备和解析，每一个阶段是做了什么要说清楚。<br>Object a = new Object()； 这⾏代码做了了哪些事情，需要从类加载开始说起，这个相<br>当于上面问题的延续，所以 一定要清楚 每一个环节 做了哪些事情的，否则这个问题不可<br>能说清楚。说完类加载的过程 再说一下 开辟内存空间、初始化内存空间以及把内存地址<br>赋值给变量 a，接下来可以进一步说一下 JVM 或者 CPU 层面对指令的优化，以及在某些<br>时刻我们需要避免它做这样的优化，比如在单例中我们的实例需要用 volatile 修饰 避免指<br>令重排序(可以说一下 在 new 一个对象的过程中如果指令重排序了会导致什么结果)。</p>
<hr>
<h2 id="多线程：怎么实现线程安全，各个实现方法有什么区别，volatile-关键字的使用，可重入锁的理解，Synchronized-是不是可重入锁"><a href="#多线程：怎么实现线程安全，各个实现方法有什么区别，volatile-关键字的使用，可重入锁的理解，Synchronized-是不是可重入锁" class="headerlink" title="多线程：怎么实现线程安全，各个实现方法有什么区别，volatile 关键字的使用，可重入锁的理解，Synchronized 是不是可重入锁"></a>多线程：怎么实现线程安全，各个实现方法有什么区别，volatile 关键字的使用，可重入锁的理解，Synchronized 是不是可重入锁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里我就主要讲了 Synchronized 关键字，还有并发包下面的一些锁，以及各自的优缺点</span><br><span class="line">和区别。volatile 关键字我主要从可见性、原子性和禁止 JVM 指令重排序三个方面讲的，</span><br><span class="line">再讲了一下我在多线程的单例模式 double-check 中用到 volatile 关键字禁止 JVM 指令重</span><br><span class="line">排优化。</span><br></pre></td></tr></table></figure>

<h2 id="JVM-的垃圾回收机制了解吗？"><a href="#JVM-的垃圾回收机制了解吗？" class="headerlink" title="JVM 的垃圾回收机制了解吗？"></a>JVM 的垃圾回收机制了解吗？</h2><p>标记-清楚算法、复制算法、标记-压缩算法、分代收集算法的实现原理。</p>
<h3 id="一、-技术背景"><a href="#一、-技术背景" class="headerlink" title="一、 技术背景"></a>一、 技术背景</h3><p>JVM 内存主要分为五个区，哪些是线程共享的，哪些是线程独享的，每个区存放什么。</p>
<h3 id="二、-哪些内存需要回收？"><a href="#二、-哪些内存需要回收？" class="headerlink" title="二、 哪些内存需要回收？"></a>二、 哪些内存需要回收？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.1 引用计数算法</span><br><span class="line">2.1.1 算法分析</span><br><span class="line">2.1.2 优缺点</span><br><span class="line">2.1.3 是不是很无趣，来段代码压压惊</span><br><span class="line">2.2 可达性分析算法</span><br><span class="line">2.3 Java 中的引用你了解多少</span><br><span class="line">2.4 对象死亡（被回收）前的最后一次挣扎</span><br><span class="line">2.5 方法区如何判断是否需要回收</span><br></pre></td></tr></table></figure>
<h3 id="三、常用的垃圾收集算法"><a href="#三、常用的垃圾收集算法" class="headerlink" title="三、常用的垃圾收集算法"></a>三、常用的垃圾收集算法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.1 标记-清除算法</span><br><span class="line">3.2 复制算法</span><br><span class="line">3.3 标记-整理算法</span><br><span class="line">3.4 分代收集算法</span><br><span class="line">3.4.1 年轻代（Young Generation）的回收算法</span><br><span class="line">3.4.2 年老代（Old Generation）的回收算法</span><br><span class="line">3.4.3 持久代（Permanent Generation）的回收算法</span><br></pre></td></tr></table></figure>
<h3 id="四、常见的垃圾收集器"><a href="#四、常见的垃圾收集器" class="headerlink" title="四、常见的垃圾收集器"></a>四、常见的垃圾收集器</h3><h3 id="五、GC-是什么时候触发的（面试最常见的问题之一）"><a href="#五、GC-是什么时候触发的（面试最常见的问题之一）" class="headerlink" title="五、GC 是什么时候触发的（面试最常见的问题之一）"></a>五、GC 是什么时候触发的（面试最常见的问题之一）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.1 Scavenge GC</span><br><span class="line">5.2 Full GC</span><br><span class="line">https://www.cnblogs.com/1024Community/p/honery.html</span><br></pre></td></tr></table></figure>
<ol>
<li> 项目中用的是 CMS 垃圾回收器吗？为什么要分为四个阶段？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始标记，并发标记，重新标记，并发清理四阶段，系统要求快速响应低延迟，对于多核</span><br><span class="line">CPU 性能更佳等方面去回答即可，网上文章很多，这里不多赘述了。</span><br></pre></td></tr></table></figure>
<a href="https://www.jianshu.com/p/86e358afdf17">学习的链接-1</a><br><a href="https://zhuanlan.zhihu.com/p/150696908">学习的链接-2</a> </li>
</ol>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="我看你简历里说熟悉计算机网络，来聊一聊计算机网络吧。了不了解"><a href="#我看你简历里说熟悉计算机网络，来聊一聊计算机网络吧。了不了解" class="headerlink" title="我看你简历里说熟悉计算机网络，来聊一聊计算机网络吧。了不了解"></a>我看你简历里说熟悉计算机网络，来聊一聊计算机网络吧。了不了解</h2><p>tcp/udp，简单说下两者的区别？<br>区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP 面向连接（如打电话要先拨号建立连接）;UDP 是无连接的，即发送数据之前不</span><br><span class="line">需要建立连接。</span><br><span class="line">TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错、不丢失、不重</span><br><span class="line">复，且按序到达，UDP 尽最大努力交付，即不保证可靠交付。</span><br><span class="line">TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流;UDP 是面向报文</span><br><span class="line">的</span><br><span class="line">UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很</span><br><span class="line">有用，如 IP 电话，实时视频会议等）。</span><br><span class="line">每一条 TCP 连接只能是点到点的，UDP 支持一对一、一对多、多对一和多对多的交</span><br><span class="line">互通信。</span><br><span class="line">TCP 首部开销 20 字节;UDP 的首部开销小，只有 8 个字节。</span><br><span class="line">TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道。</span><br></pre></td></tr></table></figure>
<h2 id="两次握手为什么不可以？为什么要四次挥手？"><a href="#两次握手为什么不可以？为什么要四次挥手？" class="headerlink" title="两次握手为什么不可以？为什么要四次挥手？"></a>两次握手为什么不可以？为什么要四次挥手？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 B，因而产生错误。失</span><br><span class="line">效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段</span><br><span class="line">时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。考虑这</span><br><span class="line">样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟</span><br><span class="line">达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发</span><br><span class="line">回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机</span><br><span class="line">B 的资源浪费。</span><br><span class="line">TCP 关闭链接四次握手原因在于 TCP 链接是全双工通道，需要双向关闭。client 向 server</span><br><span class="line">发送关闭请求，表示 client 不再发送数据，server 响应。此时 server 端仍然可以向 client</span><br><span class="line">发送数据，待 server 端发送数据结束后，就向 client 发送关闭请求，然后 client 确认。</span><br></pre></td></tr></table></figure>
<h2 id="TCP-怎么保证有序传输的？"><a href="#TCP-怎么保证有序传输的？" class="headerlink" title="TCP 怎么保证有序传输的？"></a>TCP 怎么保证有序传输的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用数据被分割成 TCP 认为最适合发送的数据块。</span><br><span class="line">超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文</span><br><span class="line">段。如果不能及时收到一个确认，将重发这个报文段。</span><br><span class="line">TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用</span><br><span class="line">层</span><br><span class="line">校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测</span><br><span class="line">数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段</span><br><span class="line">和不确认收到此报文段。</span><br><span class="line">TCP 的接收端会丢弃重复的数据。</span><br><span class="line">流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端</span><br><span class="line">发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送</span><br><span class="line">方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协</span><br><span class="line">议。</span><br><span class="line">拥塞控制：当网络拥塞时，减少数据的发送。</span><br></pre></td></tr></table></figure>
<h2 id="time-wait-状态，这个状态出现在什么地方，有什么用？"><a href="#time-wait-状态，这个状态出现在什么地方，有什么用？" class="headerlink" title="time_wait 状态，这个状态出现在什么地方，有什么用？"></a>time_wait 状态，这个状态出现在什么地方，有什么用？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 为实现 TCP 全双工连接的可靠释放</span><br><span class="line">当服务器先关闭连接,如果不在一定时间内维护一个这样的 TIME_WAIT 状态,那么当被动关</span><br><span class="line">闭的一方的 FIN 到达时，服务器的 TCP 传输层会用 RST 包响应对方，这样被对方认为是</span><br><span class="line">有错误发生，事实上这只是正常的关闭连接工程，并没有异常。</span><br><span class="line">2. 为使过期的数据包在网络因过期而消失</span><br><span class="line">在这条连接上，客户端发送了数据给服务器，但是在服务器没有收到数据的时候服务器就</span><br><span class="line">断开了连接。</span><br><span class="line">现在数据到了，服务器无法识别这是新连接还是上一条连接要传输的数据，一个处理不当</span><br><span class="line">就会导致诡异的情况发生。</span><br></pre></td></tr></table></figure>
<h2 id="HTTP-与-HTTPS-有啥区别？HTTPS-是怎么做到安全的？"><a href="#HTTP-与-HTTPS-有啥区别？HTTPS-是怎么做到安全的？" class="headerlink" title="HTTP 与 HTTPS 有啥区别？HTTPS 是怎么做到安全的？"></a>HTTP 与 HTTPS 有啥区别？HTTPS 是怎么做到安全的？</h2><p>HTTPS 安全的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTPS 把 HTTP 消息进行加密之后再传送，这样就算坏人拦截到了，得到消息之后也看不</span><br><span class="line">懂，这样就做到了安全，具体来说，HTTPS 是通过对称加密和非对称加密和 hash 算法共</span><br><span class="line">同作用，来在性能和安全性上达到一个平衡，加密是会影响性能的，尤其是非对称加密，</span><br><span class="line">因为它的算法比较复杂，那么加密了就安全了吗？不是的，HTTPS 除了对消息进行了加密</span><br><span class="line">以外还会对通信的对象进行身份验证。</span><br><span class="line">HTTPS 并不是一种新的协议，而是使用了一种叫做 TLS（Transport layer secure）的安</span><br><span class="line">全层，这个安全层提供了数据加密的支持，让 HTTP 消息运行在这个安全层上，就达到了</span><br><span class="line">安全，而运行在这个安全层上的 HTTP 就叫做 HTTPS。</span><br></pre></td></tr></table></figure>




<p>作者：前行的乌龟<br>链接：<a href="https://juejin.cn/post/6860153911366385678">https://juejin.cn/post/6860153911366385678</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-类的加载</title>
    <url>/2022/01/29/Java-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>类的加载过程:</p>
<h1 id="Java-类的加载器"><a href="#Java-类的加载器" class="headerlink" title="Java 类的加载器"></a>Java 类的加载器</h1><p>Java 类的加载器是 Java 虚拟机（JVM）的一个重要组成部分，它负责将 Java 类文件加载到内存中，并将其转换为 Java 类对象。Java 类加载器主要有以下三种类型：</p>
<p>Bootstrap ClassLoader（引导类加载器）：也称为根加载器，是 Java 虚拟机内置的类加载器，负责加载 Java 运行时环境所需的基础类，如 java.lang 包中的类。</p>
<p>Extension ClassLoader（扩展类加载器）：负责加载 Java 运行时环境的扩展类，即位于 jre/lib/ext 目录下的类。</p>
<p>System ClassLoader（系统类加载器）：也称为应用程序类加载器，负责加载应用程序类路径（Classpath）下的类。</p>
<p>此外，还有一种特殊的类加载器：用户自定义类加载器。这种类加载器是由开发人员自己实现的，可以用来加载一些特殊的类或者是自定义的类，例如动态加载类、热部署、插件化等。用户自定义类加载器需要继承自 java.lang.ClassLoader 类，并重写父类中的 findClass() 方法来实现类的加载。</p>
<p>Java 类加载器的作用是实现类的动态加载，这使得 Java 应用程序可以在运行时动态地加载一些类或者资源。通过类加载器，Java 应用程序可以实现一些特殊的功能，例如模块化编程、插件化架构、代码热替换等。同时，类加载器还能够保证类的安全性，避免因为恶意代码或者不良代码的加载而导致的安全漏洞。</p>
<h1 id="java虚拟机是如何加载类"><a href="#java虚拟机是如何加载类" class="headerlink" title="java虚拟机是如何加载类"></a>java虚拟机是如何加载类</h1><p>假设有一个类 MyClass，该类的源代码位于 MyClass.java 文件中。当 Java 应用程序运行时，它需要将该类加载到内存中，并创建该类的实例。</p>
<p>加载：Java 应用程序首先需要加载 MyClass 的二进制数据。Java 虚拟机根据类的全限定名 com.example.MyClass 来查找并加载该类的二进制数据，例如 com/example/MyClass.class 文件。</p>
<p>验证：Java 虚拟机会对 MyClass 类的字节码进行验证，以确保它符合 Java 虚拟机规范。</p>
<p>准备：在验证通过后，Java 虚拟机为 MyClass 类的静态变量分配内存，并设置默认值，例如将整型静态变量赋值为 0。</p>
<p>解析：Java 虚拟机将 MyClass 类的符号引用（例如类名）转换为直接引用（例如内存地址），以便于执行代码时访问类的方法和属性。</p>
<p>初始化：最后，Java 虚拟机执行 MyClass 类的静态初始化代码，例如赋初始值给静态变量。</p>
<p>在加载 MyClass 类的过程中，Java 类加载器起到了关键的作用。如果 MyClass 类位于应用程序类路径下，则由系统类加载器加载；如果该类位于扩展路径下，则由扩展类加载器加载；如果该类是 Java 运行时环境的基础类，则由引导类加载器加载。</p>
<p>总之，Java 应用程序的类加载过程是一个动态的过程，Java 类加载器负责将类加载到内存中，Java 虚拟机负责验证、准备、解析和初始化类，最终创建该类的实例。</p>
<h2 id="什么是java虚拟机的规范"><a href="#什么是java虚拟机的规范" class="headerlink" title="什么是java虚拟机的规范"></a>什么是java虚拟机的规范</h2><p>Java 虚拟机规范（Java Virtual Machine Specification）是一份由 Oracle 公司发布的文档，描述了 Java 虚拟机（JVM）的实现规范和行为规范，包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM 的内部结构和运行机制。</span><br><span class="line">JVM 支持的数据类型和指令集。</span><br><span class="line">Java 字节码的格式和语义。</span><br><span class="line">类加载器的机制和类加载的过程。</span><br><span class="line">Java 虚拟机的执行引擎和垃圾回收机制。</span><br><span class="line">Java 虚拟机规范的主要作用是为 Java 语言的跨平台特性提供了支持。由于 Java 虚拟机规范定义了 Java 字节码的格式和语义，以及虚拟机的内部结构和运行机制，因此只要编译出的 Java 代码符合 Java 字节码的规范，就可以在任何支持 Java 虚拟机规范的平台上运行。</span><br></pre></td></tr></table></figure>
<p>同时，Java 虚拟机规范还为 JVM 的实现提供了一些指导性的建议，使得不同的 JVM 实现可以保证在一定程度上的互操作性，也便于开发者对 JVM 进行优化和调试。</p>
<p>Java 虚拟机规范是 Java 平台的核心技术之一，它不仅为 Java 语言的跨平台特性提供了支持，也为 Java 生态系统的发展</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-内存模型</title>
    <url>/2022/01/29/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><p>如果开发项目涉及到并发，一般需要考虑2个问题</p>
<ul>
<li>线程之间如何通信 </li>
<li>线程之间如何同步 （这里的线程是指并发执行的活动实体）</li>
</ul>
<p>通信是指线程之间以何种机制来交换信息。</p>
<blockquote>
<p>比如Android比较常见的:线程之间的通信机制 Handler</p>
</blockquote>
<p>在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<!-- 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。 Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的 Java 程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。  -->

<h1 id="Java的并发模型"><a href="#Java的并发模型" class="headerlink" title="Java的并发模型"></a>Java的并发模型</h1><!-- 最近看罗翔老师的刑法课程还有刑法相关的书，让我领悟到一些比较深刻的道理，嫌弃人的犯罪的内在动机有时候更重要。 -->
<p>编程上的专业术语都有特定的定义，饮水思源，思考为什么要设计出来，还有为什么要这样设计，当2个时候都满足的时候，定义也就自然而然的清楚了。</p>
<p>众所周知，我们Java是跨平台，因为不同平台的硬件和操作系统访问都是存在访问差异的，为了要保证Java程序在各个平台下的运行对内存的访问都能得到一致效果的机制和规范，这就是为什么要设计JMM内存模型。</p>
<p>根据Google后，相关的资料，其实JMM只是一个抽象的概念，描述一个规则和规范，这个后面会细讲。</p>
<p>目的是解决由于多线程通过主存(共享内存)进行通信时，存在的原子性，可见性(缓存一致性)以及有序性问题。</p>
<h2 id="JMM-规范"><a href="#JMM-规范" class="headerlink" title="JMM 规范"></a>JMM 规范</h2><p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<blockquote>
<p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。</p>
</blockquote>
<blockquote>
<p>局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响</p>
</blockquote>
<p>1.在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，</p>
<blockquote>
<p>典型的共享内存通信方式就是通过共享对象进行通信。</p>
</blockquote>
<blockquote>
<p>参考  <a href="https://zhupengbo.com/2021/08/04/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">Linux 进程与线程</a></p>
</blockquote>
<p>每个线程都有对应自己独立，私有的栈区。</p>
<p>Java线程之间的通信由Java内存模型（本文简称为JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系:线程之间的共享变量存储在主内存( main memory )中，每个线程都有一个私有的本地内存( local memory )，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
<h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><p>java代码 &gt; 编译器重排序 &gt; 指令重排序 &gt; 内存重排序</p>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>CPU运行效率 相比缓存、内存、硬盘IO之间效率有着指数级的差别，目的就是把CPU的资源利用起来</p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>针对程序代码语而言，编译器可以在不改变单线程程序语义的情况下，可以对代码语句顺序进行调整重新排序。</p>
<h1 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h1><h1 id="as-if—serial-语义"><a href="#as-if—serial-语义" class="headerlink" title="as-if—serial 语义"></a>as-if—serial 语义</h1><p>as-if-serial语义的意思指∶不管怎么重排序（编译器和处理器为了提高并行度），(单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p>
<h1 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h1><p>JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标∶在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从happens –before 的定义我们可以看出，JMM同样遵从这一目标。</p>
<hr>
<h1 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h1><p>JVM 规定了先行发生的有的原则，让一个操作无需控制就能先于另一个操作完成</p>
<h2 id="单一线程原则"><a href="#单一线程原则" class="headerlink" title="单一线程原则"></a>单一线程原则</h2><blockquote>
<p>Single Thread rule<br>在同一个线程内，书写在前面的操作happen-before后面的操作。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 3; // 1</span><br><span class="line">int b = a + 1; // 2</span><br></pre></td></tr></table></figure>
<p>这个时候，java虚拟机不会对 1，2 的顺序进行重排序排序，jvm一定会保证1对2的可见性。<br>再换个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 3; // 1</span><br><span class="line">int b = 4; // 2</span><br></pre></td></tr></table></figure>
<h2 id="这2个语句没有依赖性，所以指定会进行重排序，有可能2是在1的前面。"><a href="#这2个语句没有依赖性，所以指定会进行重排序，有可能2是在1的前面。" class="headerlink" title="这2个语句没有依赖性，所以指定会进行重排序，有可能2是在1的前面。"></a>这2个语句没有依赖性，所以指定会进行重排序，有可能2是在1的前面。</h2><h2 id="管程锁定规则-锁的原则"><a href="#管程锁定规则-锁的原则" class="headerlink" title="管程锁定规则(锁的原则)"></a>管程锁定规则(锁的原则)</h2><h2 id="同一个锁的unlock操作happen-before此锁的lock操作"><a href="#同一个锁的unlock操作happen-before此锁的lock操作" class="headerlink" title="同一个锁的unlock操作happen-before此锁的lock操作"></a>同一个锁的unlock操作happen-before此锁的lock操作</h2><h2 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h2><ul>
<li>简而言之，volatile变量自身具有下列特性︰</li>
</ul>
<ul>
<li>内存可见性 : 当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。</li>
<li>原子性︰对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
<li>有序性 : 保证这个变量之前的代码一定会比它先执行，而之后的代码一定会比它后执行, 编译器不会对此变量次序进行排序优化。</li>
</ul>
<h3 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"> </span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;         //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 flag变量 为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
</blockquote>
<p>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行。</p>
<p>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<blockquote>
<p>什么是复合操作 ?  既读又写</p>
</blockquote>
<h1 id="volatile-写-读建立的happen-before-关系"><a href="#volatile-写-读建立的happen-before-关系" class="headerlink" title="volatile 写-读建立的happen-before 关系"></a>volatile 写-读建立的happen-before 关系</h1><p>从内存的语义，volatile写和锁的释放有相同的内存语义，volatile读和锁的获取有相同的内存语义。</p>
<h1 id="volatile-写-读-内存语义"><a href="#volatile-写-读-内存语义" class="headerlink" title="volatile 写-读 内存语义"></a>volatile 写-读 内存语义</h1><p>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所在修改的)消息。</p>
<p>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的(在写这个volatile变量之前对共享变量所做修改的)消息。</p>
<p>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h1 id="释放和获得锁的含义"><a href="#释放和获得锁的含义" class="headerlink" title="释放和获得锁的含义"></a>释放和获得锁的含义</h1><p>当线程释放锁时，JMM 会把本地的内存中的共享变量刷新到主存。</p>
<p>当线程获得锁时，JMM 会把本地的内存中的共享变量置为无效。从而使监视器的保护的临界代码必须要从主存中读取共享变量。</p>
<h1 id="内存访问重排序与Java内存模型"><a href="#内存访问重排序与Java内存模型" class="headerlink" title="内存访问重排序与Java内存模型"></a>内存访问重排序与Java内存模型</h1><p><img src="https://p0.meituan.net/travelcube/94e93b3a7b49dc4c46b528fde1a03cd967665.png" alt="重排序示意表"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile int v1 = 1;</span><br><span class="line">volatile int v2 = 2;</span><br><span class="line">int v3 = 3;</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">    int a = v3 + 1;</span><br><span class="line">    int b = v1 + v3; // 第二个 volatile 写时。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当第二个操作是volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile 写之前的操作不会被编译器重排序到volatile 写之后。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile int v1 = 1;</span><br><span class="line">volatile int v2 = 2;</span><br><span class="line">int v3 = 0;</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">    int a = v1; // 第一个 volatile 读</span><br><span class="line">    int b = v3 + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile 读之后的操作不会被编译器重排序到 volatile 读之前。</p>
<hr>
<h1 id="volatile-内存语义"><a href="#volatile-内存语义" class="headerlink" title="volatile 内存语义"></a>volatile 内存语义</h1><p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入 内存屏障 来禁止特定类型的处理器重排序。</p>
<h2 id="JMM内存屏障插入策略"><a href="#JMM内存屏障插入策略" class="headerlink" title="JMM内存屏障插入策略"></a>JMM内存屏障插入策略</h2><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p>
<p><img src="https://p0.meituan.net/travelcube/bde75d1129494bf77b8b8b1ade546cd276768.png" alt="内存屏障示意表"></p>
<h2 id="JMM内存屏障插入策略-1"><a href="#JMM内存屏障插入策略-1" class="headerlink" title="JMM内存屏障插入策略"></a>JMM内存屏障插入策略</h2><ul>
<li><p>在每个 volatile 写操作的前面插入一个 <strong>StoreStore</strong>屏障。</p>
</li>
<li><p>在每个 volatile 写操作的后面插入一个 <strong>StoreLoa</strong>屏障。</p>
</li>
<li></li>
<li><p>在每个 volatile 读操作的前面插入一个 <strong>LoadLoad</strong>屏障。</p>
</li>
<li><p>在每个 volatile 读操作的后面插入一个 <strong>LoadStore</strong>屏障。</p>
</li>
</ul>
<p>在 StoreStore屏障可以保证在 volatile 写之前，其前面的操作已经对任意处理器可见，把StoreStore上面的普通读写操作在volatile写之前刷新到主存。</p>
<hr>
<!-- # ReentrantLock -->


<!-- 
# Android共享内存


2.在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型
的消息传递方式就是wait()和notify()。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同步,异步,串行与并行:</span><br><span class="line">Java同步机制（同步方法或者同步块中）有4种实现方式：</span><br><span class="line">① ThreadLocal  </span><br><span class="line">② synchronized()   </span><br><span class="line">③ wait() 与 notify() </span><br><span class="line">④ volatile </span><br><span class="line">异步的同义语是非阻塞（None Blocking）。</span><br><span class="line">— 以通讯为例</span><br><span class="line">同步:发送一个请求,等待返回,然后再发送下一个请求</span><br><span class="line">异步:发送一个请求,不等待返回,随时可以再发送下一个请求</span><br><span class="line">并发:同时发送多个请求 --&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Zygote剖析</title>
    <url>/2022/01/13/Zygote%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h1><p>任何系统启动过程的本质都是要建立一套系统运行所需的环境。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>Zygote</strong> 进程运行时，会初始化 <strong>Dalvik虚拟机</strong>，并启动它。<br>Android的应用程序是由Java编写的，它们不能直接以本地进程的形态运行在Linux 上，只能运行在Dalvik虚拟机中。</p>
<p>并且，每个应用程序都运行在各自的虚拟机中，</p>
<p>应用程序每次运行都要重新初始化并启动虚拟机，这个过程会耗费相当长时间，是拖慢应用程序的原因之一。</p>
<p>因此，在Android 中，应用程序运行前，Zygote进程通过共享已运行的虚拟机的代码与内存信息，缩短应用程序运行所耗费的时间。并且，它会事先将应用程序要使用的Android Framework中的类与资源加载到内存中，并组织形成所用资源的链接信息。新运行的Android应用程序在使用所需资源时不必每次重新形成资源的链接信息，这会节省大量时间，提高程序运行速度。</p>
<p>反推 一般Zygote都是Android应用程序。 </p>
<blockquote>
</blockquote>
<ol>
<li>init进程系统启动后运行在用户空间中的首个进程。  </li>
<li>init进程启动完系统运行所需要的各种 Daemon后。  </li>
<li>启动Zygote进程。</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-渲染机制</title>
    <url>/2022/01/10/Android-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="像素的计算"><a href="#像素的计算" class="headerlink" title="像素的计算"></a>像素的计算</h1><p>简单的科普下</p>
<ul>
<li>1 Inch = 2.54 cm</li>
<li>1 寸 = 3.33300 cm</li>
<li>1尺=10寸, 1寸=10分<h1 id="Px"><a href="#Px" class="headerlink" title="Px"></a>Px</h1>个人简单的理解：Pixel是一个带颜色的方块，一个图片其实就是由这些方块组成的<h1 id="Ppi"><a href="#Ppi" class="headerlink" title="Ppi"></a>Ppi</h1>PPI的意思是：Pixels Per Inch ，即每英寸所拥有的像素数目。</li>
</ul>
<p>所以PPI的理论表述应该是px/in，如：iphone5s的PPI是326px/in。<br>可以看到：PPI=像素数量/物理尺寸（英寸数）</p>
<blockquote>
<p>注意，这里的像素数量指的是一个维度的，比如X轴的像素数量，或Y轴的像素数量，或者对角线的像素数量。而不是总的像素数量。</p>
</blockquote>
<p>那么就好办了。这是PPI的计算公式。</p>
<img src="https://pic3.zhimg.com/50/7960dd56f2627a5f4441538c26adf6d7_720w.jpg?source=1940ef5c" data-rawwidth="500" data-rawheight="265" class="origin_image zh-lightbox-thumb" width="500" data-original="https://pic1.zhimg.com/7960dd56f2627a5f4441538c26adf6d7_r.jpg?source=1940ef5c"/>

<p>我们再看一下勾股定律：如果直角三角形两直角边为a和b，斜边为c，那么a²+b²=c²。所以：PPI计算公式里√（x²+y²）这一部分计算的是屏幕对角线的像素数。(有人说对角线上的像素数量难以计算，所以特此说明：这里所说的对角线像素数并非实际上屏幕对角线有多少像素，只是在此公式中等效于对角线像素数量，只是数学意义上的一个值，用于计算。)而一般说的屏幕尺寸说的是屏幕对角线的长度。</p>
<p>比如iphone 6 plus的屏幕尺寸是5.5in，说的也是屏幕对角线的长度。那么这个公式就回到了上面说的：PPI=像素数量/物理尺寸（英寸数）所以，如果知道屏幕横向或者竖向的物理尺寸，PPI也可以用横向或竖向的像素数来计算。即：屏幕分辨率是X*Y。PPI=X/屏幕宽度（英寸）PPI=Y/屏幕高度（英寸）这样就好理解的多。而之所以要用对角线来计算，是因为屏幕对角线长度（屏幕尺寸）是厂商制造时就定好的精确数值。而宽和高都需要计算才能得到。</p>
<pre><code>作者：chen vincent
链接：https://www.zhihu.com/question/21220154/answer/56288324
来源：知乎
s著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h1 id="Dpi"><a href="#Dpi" class="headerlink" title="Dpi"></a>Dpi</h1><p>dpi（dots per inch）点每英寸，常用于平面印刷。</p>
<p>dot就是一个点，打印机或屏幕通过这些点把图片print出来。</p>
<p>如果是针对在电脑屏幕或手机屏幕上面来说DPI=PPI。</p>
<p>我总结下：Pixel是一个带颜色的方块，一个图片其实就是由这些方块组成的。dot就是一个点，打印机或屏幕通过这些点把图片print出来。</p>
<p>例如：一个150ppi的图片在600dpi的设备上显示，每个pixel有16个dot (600 dots/150 pixels)PPI vs. DPI: what’s the difference?</p>
<pre><code>作者：蛮大人
链接：https://www.zhihu.com/question/23770739/answer/51830906  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  
</code></pre>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-AmS内部原理</title>
    <url>/2021/12/13/Android-AmS%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="补充文章"><a href="#补充文章" class="headerlink" title="补充文章"></a>补充文章</h1><p><a href="https://cloud.tencent.com/developer/article/1029670">https://cloud.tencent.com/developer/article/1029670</a></p>
<h1 id="AMS-主要功能"><a href="#AMS-主要功能" class="headerlink" title="AMS 主要功能"></a>AMS 主要功能</h1><p>1.统一调度各个 App 的 Activity</p>
<p>2.内存管理</p>
<p>3.进程管理</p>
<h1 id="Android内存管理"><a href="#Android内存管理" class="headerlink" title="Android内存管理"></a>Android内存管理</h1><ul>
<li>Android内存管理分为2个部分</li>
</ul>
<ul>
<li>应用程序关闭之后，后台对应的进程没有真正的关闭，以便下次快速的再启动(温启动)。</li>
<li>当系统内存不够时，Ams(ActivityManagerService)会主动根据一定的优先级规则退出优先级低的进程</li>
</ul>
<h1 id="关闭与退出"><a href="#关闭与退出" class="headerlink" title="关闭与退出"></a>关闭与退出</h1><p>关闭是指进程对应的窗口不显示，而后台的进程还在保存。<br>Android 关闭的机制除了占用内存之外，基本上不会降低前台应用的程序。</p>
<p>消息分发机制<br>每一个App的对应一个 ActivityThread，该类初始化后就进入Looper.loop()的无限循环。</p>
<p><strong>ActivityThread</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>之后则是靠消息分发机制运行，没有消息则会sleep，阻塞起来，直到有新的msg过来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>总结：在Linux的内核调度中，如果一个线程的状态为sleep，除了占用调用本身时间之外，不占用Cpu的时间片。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Message msg = queue.next(); // might block</span><br></pre></td></tr></table></figure>
<blockquote>
<p>被唤醒的3种情况<br>定时器中断<br>用户按键消息(消息线程)<br>Binder消息(Binder线程)  </p>
</blockquote>
<h2 id="温启动"><a href="#温启动" class="headerlink" title="温启动"></a>温启动</h2><p> 温启动时由于app的进程仍然存在，只执行冷启动第二阶段流程</p>
<blockquote>
<p>1、创建app对象<br>2、启动主进程<br>3、创建MainActivity<br>4、渲染视图<br>5、执行onLayout<br>6、执行onDraw  </p>
</blockquote>
<p>温启动常见场景：</p>
<blockquote>
<p>1、用户双击返回键退出应用<br>2、app由于内存不足被回收</p>
</blockquote>
<hr>
<h1 id="Android-与-Linux-配合"><a href="#Android-与-Linux-配合" class="headerlink" title="Android 与 Linux  配合"></a>Android 与 Linux  配合</h1><p>App 和 AmS 是运行在2个独立的 Java虚拟机()，App申请内存不会通知AmS，AmS也无法感知App申请内存。</p>
<p>Java虚拟机运行时，每一个 App都有各自独立的内存空间。各自独立，进程互斥。</p>
<p>由于 Android 底层的 Linux 的内存机制不是使用 磁盘虚拟内存，所以 RAM=实际的物理内存。<br>为了在 RAM 中容纳所需的一切，Android 会尝试跨进程共享 RAM 页面。</p>
<blockquote>
<p> 回收的系统的“”潜规则  </p>
</blockquote>
<h2 id="OOM-Killer"><a href="#OOM-Killer" class="headerlink" title="OOM Killer"></a>OOM Killer</h2><p>在Android中运行了一个OOM 进程，即Out Of Memory。</p>
<p>该进程启动时会首先向Linux内核中把自己注册为一个OOM Killer，即当Linux内核的内存管理模块检测到系统内存低的时候就会通知已经注册的OOM进程，然后这些OOM Killer就可以根据各种规则进行内存释放了，当然也可以什么都不做。</p>
<p>Android中的OOM Killer进程是仅仅适用于Android应用程序的，该进程在运行时，AmS需要把每一个应用程序的oom_adj值告知给Killer。这个值的范围在－16到15，值越低，说明越重要，这个值类似于Linux系统中的进程nice值，只是在标准的Linux中，有其自己的一套Killer机制。</p>
<p>总结：当发生低内存的条件时，Linux内核管理模块通知OOM Killer，Killer则根据AmS所告知的优先级，强制退出优先级低的应用进程</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-反射与应用-基础概念</title>
    <url>/2021/12/13/Java-%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="RIIT"><a href="#RIIT" class="headerlink" title="RIIT"></a>RIIT</h1><blockquote>
<p>RTTI（RunTime Type Information，运行时类型信息）能够在程序运行时发现和使用类型信息</p>
</blockquote>
<p>Java 是如何在运行时识别对象和类信息的。主要有两种方式：</p>
<ol>
<li>“传统的” RTTI：假定我们在编译时已经知道了所有的类型；</li>
<li>“反射” 机制：允许我们在运行时发现和使用类的信息</li>
</ol>
<p>在 Java 中，每个对象都有一个与之关联的类，<strong>该类定义了对象的属性和方法</strong>。RTTI 允许程序在运行时确定对象的实际类型，而不是在编译时确定对象的静态类型。这意味着，即使对象的静态类型是某个父类或接口，程序仍然可以根据对象的实际类型来访问它的方法和属性。</p>
<p>在 Java 中，可以使用 instanceof 运算符来检查对象的类型，并根据对象的类型来执行相应的操作。例如：</p>
<figure class="highlight plaintext"><figcaption><span>code</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if (obj instanceof MyClass) &#123;</span><br><span class="line">   MyClass myObj = (MyClass) obj;</span><br><span class="line">   myObj.myMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会检查 obj 对象是否是 MyClass 类型的对象，如果是，就将 obj 强制转换为 MyClass 类型，并调用它的 myMethod 方法。</p>
<p>需要注意的是，如果对象的类型与 instanceof 运算符中指定的类型不兼容，会抛出 ClassCastException 异常。因此，在使用 RTTI 时，应该始终使用强制类型转换之前进行类型检查。</p>
<h2 id="为什么需要-RTTI-机制"><a href="#为什么需要-RTTI-机制" class="headerlink" title="为什么需要 RTTI 机制"></a>为什么需要 <strong>RTTI</strong> 机制</h2><p>RTTI 在 Java 中存在的意义在于它使得程序能够在运行时进行类型检查和动态多态性，从而使程序更加灵活、可靠和稳定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;? extends Object&gt; objClass = obj.getClass();</span><br></pre></td></tr></table></figure>

<p>这里涉及到另外一个根本的问题，为什么我们需要在运行时识别对象和类信息。<br>我们看一个demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">   public void makeSound() &#123;</span><br><span class="line">      System.out.println(&quot;The animal makes a sound&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">   public void makeSound() &#123;</span><br><span class="line">      System.out.println(&quot;The dog barks&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">   public void makeSound() &#123;</span><br><span class="line">      System.out.println(&quot;The cat meows&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Animal animal1 = new Animal();</span><br><span class="line">      Animal animal2 = new Dog();</span><br><span class="line">      Animal animal3 = new Cat();</span><br><span class="line">      </span><br><span class="line">      animal1.makeSound();</span><br><span class="line">      animal2.makeSound();</span><br><span class="line">      animal3.makeSound();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用多态性时，对象的实际类型和调用方法的类型可能不同，需要在运行时识别对象和类信息，在以上的信息中</p>
<blockquote>
<p>在上面的示例中，有三个 Animal 对象：animal1、animal2 和 animal3。  </p>
<blockquote>
<p>animal1 的实际类型是 Animal，animal2 的实际类型是 Dog，animal3 的实际类型是 Cat。<br>调用 makeSound() 方法时，animal1 会调用 Animal 类的 makeSound() 方法，输出 “The animal makes a sound”；animal2 会调用 Dog 类的 makeSound() 方法，输出 “The dog barks”；animal3 会调用 Cat 类的 makeSound() 方法，输出 “The cat meows”。</p>
</blockquote>
</blockquote>
<p><strong>因为在编译时，编译器只能确定调用 makeSound() 方法的对象是 Animal 类型的，无法确定其实际类型是什么，因此需要在运行时识别对象和类信息，才能确定调用哪个方法。</strong></p>
<p>通过这个例子，可以看到，运行时识别对象和类信息是多态性的关键，也是 Java 中许多其他特性的基础。</p>
<h1 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a><strong>Class</strong> 对象</h1><p>引用</p>
<p>要理解 RTTI 在 Java 中的工作原理，首先必须知道类型信息在运行时是如何表示的。<br>这项工作是由称为 Class 对象的特殊对象完成的，它包含了与类有关的信息。<br>实际上，Class 对象就是用来创建该类所有 “常规” 对象的。<br>Java 使用 Class 对象来实现RTTI，即便是类型转换这样的操作都是用 Class 对象实现的。</p>
<p>类是程序的一部分，每个类都有一个 Class 对象。换言之，每当我们编写并且编译<br>了一个新类，就会产生一个 Class 对象（更恰当的说，是被保存在一个同名的 .class<br>文件中）。为了生成这个类的对象，Java 虚拟机 (JVM) 先会调用 “类加载器” 子系统把<br>这个类加载到内存中。</p>
<blockquote>
<p>类加载器首先会检查这个类的 Class 对象是否已经加载，如果尚未加载，默认的类<br>加载器就会根据类名查找 .class 文件（如果有附加的类加载器，这时候可能就会在数<br>据库中或者通过其它方式获得字节码）。这个类的字节码被加载后，JVM 会对其进行验<br>证，确保它没有损坏，并且不包含不良的 Java 代码 (这是 Java 安全防范的一种措施)。</p>
</blockquote>
<p>一旦某个类的 Class 对象被载入内存，它就可以用来创建这个类的所有对象。下<br>面的示范程序可以证明这点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// typeinfo/SweetShop.java</span><br><span class="line">// 检查类加载器工作方式</span><br><span class="line">class Cookie &#123;</span><br><span class="line">static &#123; System.out.println(&quot;Loading Cookie&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Gum &#123;</span><br><span class="line">static &#123; System.out.println(&quot;Loading Gum&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Candy &#123;</span><br><span class="line">static &#123; System.out.println(&quot;Loading Candy&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class SweetShop &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;inside main&quot;);</span><br><span class="line">new Candy();</span><br><span class="line">System.out.println(&quot;After creating Candy&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">Class.forName(&quot;Gum&quot;);</span><br><span class="line">&#125; catch(ClassNotFoundException e) &#123;</span><br><span class="line">System.out.println(&quot;Couldn&#x27;t find Gum&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;After Class.forName(\&quot;Gum\&quot;)&quot;);</span><br><span class="line">new Cookie();</span><br><span class="line">System.out.println(&quot;After creating Cookie&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">inside main</span><br><span class="line">Loading Candy</span><br><span class="line">After creating Candy</span><br><span class="line">Loading Gum</span><br><span class="line">After Class.forName(&quot;Gum&quot;)</span><br><span class="line">Loading Cookie</span><br><span class="line">After creating Cookie</span><br></pre></td></tr></table></figure>

<p>Class 对象仅在需要的时候才会被加载，static 初始化是在类加载时进行的。<br>重点的是注意这行代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;Gum&quot;);</span><br></pre></td></tr></table></figure>
<p>forName() 是 Class 类的一个静态方法，我<br>们可以使用 forName() 根据目标类的类名（String）得到该类的 Class 对象。上面的<br>代码忽略了 forName() 的返回值，因为那个调用是为了得到它产生的 “副作用”。<br>从结果可以看出，forName() 执行的副作用是如果 Gum 类没有被加载就加载它，而在加载的过程中，Gum 的 static 初始化块被执行了。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface HasBatteries &#123;&#125;</span><br><span class="line">interface Waterproof &#123;&#125;</span><br><span class="line">interface Shoots &#123;&#125;</span><br><span class="line">class Toy &#123;</span><br><span class="line">// 注释下面的无参数构造器会引起 NoSuchMethodError 错误</span><br><span class="line">Toy() &#123;&#125;</span><br><span class="line">Toy(int i) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class FancyToy extends Toy</span><br><span class="line">implements HasBatteries, Waterproof, Shoots &#123;</span><br><span class="line">FancyToy() &#123; super(1); &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ToyTest &#123;</span><br><span class="line">static void printInfo(Class cc) &#123;</span><br><span class="line">System.out.println(&quot;Class name: &quot; + cc.getName() +</span><br><span class="line">&quot; is interface? [&quot; + cc.isInterface() + &quot;]&quot;);</span><br><span class="line">System.out.println(</span><br><span class="line">&quot;Simple name: &quot; + cc.getSimpleName());</span><br><span class="line">System.out.println(</span><br><span class="line">&quot;Canonical name : &quot; + cc.getCanonicalName());</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Class c = null;</span><br><span class="line">try &#123;</span><br><span class="line">c = Class.forName(&quot;typeinfo.toys.FancyToy&quot;);</span><br><span class="line">&#125; catch(ClassNotFoundException e) &#123;</span><br><span class="line">System.out.println(&quot;Can&#x27;t find FancyToy&quot;);</span><br><span class="line">System.exit(1);</span><br><span class="line">&#125;</span><br><span class="line">printInfo(c);</span><br><span class="line">for(Class face : c.getInterfaces())</span><br><span class="line">printInfo(face);</span><br><span class="line">Class up = c.getSuperclass();</span><br><span class="line">Object obj = null;</span><br><span class="line">try &#123;</span><br><span class="line">// Requires no-arg constructor:</span><br><span class="line">obj = up.newInstance();</span><br><span class="line">&#125; catch(InstantiationException e) &#123;</span><br><span class="line">System.out.println(&quot;Cannot instantiate&quot;);</span><br><span class="line">System.exit(1);</span><br><span class="line">&#125; catch(IllegalAccessException e) &#123;</span><br><span class="line">System.out.println(&quot;Cannot access&quot;);</span><br><span class="line">System.exit(1);</span><br><span class="line">&#125;</span><br><span class="line">printInfo(obj.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Class name: typeinfo.toys.FancyToy is interface?</span><br><span class="line">[false]</span><br><span class="line">Simple name: FancyToy</span><br><span class="line">Canonical name : typeinfo.toys.FancyToy</span><br><span class="line">Class name: typeinfo.toys.HasBatteries is interface?</span><br><span class="line">[true]</span><br><span class="line">Simple name: HasBatteries</span><br><span class="line">Canonical name : typeinfo.toys.HasBatteries</span><br><span class="line">Class name: typeinfo.toys.Waterproof is interface?</span><br><span class="line">[true]</span><br><span class="line">Simple name: Waterproof</span><br><span class="line">Canonical name : typeinfo.toys.Waterproof</span><br><span class="line">Class name: typeinfo.toys.Shoots is interface? [true]</span><br><span class="line">Simple name: Shoots</span><br><span class="line">Canonical name : typeinfo.toys.Shoots</span><br><span class="line">Class name: typeinfo.toys.Toy is interface? [false]</span><br><span class="line">Simple name: Toy</span><br><span class="line">Canonical name : typeinfo.toys.Toy</span><br></pre></td></tr></table></figure>

<p>你还可以调用 getSuperclass() 方法来得到父类的 Class 对象，再用父类的 Class 对象调用该方法，重复多次，你就可以得到一个对象完整的类继承结构</p>
<h2 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h2><p>当使用 .class 来创建对 Class 对象的引用时，不会自动地<br>初始化该 Class 对象。为了使用类而做的准备工作实际包含三个步骤：</p>
<blockquote>
<ol>
<li>加载，这是由类加载器执行的。该步骤将查找字节码（通常在 classpath 所指定的<br>路径中查找，但这并非是必须的），并从这些字节码中创建一个 Class 对象。</li>
<li>链接。在链接阶段将验证类中的字节码，为 static 字段分配存储空间，并且如果需要的话，将解析这个类创建的对其他类的所有引用。</li>
<li>初始化。如果该类具有超类，则先初始化超类，执行 static 初始化器和 static 初始化块。</li>
</ol>
</blockquote>
<p>直到第一次引用一个 static 方法（构造器隐式地是 static）或者非常量的 static<br>字段，才会进行类初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// typeinfo/ClassInitialization.java</span><br><span class="line">import java.util.*;</span><br><span class="line">第十九章类型信息 11</span><br><span class="line">class Initable &#123;</span><br><span class="line">static final int STATIC_FINAL = 47;</span><br><span class="line">static final int STATIC_FINAL2 =</span><br><span class="line">ClassInitialization.rand.nextInt(1000);</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;Initializing Initable&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Initable2 &#123;</span><br><span class="line">static int staticNonFinal = 147;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;Initializing Initable2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Initable3 &#123;</span><br><span class="line">static int staticNonFinal = 74;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println(&quot;Initializing Initable3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ClassInitialization &#123;</span><br><span class="line">public static Random rand = new Random(47);</span><br><span class="line">public static void</span><br><span class="line">main(String[] args) throws Exception &#123;</span><br><span class="line">Class initable = Initable.class;</span><br><span class="line">System.out.println(&quot;After creating Initable ref&quot;);</span><br><span class="line">// Does not trigger initialization:</span><br><span class="line">System.out.println(Initable.STATIC_FINAL);</span><br><span class="line">// Does trigger initialization:</span><br><span class="line">System.out.println(Initable.STATIC_FINAL2);</span><br><span class="line">// Does trigger initialization:</span><br><span class="line">System.out.println(Initable2.staticNonFinal);</span><br><span class="line">Class initable3 = Class.forName(&quot;Initable3&quot;);</span><br><span class="line">System.out.println(&quot;After creating Initable3 ref&quot;);</span><br><span class="line">System.out.println(Initable3.staticNonFinal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">After creating Initable ref</span><br><span class="line">47</span><br><span class="line">Initializing Initable</span><br><span class="line">258</span><br><span class="line">Initializing Initable2</span><br><span class="line">147</span><br><span class="line">Initializing Initable3</span><br><span class="line">After creating Initable3 ref</span><br><span class="line">74</span><br></pre></td></tr></table></figure>

<p>初始化有效地实现了尽可能的 “惰性”，从对 initable 引用的创建中可以看<br>到，仅使用 .class 语法来获得对类对象的引用不会引发初始化。</p>
<p>但与此相反，使用 Class.forName() 来产生 Class 引用会立即就进行初始化，如 initable3。<br>如果一个 static final 值是 “编译期常量”（如 Initable.staticFinal），那么这<br>个值不需要对 Initable 类进行初始化就可以被读取。但是，如果只是将一个字段设置<br>成为 static 和 final，还不足以确保这种行为。<br>例如，对 Initable.staticFinal2 的访问将强制进行类的初始化，因为它不是一个编译期常量。<br>如果一个 static 字段不是 final 的，那么在对它访问时，总是要求在它被读取之<br>前，要先进行链接（为这个字段分配存储空间）和初始化（初始化该存储空间），就像<br>在对 Initable2.staticNonFinal 的访问中所看到的那样</p>
]]></content>
  </entry>
  <entry>
    <title>Android-小常识普及</title>
    <url>/2021/12/10/Android-%E5%B0%8F%E5%B8%B8%E8%AF%86%E6%99%AE%E5%8F%8A/</url>
    <content><![CDATA[<h1 id="Home键退出和返回键退出的区别"><a href="#Home键退出和返回键退出的区别" class="headerlink" title="Home键退出和返回键退出的区别"></a>Home键退出和返回键退出的区别</h1><p>Home键退出，程序保留状态为后台进程；<br>而返回键退出，程序保留状态为空进程，空进程更容易被系统回收。Home键其实主要用于进程间切换，返回键则是真正的退出程序。</p>
<p>从理论上来讲，无论是哪种情况，在没有任何后台工作线程（即便应用处于后台，工作线程仍然可以执行）的前提下，被置于后台的进程都只是保留他们的运行状态，并不会占用CPU资源，所以也不耗电。只有音乐播放软件之类的应用需要在后台运行Service，而Service是需要占用CPU时间的，此时才会耗电。所以说没有带后台服务的应用是不耗电也不占用CPU时间的，没必要关闭，这种设计本身就是Android的优势之一，可以让应用下次启动时更快。然而现实是，很多应用多多少少都会有一些后台工作线程，这可能是开发人员经验不足导致（比如线程未关闭或者循环发送的Handler消息未停止），也可能是为了需求而有意为之，导致整个Android应用的生态环境并不是一片干净。</p>
<h1 id="请问“强制进行GPU渲染”和“停用HW叠加层”有什么区别？"><a href="#请问“强制进行GPU渲染”和“停用HW叠加层”有什么区别？" class="headerlink" title="请问“强制进行GPU渲染”和“停用HW叠加层”有什么区别？"></a>请问“强制进行GPU渲染”和“停用HW叠加层”有什么区别？</h1><p>这两个还是有区别的，GPU渲染就是hwa（hard ware acceleration硬件加速）的一种，其存在的意义就是为了分担CPU的负担，其原理是通过GPU对软件图形图像的处理来减轻CPU的负担，从而使应用软件能够以更快的速度被处理，以达到提速的目的，简单来说就是一般情况下软件的2D图形图像处理是交给CPU的，3D图形图像处理才是交给GPU的，而开启这个则是强制用GPU进行2D图形图像处理从而降低CPU处理器的负担，这个主要是2D界面的图形也交给GPU处理从而更流畅点。</p>
<p>而HW叠加层，HW和叠加层应该分开理解，HW指的是硬件加速，而这个硬件指的是GPU处理器，而不是其它硬件或处理器硬件，至于为什么可以去参考一下硬解的相关资料，然后叠加层指的是使用CPU进行辅助运算，而不只是让GPU来进行全部的渲染工作，这个也是停用HW叠加层默认关闭的原因，汇总起来就是停用GPU上的CPU辅助计算，停用HW叠加层默认关闭就是说明HW叠加层默认是开启的，为什么会默认开启？这个就是因为就算开启了强制进行GPU渲染但并不是所有的图形处理交给了GPU，像游戏里面的一些画面、视频中的硬解（手机上不开启的话硬解是靠SQV的）就不是全部交给GPU的，而开启停用HW叠加层就是关闭HW叠加层，关闭HW叠加层就意味着图形处理任务就全部交给了GPU，这个主要是可以让游戏、视频之类一些原本不是GPU渲染的画面也强制使用GPU进行处理（像一些配置的视频显示不支持硬解，然后开启强制进行GPU渲染后就可以硬解了，因为强制使用GPU而不是手机上的另一个SQV硬解了，但因视频配置、屏幕刷新率之类的还是会有卡顿的情况，开启HW叠加层可以让部分高帧率的视频达到流畅的效果，但也受限于视频配置、屏幕刷新率等其它因素）。强制进行GPU渲染和停用HW叠加层不建议长时间开启，虽然开启这些可以让性能更好，但是也会损耗不少东西。</p>
<h1 id="Android的同步屏障消息是指什么"><a href="#Android的同步屏障消息是指什么" class="headerlink" title="Android的同步屏障消息是指什么"></a>Android的同步屏障消息是指什么</h1><p>Android 中的 Handler 用于在不同的线程之间传递消息和任务。一个常见的用例是在后台线程中执行耗时操作，然后将结果传递给主线程以更新用户界面。同步屏障消息是一种特殊的消息类型，可以用于控制消息处理的顺序。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当你向 Handler 发送同步屏障消息时，它会将该消息插入到消息队列中，并等待消息队列中的所有先前的消息都被处理完毕，然后再处理同步屏障消息。这可以用于确保某些操作在其他消息处理之前执行，从而实现同步。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>可以在主线程上使用同步屏障消息来确保在更新用户界面之前执行某些初始化操作。这样，你可以防止在初始化操作尚未完成之前更新界面，从而提高了代码的可靠性和一致性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Handler handler = new Handler();</span><br><span class="line"></span><br><span class="line">// 发送一个普通消息</span><br><span class="line">handler.post(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 这是一个普通消息</span><br><span class="line">        // 可能会执行在其他消息之前</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 发送一个同步屏障消息</span><br><span class="line">handler.postAtFrontOfQueue(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 这是一个同步屏障消息</span><br><span class="line">        // 会等待前面的消息都处理完才执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="同步屏障消息"><a href="#同步屏障消息" class="headerlink" title="同步屏障消息"></a>同步屏障消息</h1><p>系统一些高优先级的操作会使用到同步屏障消息</p>
<blockquote>
<p>Android 是禁止App往MessageQueue插入同步屏障消息的，代码会报错</p>
<blockquote>
<p>Looper.getMainLooper.postSyncBarrier</p>
</blockquote>
</blockquote>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>例如View在绘制的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt;ViewRootImpl</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    void scheduleTraversals() &#123;</span><br><span class="line">        if (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = true;</span><br><span class="line">            //插入同步屏障消息</span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">            if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unscheduleTraversals() &#123;</span><br><span class="line">        if (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = false;</span><br><span class="line">            //移除同步屏障消息</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">            mChoreographer.removeCallbacks(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为了保证View的绘制过程不被主线程其它任务影响，View在绘制之前会先往MessageQueue插入同步屏障消息，然后再注册Vsync信号监听，Choreographer$FrameDisplayEventReceiver就是用来接收vsync信号回调的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final class FrameDisplayEventReceiver extends DisplayEventReceiver</span><br><span class="line">        implements Runnable &#123;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public void onVsync(long timestampNanos, long physicalDisplayId, int frame) &#123;</span><br><span class="line">       ...</span><br><span class="line">        //</span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        Message msg = Message.obtain(mHandler, this);</span><br><span class="line">        //1、发送异步消息</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 2、doFrame优先执行</span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>收到Vsync信号回调，注释1会往主线程MessageQueue post一个异步消息，保证注释2的doFrame优先执行。<br>doFrame才是View真正开始绘制的地方，会调用ViewRootImpl的doTraversal、performTraversals，<br>而performTraversals里面会调用我们熟悉的View的onMeasure、onLayout、onDraw。<br>这里还可以延伸到vsync信号原理，以及为什么要等vsync信号回调才开始View的绘制流程、掉帧的原理、屏幕的双缓冲、三缓冲，由于文章篇幅关系，不是本文的重点，就不一一分析了~</p>
<blockquote>
<p>虽然app无法发送同步屏障消息，但是使用异步消息是允许的</p>
</blockquote>
<h1 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h1><p>首先，SDK中限制了App不能post异步消息到MessageQueue里去的，相关字段被加了UnsupportedAppUsage注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt; Message</span><br><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    /*package*/ int flags;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Returns true if the message is asynchronous, meaning that it is not</span><br><span class="line">     * subject to &#123;@link Looper&#125; synchronization barriers.</span><br><span class="line">     *</span><br><span class="line">     * @return True if the message is asynchronous.</span><br><span class="line">     *</span><br><span class="line">     * @see #setAsynchronous(boolean)</span><br><span class="line">     */</span><br><span class="line">    public boolean isAsynchronous() &#123;</span><br><span class="line">        return (flags &amp; FLAG_ASYNCHRONOUS) != 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>不过呢，高版本的Handler的构造方法可以通过传async=true，来使用异步消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Handler(@Nullable Callback callback, boolean async) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在Handler发送消息的时候，都会走到 enqueueMessage 方法，如下代码块所示，每个消息都带了异步属性，有优先处理权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,long uptimeMillis) &#123;</span><br><span class="line">    ...</span><br><span class="line">    //如果mAsynchronous为true，就都设置为异步消息</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于低版本SDK，想要使用异步消息，可以通过反射调用Handler(@Nullable Callback callback, boolean async)，参考androidx内部的一段代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt;androidx.arch.core.executor.DefaultTaskExecutor</span><br><span class="line"></span><br><span class="line">    private static Handler createAsync(@NonNull Looper looper) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 28) &#123;</span><br><span class="line">            return Handler.createAsync(looper);</span><br><span class="line">        &#125;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 16) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return Handler.class.getDeclaredConstructor(Looper.class, Handler.Callback.class,</span><br><span class="line">                        boolean.class)</span><br><span class="line">                        .newInstance(looper, null, true);</span><br><span class="line">            &#125; catch (IllegalAccessException ignored) &#123;</span><br><span class="line">            &#125; catch (InstantiationException ignored) &#123;</span><br><span class="line">            &#125; catch (NoSuchMethodException ignored) &#123;</span><br><span class="line">            &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">                return new Handler(looper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Handler(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/12/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>针对 Andorid 内核的管理， Google 定义了一个所谓 “AOSP 通用内核 ( AOSP common kernels，简称 ACKs)” 的概念。 ACKs 版本基于 Linux 内核 开发（术语上称之为 downstream，形象地说可以认为 Linux 内核 的发布处于上游，而 ACKs 随着 Linux 内核版本的升级而升级，就好像处在流水线的下游），ACKs 在 Linux 内核 的版本基础上包含了许多与 Android 社区相关但尚未合并到 LTS 的补丁程序，可以简单地分成以下几大类。</p>
]]></content>
  </entry>
  <entry>
    <title>Android-内存管理机制-1</title>
    <url>/2021/12/08/Android-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6-1/</url>
    <content><![CDATA[<h1 id="技术参考"><a href="#技术参考" class="headerlink" title="技术参考"></a>技术参考</h1><p><a href="https://developer.android.com/topic/performance/memory-overview?hl=zh-cn">google</a><br><a href="https://en.wikipedia.org/wiki/Memory_paging">分页</a><br><a href="https://en.wikipedia.org/wiki/Memory-mapped_file">内存映射</a>  </p>
<pre><code>作者：未子涵
链接：https://www.jianshu.com/p/2787a0661742
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h1 id="Android的内存管理机制"><a href="#Android的内存管理机制" class="headerlink" title="Android的内存管理机制"></a>Android的内存管理机制</h1><blockquote>
<p>Android使用 虚拟内存 和 分页，不支持交换 </p>
</blockquote>
<blockquote>
<p>Android 运行时 (ART) 和 Dalvik 虚拟机使用 分页 和 内存映射 来管理内存。这意味着应用修改的任何内存，无论修改的方式是分配新对象还是轻触内存映射的页面，都会一直驻留在 RAM 中，并且无法换出。要从应用中释放内存，只能释放应用保留的对象引用，使内存可供垃圾回收器回收。这种情况有一个例外：对于任何未经修改的内存映射文件（如代码），如果系统想要在其他位置使用其内存，可将其从 RAM 中换出。</p>
</blockquote>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>无论是 RT还是Dalvik虚拟机，都和众多Java虚拟机一样，属于一种托管内存环境（程序员不需要显示的管理内存的分配与回收，交由系统自动管理）。托管内存环境会跟踪每个内存分配， 一旦确定程序不再使用一块内存，它就会将其释放回堆中，而无需程序员的任何干预。 回收托管内存环境中未使用内存的机制称为垃圾回收。</p>
<p>—垃圾收集有两个目标：</p>
<p>*在程序中查找将来无法访问的数据对象;<br>*回收这些对象使用的资源。</p>
<blockquote>
<p>Android的垃圾收集器不带压缩整理功能（Compact），即不会对Heap做碎片整理  </p>
</blockquote>
<p>Android的内存堆是<strong>分代式（Generational</strong>的，意味着它会将所有分配的对象进行分代，然后分代跟踪这些对象。 例如，最近分配的对象属于<strong>年轻代（Young Generation）</strong>。 当一个对象长时间保持活动状态时，它可以被提升为<strong>年老代（Older Generation）</strong>，之后还能进一步提升为<strong>永久代（Permanent Generation）</strong>。</p>
<p>每一代的对象可占用的内存总量都有其专用上限。 每当一代开始填满时，系统就会执行垃圾收集事件以试图释放内存。 垃圾收集的持续时间取决于它在收集哪一代的对象以及每一代中有多少活动对象。</p>
<p><img src="Android%E5%88%86%E4%BB%A3%E5%BC%8F.jpg" alt="Android分代式"></p>
<p>虽然垃圾收集速度非常快，但它仍然会影响应用程序的性能。通常情况下你不需要控制代码中何时执行垃圾收集事件。 系统有一组用于确定何时执行垃圾收集的标准。 满足条件后，系统将停止执行当前进程并开始垃圾回收。 如果在像动画或音乐播放这样的密集处理循环中发生垃圾收集，则会增加处理时间。 这种增加可能会导致你的应用程序中的代码执行超过建议的16ms阈值。</p>
<p>为实现高效，流畅的帧渲染，Android建议绘制一帧的时间不要超过16ms。</p>
<p>此外，你的代码可能会执行各种工作，这些工作会导致垃圾收集事件更频繁地发生，或使其持续时间超过正常范围。 例如，如果在Alpha混合动画的每个帧期间在for循环的最内部分配多个对象，则大量的对象就会污染内存堆。 此时，垃圾收集器会执行多个垃圾收集事件，并可能降低应用程序的性能</p>
<hr>
<h1 id="Android进程模式"><a href="#Android进程模式" class="headerlink" title="Android进程模式"></a>Android进程模式</h1><p>了解Android生命周期之前，需要理解Android进程模式。</p>
<p>由于 Android 平台资源有限，需为不同进程设置优先级，以便系统资源紧张时，通过 “杀死优先级较低进程” 释放资源。所以进程模式的存在主要是为了“标记和区分” 进程优先级。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>App 进程级别，由其 “活跃的或处于栈顶的组件” 的状态（比如所处生命周期）决定。<br>按优先级从高到低，进程模式主要包含：</p>
<p>前景进程(onResume)、可见进程、服务进程、背景进程、空白进程 这 5 大类别。</p>
<blockquote>
<p>!!!系统回收资源时，针对的是 App 的进程。<br>前景进程和可见进程2者主要的区别在于有没有获得焦点。</p>
</blockquote>
<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>Android可以跨进程共享RAM页面（Pages）</p>
<p>为了在 RAM 中容纳所需的一切，Android 会尝试跨进程共享 RAM 页面。它可以通过以下方式实现这一点：</p>
<p><img src="RAM.jpg" alt="Android-Ram"></p>
<p>每个应用进程都从一个名为 Zygote 的现有进程分叉。系统启动并加载通用框架代码和资源（如 Activity 主题背景）时，Zygote 进程随之启动。为启动新的应用进程，系统会分叉 Zygote 进程，然后在新进程中加载并运行应用代码。这种方法使为框架代码和资源分配的大多数 RAM 页面可在所有应用进程之间共享。</p>
<p>大多数静态数据会内存映射到一个进程中。这种方法使得数据不仅可以在进程之间共享，还可以在需要时换出。静态数据示例包括：Dalvik 代码（通过将其放入预先链接的 .odex 文件中进行直接内存映射）、应用资源（通过将资源表格设计为可内存映射的结构以及通过对齐 APK 的 zip 条目）和传统项目元素（如 .so 文件中的原生代码）。<br>在很多地方，Android 使用明确分配的共享内存区域（通过 ashmem 或 gralloc）在进程间共享同一动态 RAM。例如，窗口 surface 使用在应用和屏幕合成器之间共享的内存，而光标缓冲区则使用在内容提供器和客户端之间共享的内存。</p>
<h1 id="限制应用的内存"><a href="#限制应用的内存" class="headerlink" title="限制应用的内存"></a>限制应用的内存</h1><p>为了维护高效的多任务环境，Android为每个应用程序设置了堆大小的硬性限制。 该限制因设备而异，取决于设备总体可用的RAM。 如果应用程序已达到该限制并尝试分配更多内存，则会收到 OutOfMemoryError 。</p>
<blockquote>
<p>这里Google文档所说的堆指的是Java虚拟机堆，而我们游戏分配的内存比较多的是在native层面，需要区分清楚。</p>
</blockquote>
<p>在某些情况下，你可能希望查询系统以准确确定当前设备上可用的堆空间大小，例如，确定可以安全地保留在缓存中的数据量。 你可以通过调用 getMemoryClass() 来查询系统中的这个数字。 此方法返回一个整数，指示应用程序堆可用的兆字节数。</p>
<h1 id="切换应用"><a href="#切换应用" class="headerlink" title="切换应用"></a>切换应用</h1><p>当用户在应用程序之间切换时，Android会将非前台应用程序（即用户不可见或并没有运行诸如音乐播放等前台服务的进程）缓存到一个最近最少使用缓存（LRU Cache）中。例如，当用户首次启动应用程序时，会为其创建一个进程; 但是当用户离开应用程序时，该进程不会退出。 系统会缓存该进程。 如果用户稍后返回应用程序，系统将重新使用该进程，从而使应用程序切换更快。</p>
<p>如果你的应用程序具有缓存进程并且它保留了当前不需要的内存，那么即使用户未使用它，你的应用程序也会影响系统的整体性能。 当系统内存不足时，就会从最近最少使用的进程开始，终止LRU Cache中的进程。另外，系统还会综合考虑保留了最多内存的进程，并可能终止它们以释放RAM。</p>
<p>当系统开始终止LRU Cache中的进程时，它主要是自下而上的。 系统还会考虑哪些进程占用更多内存，因为在它被杀时会为系统提供更多内存增益。 因此在整个LRU列表中消耗的内存越少，保留在列表中并且能够快速恢复的机会就越大。</p>
<h1 id="Android-对-Linux系统-的内存管理机制进行的优化"><a href="#Android-对-Linux系统-的内存管理机制进行的优化" class="headerlink" title="Android 对 Linux系统 的内存管理机制进行的优化"></a>Android 对 Linux系统 的内存管理机制进行的优化</h1><p>Android对内存的使用方式同样是“尽最大限度的使用”，这一点继承了Linux的优点。只不过有所不同的是，Linux侧重于尽可能多的缓存磁盘数据以降低磁盘IO进而提高系统的数据访问性能，而Android侧重于尽可能多的缓存进程以提高应用启动和切换速度。Linux系统在进程活动停止后就结束该进程，而Android系统则会在内存中尽量长时间的保持应用进程，直到系统需要更多内存为止。这些保留在内存中的进程，通常情况下不会影响系统整体运行速度，反而会在用户再次激活这些进程时，加快进程的启动速度，因为不用重新加载界面资源了，这是Android标榜的特性之一。所以，Android现在不推荐显式的“退出”应用。</p>
<p>那为什么内存少的时候运行大型程序会慢呢，原因是：在内存剩余不多时打开大型程序会触发系统自身的进程调度策略，这是十分消耗系统资源的操作，特别是在一个程序频繁向系统申请内存的时候。这种情况下系统并不会关闭所有打开的进程，而是选择性关闭，频繁的调度自然会拖慢系统。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Code-心得记录</title>
    <url>/2021/12/08/Code-%E5%BF%83%E5%BE%97%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="思考心得"><a href="#思考心得" class="headerlink" title="思考心得"></a>思考心得</h1><p>💻 程序是如何执行的?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入 ==&gt; 输出</span><br><span class="line"></span><br><span class="line">编程</span><br><span class="line">编写 =&gt; 编译 =&gt; 可执行文件 =&gt; 加载 =&gt; 回收</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">操作系统</span><br><span class="line">Cpu</span><br><span class="line">HHD</span><br></pre></td></tr></table></figure>

<h1 id="如何思考"><a href="#如何思考" class="headerlink" title="如何思考"></a>如何思考</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任何技术都绝非凭空产生,一项技术的存在，必然是为了在特定场景下，成为解决特定问题时的不可替代。 —— ©KunMinX</span><br><span class="line">是深度思考的 main 方法。</span><br><span class="line"></span><br><span class="line">abstract 1：宇宙中，任何现象绝非凭空存在，一个现象的存在，必然是出于某种目的。×（暂时无法证明 100% 成立，因为自然界除了规律就是概率，后者是独立事件，并非总是存在特定的因果关系）</span><br><span class="line"></span><br><span class="line">abstract 2：人类社会中，任何一个人造物绝非凭空存在，一个人造物的存在，必然是为了解决某种需求。√（可以 100% 确证，无法推翻，因而，当我们去追溯人造物 存在的背景 </span><br><span class="line"></span><br><span class="line">—— 它的存在主要是 为了解决什么需求 时，我们便 基本能够确知 该事物的本质：我们 用 80% 的时间去抓住作为精华的那 20%，是谓 对此事物有了深入的理解、从而有观点可负责。）</span><br><span class="line"></span><br><span class="line">abstract 3：工具是人造物的子类，工具是一种人造物，所以工具仍然满足上述推论，即 确立了背景认知，即有机会确立对该事物本质的认识。</span><br><span class="line"></span><br><span class="line">abstract 4：技术是一种工具，从而技术也是一种人造物，所以技术仍然满足上述推论、适合以 abstract 3 认识工具的方式来思考技术。</span><br><span class="line"></span><br><span class="line">—— ©KunMinX </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>综上<br>真正的 问题 多数时候 并不在于外界，不在于拥有了多少资源，而在于 认知的版图：</p>
</blockquote>
<blockquote>
<p>对事物的认知有多深，能驾驭的事物也就有多少；</p>
</blockquote>
<blockquote>
<p>所认知的领域有多大，能介入的领域也就有多广。</p>
</blockquote>
<blockquote>
<p>二鸟在林，不如一鸟在手。四处搜刮和囤积的表面信息再多 也无济于事；唯有对一件事情有了深入的理解，才能印象深刻 乃至 真正成为自己的 —— 是随时随地可受用的知识。</p>
</blockquote>
<blockquote>
<p>所以，越是后知后觉，就越是需要 认清现状、踏踏实实、没有商量余地地将 “绝不可绕过的基础现象” 给想明白、给确立下来，</p>
</blockquote>
<blockquote>
<p>唯有这样，未来才 真真实实地 有资本、有方向地 能在 “世界” 这个市场中博弈。</p>
</blockquote>
<hr>
<h1 id="视频观看"><a href="#视频观看" class="headerlink" title="视频观看"></a>视频观看</h1><p>Google发布会，包括Google相关的资料也可以学习。<br>可以先看Google相关的视频资料，再根据这些视频资料，去阅读源码。</p>
<h1 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h1><p>分析源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.首先猜想源码的功能</span><br><span class="line">2.再根据功能去找对应的代码</span><br><span class="line">3.对整体进行有效的逻辑分析</span><br><span class="line"></span><br><span class="line">如果是我来做这块功能的模块，我应该怎么设计.</span><br><span class="line">1.需要多少步骤。(需要哪些步骤，能不能简化,还有关联性)</span><br><span class="line">2.考虑使用的场景。</span><br><span class="line">3.考虑用户的体验。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 编写 ==&gt; 目的 </span><br><span class="line">编译 ==&gt; </span><br><span class="line">运行时 ==&gt;</span><br><span class="line">如何加载 ==&gt; </span><br><span class="line">如何回收 ==&gt;  --&gt;</span><br><span class="line">---</span><br><span class="line"># 投资心得</span><br></pre></td></tr></table></figure>

<p>```</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>操作系统在读取可执行程序头时做了三件事：<br>1.创建虚拟内存空间来容纳一个进程</p>
<p>2.根据文件头内容建立程序虚拟内存地址与elf文件的映射关系表，vma（virtual memory area）结构</p>
<p>3.初始化程序的栈空间与堆空间    </p>
]]></content>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-内存篇</title>
    <url>/2021/12/07/Linux-%E5%86%85%E5%AD%98%E7%AF%87/</url>
    <content><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NzYzODg1OA==&mid=2648464745&idx=1&sn=374b770823d0a9e9677386160e57f71c&chksm=876600ccb01189dac48a843f71d39521c5bbc6cb6afb113e9d90ef7211c22d579a23c20cd8c5&scene=21#wechat_redirect">漫画解说 “内存映射”</a></p>
<p><a href="https://javaguide.cn/cs-basics/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98&%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/#">操作系统常见面试题总结</a></p>
<hr>
<h1 id="内存是什么-—-RAM-Definition"><a href="#内存是什么-—-RAM-Definition" class="headerlink" title="内存是什么 — RAM Definition"></a>内存是什么 — RAM Definition</h1><blockquote>
<p>Memory,as it’s used with regard to computer, most commonly refers to semicondutor devices whose contents can be accessed(i.e., read and written to) at extremely high speeds but which are retained only temporarily(i.e.,which in use or,at most,while the power supply remains on).<br>内存，因为它被用于计算机，最常指的是<strong>半导体的设备</strong>，其内容可以用极高速度访问(即读取和写入)，但只能暂时保留。</p>
</blockquote>
<p>运行内存又可划分为虚拟内存和物理内存</p>
<h2 id="Virtual-memory-Definition-虚拟内存"><a href="#Virtual-memory-Definition-虚拟内存" class="headerlink" title="Virtual memory Definition (虚拟内存)"></a>Virtual memory Definition (虚拟内存)</h2><blockquote>
<p>Virtual memory is the use of space on a hard disk (HDD) is simulate additional main memory<br>译：虚拟内存是使用硬盘 (HDD) 上的空间来模拟额外的主内存 </p>
</blockquote>
<h3 id="虚拟内存的意义"><a href="#虚拟内存的意义" class="headerlink" title="虚拟内存的意义"></a>虚拟内存的意义</h3><p>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p>
<p>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间</p>
<blockquote>
<p>虚拟内存 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">https://zh.wikipedia.org/wiki/虚拟内存</a>  (opens new window)</p>
</blockquote>
<h2 id="主内存—物理内存"><a href="#主内存—物理内存" class="headerlink" title="主内存—物理内存"></a>主内存—物理内存</h2><p>通俗易懂就是你现在电脑或者手机配置，在系统属性上写着RAM 8G就是你的物理内存的大小</p>
<h2 id="Other-Types-of-Memory-其他内存的模型"><a href="#Other-Types-of-Memory-其他内存的模型" class="headerlink" title="Other Types of Memory (其他内存的模型)"></a>Other Types of Memory (其他内存的模型)</h2><blockquote>
<p>The most basic of them is read-only memory(ROM),whose contents are written in at the factory and thereafter cannot be erased or rewritten.</p>
</blockquote>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>局部性原理既适用于程序结构，也适用于数据结构</p>
<h3 id="局部性原理表现在以下两个方面："><a href="#局部性原理表现在以下两个方面：" class="headerlink" title="局部性原理表现在以下两个方面："></a>局部性原理表现在以下两个方面：</h3><p>时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。<br>空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。<br>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。<br>空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存  </p>
<pre><code>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟存储器。 实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。
</code></pre>
<hr>
<h1 id="内存管理的基础"><a href="#内存管理的基础" class="headerlink" title="内存管理的基础"></a>内存管理的基础</h1><h1 id="CPU知识扩展"><a href="#CPU知识扩展" class="headerlink" title="CPU知识扩展"></a>CPU知识扩展</h1><p><a href="https://zhupengbo.com/2021/08/04/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#CPU">CPU</a></p>
<p>CPU只能访问其寄存器（Register）和内存（Memory）， 无法直接访问硬盘（Disk）。 存储在硬盘上的数据必须首先传输到内存中才能被CPU访问。从访问速度来看，对寄存器的访问非常快，通常为1纳秒； 对内存的访问相对较慢，通常为100纳秒（使用缓存加速的情况下；而对硬盘驱动器的访问速度最慢，通常为10毫秒。</p>
<h1 id="Linux主要的内存管理技术"><a href="#Linux主要的内存管理技术" class="headerlink" title="Linux主要的内存管理技术"></a>Linux主要的内存管理技术</h1><pre><code>Base and limit registers（基址寄存器和界限寄存器）
Virtual memory（虚拟内存）
Swapping（交换）
Segmentation（分段）
Paging（分页)
</code></pre>
<h2 id="Base-and-limit-registers（基址寄存器和界限寄存器）"><a href="#Base-and-limit-registers（基址寄存器和界限寄存器）" class="headerlink" title="Base and limit registers（基址寄存器和界限寄存器）"></a>Base and limit registers（基址寄存器和界限寄存器）</h2><p>必须限制进程，以便它们只能访问属于该特定进程的内存位置。</p>
<p>每个进程都有一个基址寄存器和限制寄存器：</p>
<p>基址寄存器保存最小的有效存储器地址<br>限制寄存器指定范围的大小</p>
<h1 id="Paging（分页"><a href="#Paging（分页" class="headerlink" title="Paging（分页)"></a>Paging（分页)</h1><p>有时可用内存被分成许多小块，其中没有一块足够大以满足下一个内存需求，然而他们的总和却可以。这个问题被称为碎片（Fragmentation），许多内存分配策略都会受其影响。</p>
<p>分页将物理内存划分为多个大小相等的块，称为帧（Frame）。</p>
<p>并将进程的逻辑内存空间也划分为大小相等的块，称为页面（Page）。</p>
<p>任何进程中的任何页面都可以放入任何可用的帧中。</p>
<p>页表（Page Table）用于查找此刻存储特定页面的帧。</p>
<p><img src="Paging.jpg" alt="Linux-Paging">  </p>
<p>使用分页时，虚拟内存地址是一对：&lt;页码，偏移量&gt;</p>
<p>页码（Page Number）：用作页表的索引，以查找此页面的条目<br>偏移量（Offset）：与基址相结合，以定义物理内存地址</p>
<p><img src="use-paging.png" alt="Linux-Paging">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举一个分页地址转换的例子：</span><br><span class="line"></span><br><span class="line">虚拟内存地址为0x13325328，页表项0x13325包含的值是0x03004，那么物理地址是什么？</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line">物理地址是0x03004328</span><br><span class="line">页码为0x13325，偏移量为0x328</span><br><span class="line">相应的帧号是0x03004</span><br><span class="line"></span><br><span class="line">作者：未子涵</span><br><span class="line">链接：https://www.jianshu.com/p/2787a0661742</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Linux十万个为什么"><a href="#Linux十万个为什么" class="headerlink" title="Linux十万个为什么"></a>Linux十万个为什么</h1><h1 id="虚拟内存为什么会设计出来"><a href="#虚拟内存为什么会设计出来" class="headerlink" title="虚拟内存为什么会设计出来"></a>虚拟内存为什么会设计出来</h1><p>在早期的计算机中，程序是直接运行在物理内存上的，那个时候的计算机和程序内存都很小。程序运行时会把其全部加载到内存，只要程序所需的内存不超过计算机剩余内存就不会出现问题。</p>
<p>但由于程序是可以直接访问物理内存的，这也带来了内存数据的不安全性，轻则程序挂掉，重则操作系统崩溃。</p>
<p>所以，我们希望程序间的内存数据是安全的互不影响的。同时计算机程序直接运行在物理内存上也导致了内存使用率较低，程序运行内存地址不确定，不同的运行顺序甚至会出错。此时在程序的执行过程中，已经存在着大量在物理内存和硬盘之间的数据交换过程。</p>
<p>基于以上问题，那我们可以是不是考虑在物理内存之上增加一个中间层，让程序通过虚拟地址去间接的访问物理内存呢。通过虚拟内存，每个进程好像都可以独占内存一样，每个进程看到的内存都是一致的，这称为虚拟地址空间。</p>
<p>（这种思想在现在也用的很广泛，例如很多优秀的中间层：Nginx、Redis 等等）</p>
<p>这样只要系统处理好虚拟地址到物理地址的映射关系，就可以保证不同的程序访问不同的内存区域，就可以达到物理内存地址隔离的效果，进而保证数据的安全性</p>
<h1 id="内存映射是什么"><a href="#内存映射是什么" class="headerlink" title="内存映射是什么"></a>内存映射是什么</h1><p>关于内存映射，首先要明白什么是<strong>虚拟内存</strong>和<strong>物理内存</strong> 。<br>虚拟内存与物理内存的映射关系是通过 <strong>页表</strong>。<br>页表通过内存页进行映射</p>
<h1 id="页表是什么"><a href="#页表是什么" class="headerlink" title="页表是什么"></a>页表是什么</h1><blockquote>
<p>但 页表 并不是按字节来进行映射的，而是按照 内存页 为单位进行映射，一般一个 内存页 的大小为 4KB（为什么要加一般呢，这是因为除了4KB，还有其他大小的内存页，如2MB，4MB，1GB等），页表 的每一个 页表项 都保存着物理内存页的地址。</p>
</blockquote>
<blockquote>
<p> 所以，4GB 的虚拟内存空间需要 1MB 大小的页表来关联（因为 4GB / 4KB = 1MB）。也就是说，0 ~ 4095 的虚拟内存地址都是使用 页表 的第一个 页表项 来映射的，而 4096 ~ 8191 的虚拟内存地址使用 页表 的第二个 页表项 来映射的，以此类推..</p>
</blockquote>
<h1 id="cr3是什么"><a href="#cr3是什么" class="headerlink" title="cr3是什么"></a>cr3是什么</h1><p>cr3 是 CPU 中的一个寄存器，用于保存 <strong>页表</strong> 的物理内存地址，通过这个寄存器就能找到进程的 <strong>页表</strong> 了</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发资源汇总</title>
    <url>/2021/11/29/Android%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="颜色透明度汇总"><a href="#颜色透明度汇总" class="headerlink" title="颜色透明度汇总"></a>颜色透明度汇总</h1><p>半透明颜色值不同于平时使用的颜色，半透明颜色值共 8 位，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android:background=&quot;#AAxxxxxx&quot;</span><br></pre></td></tr></table></figure>
<p>前 2 位(AA)是透明度，后 6 位(xxxxxx) 是颜色，透明度和颜色结合在一起就可以写出各种颜色的透明度。下面是透明度说明表。</p>
<table>
<thead>
<tr>
<th align="left">透明度百分比</th>
<th align="center">对应的值</th>
<th align="left">备注</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100%</td>
<td align="center">FF</td>
<td align="left">完全不透明</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">95%</td>
<td align="center">F2</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">90%</td>
<td align="center">E6</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">85%</td>
<td align="center">D9</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">80%</td>
<td align="center">CC</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">75%</td>
<td align="center">BF</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">70%</td>
<td align="center">B3</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">65%</td>
<td align="center">A6</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">60%</td>
<td align="center">99</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">55%</td>
<td align="center">8C</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">50%</td>
<td align="center">80</td>
<td align="left">半透明 50%</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">45%</td>
<td align="center">73</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">40%</td>
<td align="center">40</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">35%</td>
<td align="center">59</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">30%</td>
<td align="center">4D</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">25%</td>
<td align="center">40</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">20%</td>
<td align="center">33</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">15%</td>
<td align="center">26</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">10%</td>
<td align="center">1A</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5%</td>
<td align="center">0D</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">0%</td>
<td align="center">00</td>
<td align="left">全透明</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>使用举例：</p>
<p>全透明：#00000000<br>半透明：#80000000<br>不透明：#FF000000<br>白色半透明：#80FFFFFF<br>不同像素密度的配置限定符<br>官方链接：<a href="https://developer.android.com/training/multiscreen/screendensities?hl=zh-cn">https://developer.android.com/training/multiscreen/screendensities?hl=zh-cn</a></p>
<p>密度限定符    说明<br>ldpi    适用于低密度 (ldpi) 屏幕 (~ 120dpi) 的资源<br>mdpi    适用于中密度 (mdpi) 屏幕 (~ 160dpi) 的资源（这是基准密度）<br>hdpi    适用于高密度 (hdpi) 屏幕 (~ 240dpi) 的资源<br>xhdpi    适用于加高 (xhdpi) 密度屏幕 (~ 320dpi) 的资源<br>xxhdpi    适用于超超高密度 (xxhdpi) 屏幕 (~ 480dpi) 的资源<br>xxxhdpi    适用于超超超高密度 (xxxhdpi) 屏幕 (~ 640dpi) 的资源<br>nodpi    适用于所有密度的资源。这些是与密度无关的资源。无论当前屏幕的密度是多少，系统都不会缩放以此限定符标记的资源<br>tvdpi    适用于密度介于 mdpi 和 hdpi 之间的屏幕（约 213dpi）的资源。这不属于“主要”密度组。它主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将视情况对其进行缩放。如果您发现有必要提供 tvdpi 资源，应按一个系数来确定其大小，即 1.33*mdpi。例如，如果某张图片在 mdpi 屏幕上的大小为 100px x 100px，那么它在 tvdpi 屏幕上的大小应该为 133px x 133px<br>要针对不同的密度创建备用可绘制位图资源，您应遵循六种主要密度之间的 3:4:6:8:12:16 缩放比。例如，如果您有一个可绘制位图资源，它在中密度屏幕上的大小为 48x48 像素，那么它在其他各种密度的屏幕上的大小应该为：</p>
<p>36x36 (0.75x) - 低密度 (ldpi)<br>48x48（1.0x 基准）- 中密度 (mdpi)<br>72x72 (1.5x) - 高密度 (hdpi)<br>96x96 (2.0x) - 超高密度 (xhdpi)<br>144x144 (3.0x) - 超超高密度 (xxhdpi)<br>192x192 (4.0x) - 超超超高密度 (xxxhdpi)<br>Android studio 插件版本与 gradle 版本对应关系<br>Android studio 插件版本与 gradle 版本对应关系如下所示：</p>
<p>AS 插件版本    Gradle 版本<br>1.0.0 - 1.1.3    2.2.1 - 2.3<br>1.2.0 - 1.3.1    2.2.1 - 2.9<br>1.5.0    2.2.1 - 2.13<br>2.0.0 - 2.1.2    2.10 - 2.13<br>2.1.3 - 2.2.3    2.14.1+<br>2.3.0+    3.3+<br>3.0.0+    4.1+<br>3.1.0+    4.4+<br>3.2.0 - 3.2.1    4.6+<br>3.3.0 - 3.3.3    4.10.1+<br>3.4.0 - 3.4.3    5.1.1+<br>3.5.0 - 3.5.4    5.4.1+<br>3.6.0 - 3.6.4    5.6.4+<br>4.0.0+    6.1.1+<br>4.1.0+    6.5+<br>以上信息参考 Android Gradle 插件版本说明</p>
<p>Android Studio 根据动物名称来命名，而 Android 系统 10.0 之前都是以甜点的方式来命名，我们在来会汇总一下 Android 系统的命名方案。</p>
<p>2007 年 11 月 5 日发布最初的版本（Android 0.5），至今 Android 发行了多个版本，Android 操作系统有预发行的内部版本，分别为铁臂阿童木（Astro）与机器人班亭（Bender），从 2009 年 5 月开始， Android 的版本代号以甜点来命名，且每个代号间的前缀以英文本母序接续排列。</p>
<p>Android 系统名字、版本、API level 的对应关系<br>Android 系统名字、版本、API level 的对应关系如下所示：</p>
<p>名称    版本号    发版日期    API    API<br>Android 1.0    1.0    2008年9月23日    1    BASE<br>Android 1.1    1.1    2009年2月9日    2    BASE_1_1<br>Android Cupcake（纸杯蛋糕）    1.5    2009年4月27日    3    CUPCAKE<br>Android Donut（甜甜圈）    1.6    2009年9月15日    4    DONUT<br>Android Eclair（闪电泡芙）    2.0 – 2.1    2009年10月26日    5 – 7    ECLAIR_MR1（2.1.x）<br>ECLAIR_0_1（2.0.1）<br>ECLAIR（2.0）<br>Android Froyo（优格冰淇淋）    2.2 – 2.2.3    2010年5月20日    8    FROYO<br>Android Gingerbread（姜饼）    2.3 – 2.3.7    2010年12月6日    9 - 10    GINGERBREAD_MR1（ 2.3.3 - 2.3.4）<br>GINGERBREAD（2.3、2.3.1、2.3.2）<br>Android Honeycomb（蜂巢）    3.0 – 3.2.6    2011年2月22日    11 - 13    HONEYCOMB_MR2（3.2）<br>HONEYCOMB_MR1（3.1x）<br>HONEYCOMB（3.0.x）<br>Android Ice Cream Sandwich（冰淇淋三明治）    4.0 – 4.0.4    2011年10月18日    14 - 15    ICE_CREAM_SANDWICH_MR1（4.0.3、4.0.4）<br>ICE_CREAM_SANDWICH （4.0、4.0.1、4.0.2）<br>Android Jelly Bean（果冻豆）    4.1 – 4.3.1    2012年7月9日    16 – 18    JELLY_BEAN_MR2（4.3）<br>JELLY_BEAN_MR1（4.2 - 4.2.2）<br>JELLY_BEAN（4.1 - 4.1.1）<br>Android KitKat（奇巧巧克力）    4.4 – 4.4.4    2013年10月31日    19 - 20    KITKAT<br>Android Lollipop（棒棒糖）    5.0 – 5.1.1    2014年11月12日    21 - 22    LOLLIPOP_MR1（5.1）<br>LOLLIPOP（5.0）<br>Android Marshmallow（棉花糖）    6.0 – 6.0.1    2015年10月5日    23    M<br>Android Nougat（牛轧糖）    7.0 – 7.1.2    2016年8月22日    24 - 25    N_MR1（7.1 - 7.11） N（7.0）<br>Android Oreo（奥利奥）    8.0 – 8.1    2017年8月21日    26 – 27    O_MR1（8.1） O （8.0）<br>Android Pie（派）    9    2018年8月6日    28    P<br>Android 10    10    2019年9月3日    29    Q<br>Android 11    11    2020年2月19日    30    R<br>从 Android Q 开始不再以甜品命名，且直接称 Android Q 为 Android 10。以上信息参考 uses-sdk</p>
<p>跳转到系统各个设置界面<br>跳转常用方法如下：</p>
<p>// 第一个参：包名<br>// 第二个参数：各个设置的类名(可以参考下面)<br>ComponentName cm = new ComponentName(“com.android.settings”,<br>            “com.android.settings.RadioInfo”);<br>    intent.setComponent(cm);<br>    intent.setAction(“android.intent.action.VIEW”);<br>    startActivity(intent);<br>各个设置的类名汇总</p>
<p>com.android.settings.AccessibilitySettings 辅助功能设置<br>com.android.settings.ActivityPicker 选择活动<br>com.android.settings.ApnSettings APN设置<br>com.android.settings.ApplicationSettings 应用程序设置<br>com.android.settings.BandMode 设置GSM/UMTS波段<br>com.android.settings.BatteryInfo 电池信息<br>com.android.settings.DateTimeSettings 日期和坝上旅游网时间设置<br>com.android.settings.DateTimeSettingsSetupWizard 日期和时间设置<br>com.android.settings.DevelopmentSettings 应用程序设置=》开发设置<br>com.android.settings.DeviceAdminSettings 设备管理器<br>com.android.settings.DeviceInfoSettings 关于手机<br>com.android.settings.Display 显示——设置显示字体大小及预览<br>com.android.settings.DisplaySettings 显示设置<br>com.android.settings.DockSettings 底座设置<br>com.android.settings.IccLockSettings SIM卡锁定设置<br>com.android.settings.InstalledAppDetails 语言和键盘设置<br>com.android.settings.LanguageSettings 语言和键盘设置<br>com.android.settings.LocalePicker 选择手机语言<br>com.android.settings.LocalePickerInSetupWizard 选择手机语言<br>com.android.settings.ManageApplications 已下载（安装）软件列表<br>com.android.settings.MasterClear 恢复出厂设置<br>com.android.settings.MediaFormat 格式化手机闪存<br>com.android.settings.PhysicalKeyboardSettings 设置键盘<br>com.android.settings.PrivacySettings 隐私设置<br>com.android.settings.ProxySelector 代理设置<br>com.android.settings.RadioInfo 手机信息<br>com.android.settings.RunningServices 正在运行的程序（服务）<br>com.android.settings.SecuritySettings 位置和安全设置<br>com.android.settings.Settings 系统设置<br>com.android.settings.SettingsSafetyLegalActivity 安全信息<br>com.android.settings.SoundSettings 声音设置<br>com.android.settings.TestingSettings 测试——显示手机信息、电池信息、使用情况统计、Wifi information、服务信息<br>com.android.settings.TetherSettings 绑定与便携式热点<br>com.android.settings.TextToSpeechSettings 文字转语音设置<br>com.android.settings.UsageStats 使用情况统计<br>com.android.settings.UserDictionarySettings 用户词典<br>com.android.settings.VoiceInputOutputSettings 语音输入与输出设置<br>com.android.settings.WirelessSettings 无线和网络设置<br>Android 设备信息以及系统 API<br>Build 系列</p>
<p>Build 系列    android.os.Build<br>系统版本    RELEASE    获取系统版本字符串。如4.1.2 或2.2 或2.3等    4.4.4<br>系统版本值    SDK_INT        19<br>品牌    BRAND    获取设备品牌    Huawei<br>型号    MODEL    获取手机的型号    HUAWEI G750-T01<br>ID    ID    设备版本号    HUAWEITAG-TLOO<br>DISPLAY    DISPLAY    获取设备显示的版本包（在系统设置中显示为版本号）和ID一样    TAG-TLOOCO1B166-TLOO<br>产品名    PRODUCT    整个产品的名称    G750-T01<br>制造商    MANUFACTURER    获取设备制造商    HUAWEI<br>设备名    DEVICE    获取设备驱动名称    hwG750-T01<br>硬件    HARDWARE    设备硬件名称,一般和基板名称一样（BOARD）    mt6592<br>指纹    FINGERPRINT    设备的唯一标识。由设备的多个信息拼接合成    Huawei/G750-T01/hwG750-T01:4.2.2/HuaweiG750-T01/C00B152:user/ota-rel-keys,release-keys<br>串口序列号    SERIAL    返回串口序列号    YGKBBBB5C1711949<br>设备版本类型    TYPE    主要为user 或eng.    user<br>描述build的标签    TAGS    设备标签。如release-keys 或测试的 test-keys    release-keys<br>设备主机地址    HOST    设备主机地址    scmbuild<br>设备用户名    USER    基本上都为android-build    queen<br>固件开发版本代号    codename    设备当前的系统开发代号，一般使用REL代替    REL<br>源码控制版本号    build_incremental    系统源代码控制值，一个数字或者git hash值    C01B166<br>主板    board    获取设备基板名称    TAG-TL00<br>主板引导程序    bootloader    获取设备引导程序版本号    unkonwn<br>Build时间    time    Build时间    1476084456000<br>系统的API级别    SDK_INT    数字表示    19<br>cpu指令集1    CPU_ABI    获取设备指令集名称（CPU的类型）    arm64-v8a<br>cpu指令集1    CPU_ABI2<br>Android 硬件设备信息：</p>
<p>名称    接口参数名称    备注    示例<br>序列号    getDeviceId    序列号IMEI    865872025238821<br>andrlid_id    getString    android_id    bcbc00f09479aa5b<br>手机号码    getLine1Number    手机号码    13117511178<br>手机卡序列号    getSimSerialNumber    手机卡序列号    89860179328595969501<br>手机卡IMSI号    getSubscriberId    IMSI    460017932859596<br>手机卡国家    getSimCountryIso    手机卡国家    cn<br>运营商    getSimOperator    运营商    46001<br>运营商名字    getSimOperatorName    运营商名字    中国联通<br>国家iso代码    getNetworkCountryIso    国家iso代码字    cn<br>网络运营商类型    getNetworkOperator    返回MCC+MNC代码    (SIM卡运营商国家代码和运营商网络代码)(IMSI) 46001<br>网络类型名    getNetworkOperatorName    返回移动网络运营商的名字(SPN)    中国联通<br>网络    getNetworkType    网络    3<br>手机类型    getPhoneType    机类型    1<br>手机卡状态    getSimState        1<br>mac地址    getMacAddress    mac地址    a8:a6:68:a3:d9:ef<br>蓝牙名称    getName        HUAWEI TAG-TL00<br>固件版本    固件版本    无线电固件版本号，通常是不可用的    MOLY.WR8.W1328.MD.TG.MP.V1.P22, 2014/07/15 19:57<br>WifiManager</p>
<p>WifiManager    WIFI相关<br>蓝牙地址    getAddress    蓝牙地址MAC地址    6a: cd:57:f2:3b:59<br>无线路由器名    getSSID    WIFI名字    210e03fcf0<br>无线路由器地址    getBSSID        ce:ea:8c:1a:5c:b2<br>内网ip(wifl可用)    getIpAddress    可以用代码转成192.168形式    -2023511872<br>Display 屏幕相关</p>
<p>Display    屏幕相关<br>屏幕密度    density    屏幕密度（像素比例：0.75/1.0/1.5/2.0）    2.0<br>屏幕密度    densityDpi    屏幕密度（每寸像素：120/160/240/320）    480<br>手机内置分辨率    getWidth    内置好的不准确已废弃API    720<br>手机内置分辨率    getHeight<br>字体缩放比例    scaledDensity        2.0</p>
]]></content>
      <tags>
        <tag>Android-Develop</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-性能优化-启动优化-进阶篇</title>
    <url>/2021/11/17/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96-%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.cn/post/6854573215474253838#heading-0">掘金</a><br><a href="https://juejin.cn/post/6844904093786308622#heading-0">掘金</a></p>
<h1 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h1><p><img src="xmind.awebp" alt="深入探索Android启动速度优化"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-性能优化-IO优化</title>
    <url>/2021/11/02/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-IO%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote>
<ul>
<li>作者：yorek<br>来源：<a href="https://blog.yorek.xyz/">个人博客</a><br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>以前对读写的操作更多这块是基于业务去做开发，最近我们的游戏遇到一个问题，升级了Unity版本后，游戏相关的场景出现了卡顿，游戏加载资源场景和相关战斗场景出现了卡顿，通过我们对游戏业务深度的剖析，最后发现了卡顿的问题部分是<strong>IO</strong>的问题。所以我打算对这块知识好好学习一下。</p>
<h1 id="IO的基本知识"><a href="#IO的基本知识" class="headerlink" title="IO的基本知识"></a>IO的基本知识</h1><p><img src="io_1_1.jpg" alt="IO基本流程图"></p>
<p>你可以看到整个文件 I/O 操作由应用程序、文件系统和磁盘共同完成。首先应用程序将 I/O 命令发送给文件系统，然后文件系统会在合适的时机把 I/O 操作发给磁盘。</p>
<p>这就好比 CPU、内存、磁盘三个小伙伴一起完成接力跑，最终跑完的时间很大程度上取决于最慢的小伙伴。我们知道，CPU 和内存相比磁盘是高速设备，整个流程的瓶颈在于磁盘 I/O 的性能。所以很多时候，文件系统性能比磁盘性能更加重要，为了降低磁盘对应用程序的影响，文件系统需要通过各种各样的手段进行优化。那么接下来，我们首先来看文件系统。</p>
<h1 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h1><p>对于 Android 来说，现在普遍使用的是 Linux 常用的 ext4 文件系统。</p>
<p>F2FS 系统应该是未来 Android 的主流文件系统。</p>
<p>回到文件系统的 I/O。应用程序调用 read() 方法，系统会通过中断从用户空间进入内核处理流程，然后经过 VFS（Virtual File System，虚拟文件系统）、具体文件系统、页缓存 Page Cache。下面是 Linux 一个通用的 I/O 架构模型。</p>
<p><img src="io_1_2.png" alt="Linux-IO-架构图"></p>
<p>虚拟文件系统（VFS）。它主要用于实现屏蔽具体的文件系统，为应用程序的操作提供一个统一的接口。这样保证就算厂商把文件系统从 ext4 切换到 F2FS，应用程序也不用做任何修改。<br>文件系统（File System）。ext4、F2FS 都是具体文件系统实现，文件元数据如何组织、目录和索引结构如何设计、怎么分配和清理数据，这些都是设计一个文件系统必须要考虑的。每个文件系统都有适合自己的应用场景，我们不能说 F2FS 就一定比 ext4 要好。F2FS 在连续读取大文件上并没有优势，而且会占用更大的空间。只是对一般应用程序来说，随机 I/O 会更加频繁，特别是在启动的场景。你可以在 /proc/filesystems 看到系统可以识别的所有文件系统的列表。<br>页缓存（Page Cache）。在启动优化中我已经讲过 Page Cache 这个概念了，在读文件的时候会，先看它是不是已经在 Page Cache 中，如果命中就不会去读取磁盘。在 Linux 2.4.10 之前还有一个单独的 Buffer Cache，后来它也合并到 Page Cache 中的 Buffer Page 了。  </p>
<p>Page Cache 就像是我们经常使用的数据缓存，是文件系统对数据的缓存，目的是提升内存命中率。Buffer Cache 就像我们经常使用的 BufferInputStream，是磁盘对数据的缓存，目的是合并部分文件系统的 I/O 请求、降低磁盘 I/O 的次数。需要注意的是，它们既会用在读请求中，也会用到写请求中。</p>
<p>通过 /proc/meminfo 文件可以查看缓存的内存占用情况，当手机内存不足的时候，系统会回收它们的内存，这样整体 I/O 的性能就会有所降低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MemTotal:    2866492 kB</span><br><span class="line">MemFree:      72192 kB</span><br><span class="line">Buffers:      62708 kB      // Buffer Cache</span><br><span class="line">Cached:      652904 kB      // Page Cache</span><br></pre></td></tr></table></figure>

<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><h1 id="IO优化"><a href="#IO优化" class="headerlink" title="IO优化"></a>IO优化</h1><p>磁盘 I/O 是启动优化一定要抠的点。首先我们要清楚启动过程读了什么文件、多少个字节、Buffer 是多大、使用了多长时间、在什么线程等一系列信息。不仅仅是简单读写的问题。</p>
<h2 id="IO优化的事项"><a href="#IO优化的事项" class="headerlink" title="IO优化的事项"></a>IO优化的事项</h2><p><strong>启动过程不建议出现网络 I/O</strong></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-性能优化-启动优化</title>
    <url>/2021/11/02/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><blockquote>
<ul>
<li>作者：Android帅次<br>来源：<a href="https://juejin.cn/post/7020245974962405412">稀土掘金</a><br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  </li>
</ul>
</blockquote>
<ul>
<li><a href="https://time.geekbang.org/column/intro/100021101?code=XYo6BbXL8QKIVD8hO/4J00rK7TGKbHld2l2RSdESqQ4=&source=app_share">极客学院</a></li>
</ul>
<h1 id="解决问题的基本思路"><a href="#解决问题的基本思路" class="headerlink" title="解决问题的基本思路"></a>解决问题的基本思路</h1><blockquote>
<p>发现问题 ==&gt; 定位问题 ==&gt; 改善问题 ==&gt; 验证问题</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>随着我们开发项目的游戏包越来越大，app冷启动的问题耗时也是越来越严重，在高端手机上还好，但是在低端手机上的问题会越来越明显，毕竟启动快慢在一定程度上是玩家体验很重要的一环。我们尽量Unity和Android角度尽可能去分析。</p>
</blockquote>
<h1 id="Android的启动机制"><a href="#Android的启动机制" class="headerlink" title="Android的启动机制"></a>Android的启动机制</h1><p>我们需要这几种启动的方式有什么不同，这块不会很复杂，大部分同学都是接触过。</p>
<p>应用有三种启动状态：</p>
<p>冷启动:</p>
<p>温启动:</p>
<p>温启动介于冷启动和热启动中间吧。例如：</p>
<p>用户按返回键退出应用，然后重新启动。进程可能还没有被杀死，但应用必须通过调用onCreate（）重新创建 Activity。</p>
<p>系统回收了应用的内存，然后用户重新运行应用。应用进程和Activity都需要重新启动。</p>
<p>热启动:</p>
<p>热启动时，系统将应用从后台拉回前台，应用程序的 Activity 在内存中没有被销毁，那么应用程序可以避免重复对象初始化，UI的布局和渲染。</p>
<p>如果 Activity 被销毁则需要重新创建。</p>
<p>和冷启动的区别:不需要创建 Application。</p>
<h1 id="启动分析"><a href="#启动分析" class="headerlink" title="启动分析"></a>启动分析</h1><p>这块我们主要是对于这启动流程的剖析，从用户点击图标开始，整个启动过程经过哪<br>几个关键阶段，又会给用户带来哪些体验问题。</p>
<p>其实就是作为开发者要知道哪些是我们可以干预的，哪些是干预不了的。</p>
<h1 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h1><p>我们针对的主要还是冷启动这块，先简单的剖析下启动的流程。<br><img src="start_1_1.png" alt="app-启动流程"></p>
<p>T1 预览窗口显示。系统在拉起微信进程之前，会先根据微信的 Theme 属性创建预览窗口。当然如果我们禁用预览窗口或者将预览窗口指定为透明，用户在这段时间依然看到的是桌面。<br>T2 闪屏显示。在微信进程和闪屏窗口页面创建完毕，并且完成一系列 inflate view、onmeasure、onlayout 等准备工作后，用户终于可以看到熟悉的“小地球”。<br>T3 主页显示。在完成主窗口创建和页面显示的准备工作后，用户可以看到微信的主界面。<br>T4 界面可操作。在启动完成后，微信会有比较多的工作需要继续执行，例如聊天和朋友圈界面的预加载、小程序框架和进程的准备等。在这些工作完成后，用户才可以真正开始愉快地聊天。  </p>
<p>冷启动之前(关于android启动Api，后面我们会单独开一章来讲)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一. Step1 - Step 11：</span><br><span class="line">Launcher通过Binder进程间通信机制通知ActivityManagerService，</span><br><span class="line">它要启动一个Activity；</span><br><span class="line"></span><br><span class="line">二. Step 12 - Step 16：</span><br><span class="line">ActivityManagerService通过Binder进程间通信机制通知Launcher进入Paused状态；</span><br><span class="line"></span><br><span class="line">三. Step 17 - Step 24：</span><br><span class="line">Launcher通过Binder进程间通信机制通知ActivityManagerService，它已经准备就绪进入Paused状态，</span><br><span class="line">于是ActivityManagerService就创建一个新的进程，用来启动一个ActivityThread实例，</span><br><span class="line">即将要启动的Activity就是在这个ActivityThread实例中运行；</span><br><span class="line"></span><br><span class="line">四. Step 25 - Step 27：</span><br><span class="line">ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService，</span><br><span class="line">以便以后ActivityManagerService能够通过这个Binder对象和它进行通信；</span><br><span class="line"></span><br><span class="line">五. Step 28 - Step 35：</span><br><span class="line">ActivityManagerService通过Binder进程间通信机制通知ActivityThread，</span><br><span class="line">现在一切准备就绪，它可以真正执行Activity的启动操作了。</span><br></pre></td></tr></table></figure>
<pre><code>首先，会启动App  
然后，加载空白Window  
最后，创建进程  
</code></pre>
<p>需要注意的是，这些都是系统的行为，一般情况下我们是无法直接干预的。  </p>
<p>随后任务<br>首先，创建Application<br>启动主线程<br>创建MainActivity<br>加载布局<br>布置屏幕<br>首帧绘制<br>通常到了界面首帧绘制完成后，我们就可以认为启动已经结束了。  </p>
<h1 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h1><p>我们的优化方向就是 <strong>Application</strong>和<strong>Activity</strong>的生命周期 这个阶段，因为这个阶段的时机对于我们来说是可控的  </p>
<h1 id="优化核心思想"><a href="#优化核心思想" class="headerlink" title="优化核心思想"></a>优化核心思想</h1><p>启动优化是对 启动流程的那些步骤进行优化呢？</p>
<p>作为app的使用用户，不论你的app是游戏还是电商，用户关心的是<strong>当我的手机按下桌面的图标后，app的内容要尽快的显示出来。</strong> </p>
<p>特别像打车遇到高峰期，抢单软件和游戏app或者做定时活动的时候，启动响应太慢，这用户群体基本上就凉了一半，不能忽视其重要性。</p>
<p>根据启动流程的分析，显示页面能和用户交互，这是主线程做的事情。那么就要求 我们不能再主线程做耗时的操作。启动中的系统任务我们无法干预，能干预的就是在创建应用和创建 Activity 的过程中可能会出现的性能问题。这一过程具体就是：</p>
<blockquote>
<p>关于 Activity,Application生命周期具体可以看这里<br><a href="https://www.jianshu.com/p/5fd095c740af">Android生命周期</a><br>关于Activity启动模式 : <a href="https://zhupengbo.com/2021/08/11/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/">Activity 启动模式</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">App = Application</span><br><span class="line">App ==&gt; attachBaseContext</span><br><span class="line">App ==&gt; onCreate</span><br><span class="line">Activity ==&gt; onCreate</span><br><span class="line">Activity ==&gt; onStart</span><br><span class="line">Activity ==&gt; onResume</span><br></pre></td></tr></table></figure>
<!-- 作者：胡飞洋
链接：https://juejin.cn/post/6854573215474253838
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->


<h1 id="启动检测"><a href="#启动检测" class="headerlink" title="启动检测"></a>启动检测</h1><h2 id="使用adb-shell获取应用的启动时间"><a href="#使用adb-shell获取应用的启动时间" class="headerlink" title="使用adb shell获取应用的启动时间"></a>使用adb shell获取应用的启动时间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start -W packageName]/AppstartActivity</span><br></pre></td></tr></table></figure>

<p>ThisTime<br>表示最后一个Activity启动耗时。<br>TotalTime<br>表示所有Activity启动耗时。<br>WaitTime<br>表示AMS启动Activity的总耗时。<br>一般来说，只需查看得到的TotalTime，即应用的启动时间，其包括 创建进程 + Application初始化 + Activity初始化到界面显示 的过程。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作者：jsonchao</span><br><span class="line">链接：https://juejin.cn/post/6844904093786308622</span><br><span class="line">来源：稀土掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h2 id="Java-Code-线下测"><a href="#Java-Code-线下测" class="headerlink" title="Java-Code 线下测"></a>Java-Code 线下测</h2><p>你可以使用 reportFullyDrawn() 方法来测量应用程序启动和所有资源和视图层次结构的完整显示之间经过的时间。在应用程序执行延迟加载的情况下，这可能很有价值。在延迟加载中，应用程序不会阻止窗口的初始绘制，而是异步加载资源并更新视图层次结构。<br>这里我在Activity.onCreate()中加了个工作线程。并在里面调用reportFullyDrawn() 方法。代码如下</p>
<p>作者：Android帅次<br>链接：<a href="https://juejin.cn/post/7020245974962405412">https://juejin.cn/post/7020245974962405412</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                reportFullyDrawn();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">作者：Android帅次</span><br><span class="line">链接：https://juejin.cn/post/7020245974962405412</span><br><span class="line">来源：稀土掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h1 id="白屏或者黑屏"><a href="#白屏或者黑屏" class="headerlink" title="白屏或者黑屏"></a>白屏或者黑屏</h1><p>这块我就不写了，网上一堆，自己google一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//优点：避免启动app时白屏黑屏等现象</span><br><span class="line">//缺点：容易造成点击桌面图标无响应</span><br><span class="line">//（可以配合三方库懒加载，异步初始化等方案使用，减少初始化时长）</span><br><span class="line">//实现如下</span><br><span class="line">//0. appTheme</span><br><span class="line"> &lt;!-- Base application theme. --&gt;</span><br><span class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">    &lt;item name=&quot;colorPrimary&quot;&gt;@color/c_ff000000&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/c_ff000000&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;colorAccent&quot;&gt;@color/c_ff000000&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowActionBar&quot;&gt;false&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">//1. styles.xml中设置</span><br><span class="line">//1.1 禁用预览窗口</span><br><span class="line">&lt;style name=&quot;AppTheme.Launcher&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">//1.2 指定透明背景</span><br><span class="line">&lt;style name=&quot;AppTheme.Launcher&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/c_00ffffff&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">//2. 为启动页/闪屏页Activity设置theme</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.splash.SplashActivity&quot;</span><br><span class="line">    android:screenOrientation=&quot;portrait&quot;</span><br><span class="line">    android:theme=&quot;@style/AppTheme.Launcher&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">//3. 在该Activity.onCreate()中设置AppTheme（设置布局id之前）</span><br><span class="line">//比如我是基类中单独抽取的获取布局id方法，那么在启动页中重写此方法时加入如下配置：</span><br><span class="line"> @Override</span><br><span class="line">protected int getContentViewId() &#123;</span><br><span class="line">    setTheme(R.style.AppTheme_Launcher);</span><br><span class="line">    return R.layout.activity_splash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="MultiDex"><a href="#MultiDex" class="headerlink" title="MultiDex"></a>MultiDex</h1><p>参考：<a href="https://www.jianshu.com/p/c2d7b76ff063">简书-MultiDex</a><br>提出一个疑问 ：主进程如何得知加载进程完成加载？</p>
<!-- ## 启动过程分析 -->


<!-- ## 启动过慢的表现 -->

<h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>技术写作模板</title>
    <url>/2021/10/21/%E5%86%99%E4%BD%9C%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="写作的注意事项"><a href="#写作的注意事项" class="headerlink" title="写作的注意事项"></a>写作的注意事项</h1><ul>
<li>文章<br>如果文章全篇转载，请在<strong>全文开头</strong>显著位置注明出处并链接至原文<br>如果文章内容过多，那么可以根据内容类型进行分篇处理（保持读者的阅读耐心)</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>初衷</li>
<li>适合人群</li>
<li>内容结构</li>
<li>温馨提示</li>
</ul>
<h1 id="文章主体"><a href="#文章主体" class="headerlink" title="文章主体"></a>文章主体</h1><p>文章主体一定要符合文章前言的内容结构，除此之外内容尽量符合以下一些特性：</p>
<ul>
<li>图文并茂</li>
<li>思维导图</li>
<li>框架大图</li>
<li>表格分类对比</li>
<li>可视化数据分析</li>
<li>列表分类</li>
</ul>
<h1 id="写作风格"><a href="#写作风格" class="headerlink" title="写作风格"></a>写作风格</h1><ul>
<li>标题</li>
</ul>
<p>文章有且仅有 1 个一级标题<br>标题统一采用「#」标记<br>标题逐级递增（例如避免在一级标题下直接新增三级标题）<br>标题的「#」标记和文本之间必须要有 1 个空格，否则类似掘金平台无法识别标题<br>标题和子标题内容避免完全一致<br>标题避免有标点符号 “.,;:!?。，；：！？”<br>标题前后应该有空行<br>标题避免缩进<br>避免出现四级标题，保持简洁<br>避免出现孤儿标题<br>不要使用加粗代替标题<br>如果当前标题下内容过于简洁（例如只有一个简短的段落），可以需要考虑去除标题  </p>
<blockquote>
<p>标题的作用除了明确主题之外，重点是快进到想阅读的部分</p>
</blockquote>
<blockquote>
<p>作者：子弈<br>链接：<a href="https://juejin.cn/post/6844904168600109069">https://juejin.cn/post/6844904168600109069</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  </p>
</blockquote>
<ul>
<li>段落<br>段落之间不要产生多个连续的空白行<br>如果部分段落引用其他的技术文章，则需标明<strong>作者</strong>和<strong>来源链接</strong><br>段落开头避免缩进</li>
<li>引用<br>引用标记和内容之间避免有多个空格<br>引用前后应该有空行<br>温馨提示的内容可以采用引用的呈现形式</li>
<li>分割线<br>可以在图片下方添加或者是结尾的段落</li>
<li>代码块<br>在代码块中展示 Shell 命令不需要在命令行前加「$」符号，除非同时需要打印输出信息<br>代码块前后应该有空行<br>代码块必须指定语言类型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&#x27;load&#x27;, function() &#123;</span><br><span class="line">  console.log(&#x27;window loaded&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果部分代码引用其他的技术文章，则需标明作者和来源链接</p>
<blockquote>
<p>前方多图，流量预警⚠️ ⚠️ ⚠️ </p>
</blockquote>
<h1 id="写作工具"><a href="#写作工具" class="headerlink" title="写作工具"></a>写作工具</h1><ul>
<li><a href="https://carbon.now.sh/">代码块—carbon</a></li>
</ul>
<p><img src="carbon.png" alt="carbon"></p>
<ul>
<li><p>思维导图 - Xmind</p>
</li>
<li><p>流程图  Gilffy Diagrams</p>
</li>
<li><p>流程图 <a href="https://www.processon.com/">Process On</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>利弊分析</li>
<li>局限性及可扩展性</li>
<li>注意事项</li>
<li>未来发展</li>
<li>规律分析</li>
<li>横向对比</li>
<li>技术结论</li>
<li>思想指导</li>
<li>集思广益</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://juejin.cn/post/6844904168600109069#heading-1">掘金-技术文章的写作技巧分享</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidSdk-模块化</title>
    <url>/2021/10/19/AndroidSdk-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>初衷s1和s3出包的项目是<strong>Eclipse</strong>，后更新为<strong>Android-Studio</strong>，使用<strong>Android模块化</strong>对项目进行统一的划分。</p>
<h1 id="SDK分类"><a href="#SDK分类" class="headerlink" title="SDK分类"></a>SDK分类</h1><p>SDK划分主要是以我们打包环境来区别。<br>打包环境有2种，正式环境对应正式sdk,测试环境对应测试sdk。  </p>
<ul>
<li><strong>正式环境</strong><br>正式包，用于线上，一般是接了渠道的sdk，具备了登录，充值，实名等功能。  </li>
<li><strong>测试环境</strong><br>测试包，内部测试，不包含渠道的sdk，不具备渠道sdk的功能，主要供于游戏内部测试。  </li>
</ul>
<h1 id="SDK的结构"><a href="#SDK的结构" class="headerlink" title="SDK的结构"></a>SDK的结构</h1><p>为了方便理解SDK划分和结构，我们拿S1项目举个例子，可以先看下这张图</p>
<p><img src="%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="SDK结构图">  </p>
<p>无论是测试SDK或者正式SDK都划分为2个模块,一个为common模块，一个channel模块。</p>
<p>这里我们以S1正式SDK举例.</p>
<p>正式SDK包含2个模块，也就是是s1-common-sdk,s1-channel-dalan。</p>
<h2 id="common库结构图"><a href="#common库结构图" class="headerlink" title="common库结构图"></a>common库结构图</h2><p><img src="s1-common-sdk.png" alt="s1-common-sdk结构图"><br>!!!切记common编译库包含跟unity的的游戏库一致，否则游戏会出现奇怪的问题。</p>
<hr>
<h2 id="channel结构图"><a href="#channel结构图" class="headerlink" title="channel结构图"></a>channel结构图</h2><p><img src="s1-channel-dalan.png" alt="s1-common-channel结构图">  </p>
<hr>
<p>我们把2个目录整合一下，其实正式包channel.jar的目录只是把原本的sdks下的GameSDK和HyGameApplication取出，然后单纯作为一个jar。而其他代码是作为sdk的公共库(一般情况下不变)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–com</span><br><span class="line">——hoye</span><br><span class="line">——-game</span><br><span class="line">——--sdks</span><br><span class="line">——---GameSDK(channel)   </span><br><span class="line">——---GameSDKConstants</span><br><span class="line">——---GameSDKinferface</span><br><span class="line">-----GameSDKManager(channel)</span><br><span class="line">-----HyGameApplication   </span><br><span class="line">----BosController</span><br><span class="line">----GameActivity</span><br><span class="line">----GameApplication</span><br><span class="line">----GameConfig</span><br><span class="line">----HaoyueUtils</span><br><span class="line">----JsonParse</span><br><span class="line">----ResUtils</span><br><span class="line">----TakePhotoActivity</span><br></pre></td></tr></table></figure>

<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>目前工作环境正常下的版本，后续可能会随着as版本升级而发生变动，以下版本不作为唯一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AndroidStudio-version-4.1.1  </span><br><span class="line">gradle-version-6.1.1  </span><br><span class="line">gradle-tool-3.5.0  </span><br></pre></td></tr></table></figure>


<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>之所以用模块化开发，是为了后续几点考虑</p>
<ul>
<li>多团队并行开发测试；</li>
<li>模块间解耦、重用；</li>
<li>可单独编译打包某一模块，提升开发效率 </li>
</ul>
<p>而我们的项目刚好是要打包某一模块，提升开发的效率。</p>
<h2 id="as项目的配置-—-生成as模块"><a href="#as项目的配置-—-生成as模块" class="headerlink" title="as项目的配置 — 生成as模块"></a>as项目的配置 — 生成as模块</h2><p><img src="as.png" alt="as模块">  </p>
<p>我们需要在左侧红色方框的2个配置文件内配置好<br><strong>apply.properties</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1_channel_dalan = com.android.library</span><br></pre></td></tr></table></figure>
<p><strong>setting.gradle</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include(&#x27;s1_channel_dalan&#x27;)</span><br></pre></td></tr></table></figure>
<p>以上2个配置之后，点击Sync Project with Gradle Files<br>会在右侧生成gradle模块(以模块的名称来命名)。如as模块右侧截图。在这里的项目都是生成好了，有需要的话按照以上方式添加新的模块即可。</p>
<p>读取的代码在主目录的build.gradle，这里不做展示。</p>
<h2 id="decompile转换工具库说明"><a href="#decompile转换工具库说明" class="headerlink" title="decompile转换工具库说明"></a>decompile转换工具库说明</h2><p>as截图内左上角的编译的目录是 <strong>decomplie</strong>,是转化文件格式的工具类，主要是用于 .jar文件,smali文件,.dex文件3者的转换。</p>
<p>as项目内已编写好gradle脚本(在根目录的gradle)，通过gradle调用decompile的python的脚本(smali.py)，然后<strong>smali.py</strong>调用相关的命令,生成jar包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–decompile ： 打包bundle的时候，自动生成</span><br><span class="line">——lib: 工具jar存放的目录</span><br><span class="line">——-baksmali.jar jar转化dex</span><br><span class="line">——-baksmali-2.2.2.jar</span><br><span class="line">——-smali.jar    dex转smali</span><br><span class="line">——-smali-2.2.2.ajr</span><br><span class="line">—gradle.sh 编译检查的命令</span><br><span class="line">-smali.py 调用python脚本</span><br></pre></td></tr></table></figure>

<h1 id="工程流程-—-如何打包生成jar"><a href="#工程流程-—-如何打包生成jar" class="headerlink" title="工程流程 — 如何打包生成jar"></a>工程流程 — 如何打包生成jar</h1><p>as项目内的android模块通过<strong>decompile转换库</strong>调用python命令,把java目录下的代码打成.jar包，这里打的jar包是不包含lib，也就是只包含java目录下的代码，然后替换到打包工具的对应的目录，然后打包工具生成apk。</p>
<p>我们这里举例说明一下，假设我们需要生成s1-common-sdk的jar包。</p>
<p><img src="generate-jar.png" alt="generate_jar"> </p>
<p>1.右侧Gradle模块，是根据左侧模块文件夹的文件名生成的，然后我们点击<strong>a_makeJarLib_smali</strong>即可在文件下生成对应模块的jar。</p>
<p><img src="generated-jar.png" alt="generate_jar"> </p>
<p>2.生成jar后只要提交到145远程机的打包工具对应的目录即可。</p>
<p>3.然后使用打包工具生成apk，对apk进行测试</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1.在生成jar的时候，一定分清楚对应的处理的模块，打成jar之后可以通过第三方工具，查看对应的层级代码，避免在提交打包工具的时候提交错jar，减少低成本的问题。</p>
<p>2.as模块common库的编译时要提前检查，左侧as模块的Lib目录下的unity版本是不是跟打包工具的unity版本库一致。</p>
<p>如：S1-PIUS使用的unity库是2018.jar,那么common库的模块下的unity版本也要是2018的才行，不然提交后打包工具后，会因为编译后的字节码不一致而导致黑屏或者是卡顿等其他奇怪的问题。</p>
<p>3.在项目编译时，该工具的会先提前对模块内的代码进行检查，检查通过后才可编译，在一定程度减少容错率，无法编译时，先提前检查代码。</p>
<h1 id="局限性及可扩展性"><a href="#局限性及可扩展性" class="headerlink" title="局限性及可扩展性"></a>局限性及可扩展性</h1><p>扩展性：在此项目上我在满足基本项目打包的要求上，新增了a_makeJarChannel_smali的命令:</p>
<p>可以把包含Lib的依赖和gardle远程依赖统一分成合成jar.<br>同时对生成好的jar拆分为smali，dex，改功能针对发行要求，在mac环境上已测试通过。</p>
<p>后续可继续增加扩展smali分包的功能</p>
<!-- # 文章总结
* 利弊分析
* 局限性及可扩展性
* 注意事项
* 未来发展
* 规律分析
* 横向对比
* 技术结论
* 思想指导
* 集思广益
# 参考文档

[掘金-写作技巧](https://juejin.cn/post/6844904168600109069#heading-6)  
作者：子弈  
链接：https://juejin.cn/post/6844904168600109069  
来源：稀土掘金  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  -->]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-组件化</title>
    <url>/2021/10/19/AndroidSdk-%E7%BB%84%E4%BB%B6%E5%8C%96-1/</url>
    <content><![CDATA[<h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><h1 id="组件化和模块化"><a href="#组件化和模块化" class="headerlink" title="组件化和模块化"></a>组件化和模块化</h1><h1 id="组件化开发需要解决的问题"><a href="#组件化开发需要解决的问题" class="headerlink" title="组件化开发需要解决的问题"></a>组件化开发需要解决的问题</h1><h1 id="组件单独调试"><a href="#组件单独调试" class="headerlink" title="组件单独调试"></a>组件单独调试</h1><h1 id="组件间数据传递与方法调用"><a href="#组件间数据传递与方法调用" class="headerlink" title="组件间数据传递与方法调用"></a>组件间数据传递与方法调用</h1>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-接口和内部类</title>
    <url>/2021/10/03/Java-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<!-- 接口和内部类 -->
<h1 id="接口-—-Interface"><a href="#接口-—-Interface" class="headerlink" title="接口 — Interface"></a>接口 — Interface</h1><p>定义：<br>接口是对类一组需求的描述，实现接口的类要遵从接口的描述的定义。<br>接口中的所有方法自动地属于public，所有声明方法不必提供关键字<br>不过在实现接口的时候，必须将方法声明为public，否则编译器会给出试图提供更弱的访问权限信息</p>
<pre><code>通常类实现一个接口，通常需要2个步骤
1.让类声明为实现给定的接口
2.对接口中的方法进行定义
</code></pre>
<h2 id="java十万个为什么"><a href="#java十万个为什么" class="headerlink" title="java十万个为什么"></a>java十万个为什么</h2><p>为什么接口内无法定义静态方法？</p>
<h1 id="内部类-—-inner-class"><a href="#内部类-—-inner-class" class="headerlink" title="内部类 — inner class"></a>内部类 — inner class</h1><p>内部类（inner class）是定义在另一个类中的类，其实也可以区分为外部类和内部类，这2者的关系，<br>我个人的理解就好像是<strong>火车车厢</strong>跟<strong>火车车厢内的旅客</strong>关系，火车先组装好，再把旅客放上去，旅客在车厢内，肯定是很自然拿到车厢的信息。<br>举个例子：自然拿到车厢的班次，车厢内座位。</p>
<pre><code>内部类的方法可以访问该类定义所在的作用域中的数据，包括私有数据。  
内部类可以对同一个包中的其他类隐藏起来。  
当想定义一个回调函数并且不想编写大量的代码的时候，可以使用匿名类内部类对比。
</code></pre>
<h2 id="课外补习"><a href="#课外补习" class="headerlink" title="课外补习"></a>课外补习</h2><p>嵌套是一种类与类之间的关系，而不是对象之间的关系。<br>嵌套类有2个好处：<strong>命名控制</strong>和<strong>访问控制</strong></p>
<h3 id="java-十万个为什么"><a href="#java-十万个为什么" class="headerlink" title="java 十万个为什么"></a>java 十万个为什么</h3><h4 id="为什么java内部类可以访问外部对象"><a href="#为什么java内部类可以访问外部对象" class="headerlink" title="为什么java内部类可以访问外部对象"></a>为什么java内部类可以访问外部对象</h4><p>java的内部类对象有一个隐式引用，实例化该内部类对象的外部对象，通过这个指针，可以访问到外部类的全部状态。<br>内部类的对象总有一个隐式的引用，它指向它的外部类对象。</p>
<h4 id="总共有多少种内部类"><a href="#总共有多少种内部类" class="headerlink" title="总共有多少种内部类"></a>总共有多少种内部类</h4><ul>
<li>4种内部类</li>
</ul>
<ul>
<li>成员内部类</li>
<li>局部内部类</li>
<li>静态内部类</li>
<li>匿名内部类<h4 id="内部类的共性"><a href="#内部类的共性" class="headerlink" title="内部类的共性"></a>内部类的共性</h4></li>
</ul>
<p>1.内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。<br>内部类不能用普通的方式访问。内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的。<br>2.内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员的变量。  </p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>1.局部类不能用public和private访问说明符进行声明。<br>2.他的作用域被限定在这声明这个局部类的块中。<br>3.局部内部类中不可定义静态变量，可以访问外部类的局部变量(即方法内的变量)，但是变量必须是final的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Outer2 &#123;</span><br><span class="line">private int s = 100;</span><br><span class="line">private int out_i = 1;</span><br><span class="line">public void f(final int k)&#123;</span><br><span class="line">final int s = 200;</span><br><span class="line">int i = 1;</span><br><span class="line">final int j = 10;</span><br><span class="line">class Inner&#123; //定义在方法内部</span><br><span class="line">int s = 300;//可以定义与外部类同名的变量</span><br><span class="line">//static int m = 20;//不可以定义静态变量</span><br><span class="line">Inner(int k)&#123;</span><br><span class="line">inner_f(k);</span><br><span class="line">&#125;</span><br><span class="line">int inner_i = 100;</span><br><span class="line">void inner_f(int k)&#123;</span><br><span class="line">System.out.println(out_i);//如果内部类没有与外部类同名的变量，在内部类中可以直接访问外部类的实例变量</span><br><span class="line">System.out.println(k);//可以访问外部类的局部变量(即方法内的变量)，但是变量必须是final的</span><br><span class="line">// System.out.println(i);</span><br><span class="line">System.out.println(s);//如果内部类中有与外部类同名的变量，直接用变量名访问的是内部类的变量</span><br><span class="line">System.out.println(this.s);//用&quot;this.变量名&quot; 访问的也是内部类变量</span><br><span class="line">System.out.println(Outer2.this.s);//用外部&quot;外部类类名.this.变量名&quot; 访问的是外部类变量</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">new Inner(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//访问局部内部类必须先有外部类对象</span><br><span class="line">Outer2 out = new Outer2();</span><br><span class="line">out.f(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>我们在上文提到这个观点: </p>
<blockquote>
<p>内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员的变量。</p>
</blockquote>
<p>这里解释为什么，内部类是静态，那么它就是类级别的成员，根据类的加载机制(加载顺序)，就不在依赖对象而存在。所以静态内部类，不能访问外部类非静态成员。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Outer3 &#123;</span><br><span class="line"></span><br><span class="line">private static int i = 1;</span><br><span class="line">private int j = 10;</span><br><span class="line">public static void outer_f1()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void outer_f2()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 静态内部类可以用public，protect，private修饰</span><br><span class="line">static class Inner &#123;</span><br><span class="line">static int inner_i = 100;</span><br><span class="line">int inner_j = 200;</span><br><span class="line"></span><br><span class="line">static void inner_f1() &#123;</span><br><span class="line">System.out.println(&quot;Outer.i &quot; + i);//静态内部类只能访问外部类的静态成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inner_f2() &#123;</span><br><span class="line">// System.out.println(&quot;Outer.i&quot;+j);//静态内部类不能访问外部类的非静态成员</span><br><span class="line">// outer_f2();//包括非静态变量和非静态方法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void outer_f3()&#123;</span><br><span class="line">System.out.println(Inner.inner_i);</span><br><span class="line">Inner.inner_f1();</span><br><span class="line">// 外部类访问内部类的非静态成员:实例化内部类即可</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.inner_f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Outer().outer_f3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<em><strong><strong><strong>生成（new）一个静态内部类不需要外部类成员：这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成：<br>Outer.Inner in=new Outer.Inner()；<br>而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类。静态内部类不可用private来进行定义。</strong></strong></strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StaticInnerClassTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">double[] d = new double[20];</span><br><span class="line">for (int i= 0;i&lt;d.length;i++)</span><br><span class="line">d[i] = 100 * Math.random();</span><br><span class="line">ArrayAlg.Pair p = ArrayAlg.minmax(d);</span><br><span class="line">System.out.println(&quot;min = &quot; + p.getFirst());</span><br><span class="line">System.out.println(&quot;min = &quot; + p.getSecond());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ArrayAlg</span><br><span class="line">&#123;</span><br><span class="line">public static class Pair</span><br><span class="line">&#123;</span><br><span class="line">private double first;</span><br><span class="line">private double second;</span><br><span class="line"></span><br><span class="line">public Pair(double first, double second) &#123;</span><br><span class="line">this.first = first;</span><br><span class="line">this.second = second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getFirst() &#123;</span><br><span class="line">return first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getSecond() &#123;</span><br><span class="line">return second;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Pair minmax(double[] values)&#123;</span><br><span class="line"></span><br><span class="line">double min = Double.MAX_VALUE;</span><br><span class="line">double max = Double.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">for (double v : values)&#123;</span><br><span class="line">if (min &gt; v);</span><br><span class="line">if (max &lt; v);</span><br><span class="line">&#125;</span><br><span class="line">return new Pair(min,max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>先提出问题?</p>
<p>匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new 父类构造器（参数列表）|实现接口（）    </span><br><span class="line">    &#123;    </span><br><span class="line">     //匿名内部类的类体部分    </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p>我们看到使用匿名内部类我们必须继承一个父类或者是实现一个接口，仅能继承一个父类或者是一个接口。<br>没有class的关键字，这是因为匿名类是直接使用new来生成一个对象的引用。当然是隐式的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Bird &#123;  </span><br><span class="line">    private String name;  </span><br><span class="line">  </span><br><span class="line">    public String getName() &#123;  </span><br><span class="line">        return name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void setName(String name) &#123;  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public abstract int fly();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">      </span><br><span class="line">    public void test(Bird bird)&#123;  </span><br><span class="line">        System.out.println(bird.getName() + &quot;能够飞 &quot; + bird.fly() + &quot;米&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Test test = new Test();  </span><br><span class="line">        test.test(new Bird() &#123;  </span><br><span class="line">              </span><br><span class="line">            public int fly() &#123;  </span><br><span class="line">                return 10000;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            public String getName() &#123;  </span><br><span class="line">                return &quot;大雁&quot;;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<hr>
<p>Output：<br>大雁能够飞 10000米  </p>
<p>对于这段匿名内部类代码其实是可以拆分为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class WildGoose extends Bird&#123;  </span><br><span class="line">    public int fly() &#123;  </span><br><span class="line">        return 10000;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public String getName() &#123;  </span><br><span class="line">        return &quot;大雁&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">WildGoose wildGoose = new WildGoose();  </span><br><span class="line">test.test(wildGoose);  </span><br></pre></td></tr></table></figure>
<p>在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。<br>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。</p>
<p>使用匿名内部类时，我们必须是继承一个类或者是实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。<br>匿名类是不能定义构造函数的。<br>匿名内部类中不能存在任何静态成员变量和静态方法<br>匿名内部类为局部内部类，所以局部内部类的所有限制对匿名类产生有效<br>匿名类不能是抽象，因为他必须实现继承的类或者是实现接口的所有抽象方法</p>
<p>使用的形参为何要final？</p>
<p>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final<br>    当所在的方法的形参需要被内部类里面使用时，该形参必须为final。</p>
<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OuterClass &#123;  </span><br><span class="line">    public void display(final String name,String age)&#123;  </span><br><span class="line">        class InnerClass&#123;  </span><br><span class="line">            void display()&#123;  </span><br><span class="line">                System.out.println(name);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从上面代码中看好像name参数应该是被内部类直接调用？<br>其实不然，在java编译之后实际的操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OuterClass$InnerClass &#123;  </span><br><span class="line">    public InnerClass(String name,String age)&#123;  </span><br><span class="line">        this.InnerClass$name = name;  </span><br><span class="line">        this.InnerClass$age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void display()&#123;  </span><br><span class="line">        System.out.println(this.InnerClass$name + &quot;----&quot; + this.InnerClass$age );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。<br>直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p>
<p>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。<br>故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。</p>
<h3 id="匿名内部类初始化"><a href="#匿名内部类初始化" class="headerlink" title="匿名内部类初始化"></a>匿名内部类初始化</h3><pre><code>我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OutClass &#123;  </span><br><span class="line">    public InnerClass getInnerClass(final int age,final String name)&#123;  </span><br><span class="line">        return new InnerClass() &#123;  </span><br><span class="line">            int age_ ;  </span><br><span class="line">            String name_;  </span><br><span class="line">            //构造代码块完成初始化工作  </span><br><span class="line">            &#123;  </span><br><span class="line">                if(0 &lt; age &amp;&amp; age &lt; 200)&#123;  </span><br><span class="line">                    age_ = age;  </span><br><span class="line">                    name_ = name;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            public String getName() &#123;  </span><br><span class="line">                return name_;  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            public int getAge() &#123;  </span><br><span class="line">                return age_;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        OutClass out = new OutClass();  </span><br><span class="line">          </span><br><span class="line">        InnerClass inner_1 = out.getInnerClass(201, &quot;chenssy&quot;);  </span><br><span class="line">        System.out.println(inner_1.getName());  </span><br><span class="line">          </span><br><span class="line">        InnerClass inner_2 = out.getInnerClass(23, &quot;chenssy&quot;);  </span><br><span class="line">        System.out.println(inner_2.getName());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类加载顺序：有继承关系的加载顺序"><a href="#类加载顺序：有继承关系的加载顺序" class="headerlink" title="类加载顺序：有继承关系的加载顺序"></a>类加载顺序：有继承关系的加载顺序</h1><p><a href="https://www.cnblogs.com/sxkgeek/p/9647992.html">参考文章(CSDN)-类加载的顺序</a></p>
<p>1.首先加载父类的静态字段或者静态语句块</p>
<p>2.子类的静态字段或静态语句块</p>
<p>3.父类普通变量以及语句块</p>
<p>4.父类构造方法被加载</p>
<p>5.子类变量或者语句块被加载</p>
<p>6.子类构造方法被加载</p>
<h2 id="类加载顺序-关键点"><a href="#类加载顺序-关键点" class="headerlink" title="类加载顺序:关键点"></a>类加载顺序:关键点</h2><ul>
<li>静态代码块（只加载一次）</li>
<li>构造方法（创建一个实例就加载一次）</li>
<li>静态方法，调用的时候才会加载，不调用的时候不会加载</li>
<li>静态语句块和静态变量被初始化的顺序与代码先后顺序有关</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android插件化-开篇</title>
    <url>/2021/09/15/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Android插件化-开篇"><a href="#Android插件化-开篇" class="headerlink" title="Android插件化-开篇"></a>Android插件化-开篇</h1><p>Android插件化从技术上来说就是如何启动未安装的apk（主要是四大组件）里面的类，主要问题涉及如何加载类、如何加载资源、如何管理组件生命周期。</p>
<p>1.类加载 (四大组件)<br>2.资源的加载<br>3.如何管理组件生命周期  </p>
<h1 id="资源的加载"><a href="#资源的加载" class="headerlink" title="资源的加载"></a>资源的加载</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private AssetManager createAssetManager(String apkPath) &#123;</span><br><span class="line">    AssetManager am = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //反射构造 AssetManager</span><br><span class="line">         am =  AssetManager.class.newInstance();</span><br><span class="line">        Method method = AssetManager.class.getDeclaredMethod(&quot;addAssetPath&quot;,String.class);</span><br><span class="line">        //通过反射 将 apk 的目录添加到 AssetManager 的资源路径下</span><br><span class="line">        method.invoke(am,apkPath);</span><br><span class="line">        return am;</span><br><span class="line"></span><br><span class="line">    &#125; catch (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return am;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Resouces的访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  通过 AssetManager 和设备配置来构造 Resouces</span><br><span class="line"> * @param assetManager</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private Resources createResource(AssetManager assetManager) &#123;</span><br><span class="line">    Resources resources = mContext.getResources();</span><br><span class="line">    return new Resources(assetManager,resources.getDisplayMetrics(),resources.getConfiguration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何管理组件生命周期"><a href="#如何管理组件生命周期" class="headerlink" title="如何管理组件生命周期"></a>如何管理组件生命周期</h1><h2 id="ClassLoader-类加载"><a href="#ClassLoader-类加载" class="headerlink" title="ClassLoader-类加载"></a>ClassLoader-类加载</h2><h3 id="Java-ClassLoader"><a href="#Java-ClassLoader" class="headerlink" title="Java - ClassLoader"></a>Java - ClassLoader</h3><ul>
<li>Java中默认有三种ClassLoader。分别是:<ul>
<li>BootStrap ClassLoader：启动类加载器，最顶层的加载器。主要负责加载JDK中的核心类。在JVM启动后也随着启动，并构造Ext ClassLoader和App ClassLoader。</li>
</ul>
<ul>
<li>Extension ClassLoader：扩展类加载器，负责加载Java的扩展类库。</li>
<li>App ClassLoader：系统类加载器，负责加载应用程序的所有jar和class文件。</li>
<li>自定义ClassLoader：需要继承自ClassLoader类。 </li>
</ul>
</li>
</ul>
<h4 id="ClassLoader职能"><a href="#ClassLoader职能" class="headerlink" title="ClassLoader职能"></a>ClassLoader职能</h4><p>ClassLoader默认使用双亲委托模型来搜索类。<br>每个ClassLoader都有一个父类的引用。当ClassLoader需要加载某个类时，先判断是否加载过，如果加载过就返回Class对象。否则交给他的父类去加载，继续判断是否加载过。这样 层层判断，就到了最顶层的BootStrap ClassLoader来试图加载。如果连最顶层的Bootstrap ClassLoader都没加载过，那就加载。如果加载失败，就转交给子ClassLoader，层层加载，直到最底层。如果还不能加载的话那就只能抛出异常了。  </p>
<ul>
<li>通过这种双亲委托模型，好处是：<ul>
<li>更高效，父类加载一次就可以避免了子类多次重复加载</li>
<li>更安全，避免了外界伪造java核心类。</li>
</ul>
</li>
</ul>
<h3 id="Android-ClassLoader"><a href="#Android-ClassLoader" class="headerlink" title="Android - ClassLoader"></a>Android - ClassLoader</h3><p>android从5.0开始使用art虚拟机，这种虚拟机在程序运行时也需要ClassLoader将类加载到内存中，但是与java不同的是，java虚拟机通过读取class字节码来加载，但是art则是通过dex字节码来加载。<br>这是一种优化，可以合并多个class文件为一个classes.dex文件。</p>
<ul>
<li>android一共有三种类加载器:  <ul>
<li>BootClassLoader：父类构造器  </li>
<li>PathClassLoader：一般是加载指定路径/data/app中的apk，也就是安装到手机中的apk。所以一般作为默认的加载器。</li>
<li>DexClassLoader：从包含classes.dex的jar或者apk中，加载类的加载器，可用于动态加载。<br>看PathClassLoader和DexClassLoader源码，都是继承自BaseDexClassLoader。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DexClassLoader(String dexPath, String optimizedDirectory,</span><br><span class="line">      String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">    super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">&#125;</span><br><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">public PathClassLoader(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, null, parent);  //见下文</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BaseDexClassLoader extends ClassLoader &#123;</span><br><span class="line">    private final DexPathList pathList;</span><br><span class="line">public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">        String libraryPath, ClassLoader parent) &#123;</span><br><span class="line">        super(parent);  //见下文</span><br><span class="line">        //收集dex文件和Native动态库【见小节3.2】</span><br><span class="line">        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们可以看到PathClassLoader的两个参数都为null，表明只能接受固定的dex文件，而这个文件是只能在安装后出现的。而DexClassLoader中optimizedDirectory，和librarySearchPath都是可以自己定义的，说明我们可以传入一个jar或者apk包，保证解压缩后是一个dex文件就可以操作了。因此，我们通常使用DexClassLoader来进行插件化和热修复。  </li>
</ul>
</li>
</ul>
<p><img src="ClassLoader.png" alt="ClassLoader"></p>
<p>可以看到，BaseDexClassLoader有一个相当重要的过程就是初始化DexPathList。初始化DexPathList的过程主要是收集dexElements和nativeLibraryPathElements。一个Classloader可以包含多个dex文件，每个dex文件被封装到一个Element对象。这element对象在初始化和热修复逻辑中是相当重要的。当查找某个类时，会遍历dexElements，如果找到就返回，否则继续遍历。所以当多个dex中有相同的类，只会加载前面的dex中的类。下面是这段逻辑的具体实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">    for (Element element : dexElements) &#123;</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">        if (dex != null) &#123;</span><br><span class="line">            //找到目标类，则直接返回</span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            if (clazz != null) &#123;</span><br><span class="line">                return clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结<br>我们先是讲解了Java中类加载的双亲委托机制，然后介绍了Android中的几种ClassLoader，从源码角度介绍了两种ClassLoader加载机制的不同。以后的插件化实践中，我们会经常用到DexClassLoader。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机English词汇普及更正</title>
    <url>/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BAEnglish%E8%AF%8D%E6%B1%87%E6%99%AE%E5%8F%8A%E6%9B%B4%E6%AD%A3/</url>
    <content><![CDATA[<p>acronym 缩写</p>
<p>pertain 属于<br>pertaiing to 属于<br>Threadlocal values pertaining to this thread.<br>This map is maintained by the ThreadLocal class.  </p>
<p>usages n 用途,用法</p>
<p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了处理非常大和生命周期非常长的线程(<strong>usages</strong>)，哈希表使用弱引用作为 key。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-CMD集合</title>
    <url>/2021/09/07/Android-CMD%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重启adb </span><br><span class="line">adb kill-server &amp;&amp; adb server &amp;&amp; adb shell</span><br><span class="line">查看当前的进程</span><br><span class="line">adb shell ps | grep package-name </span><br><span class="line">过滤日志</span><br><span class="line">adb logcat </span><br><span class="line">查看链接cpu架构信息</span><br><span class="line">adb shell </span><br><span class="line">cat/proc/cpuinfo </span><br><span class="line">查看已经连接的设备</span><br><span class="line">adb devices</span><br><span class="line">指定设备安装apk</span><br><span class="line">adb -s xxx install xxx.apk</span><br><span class="line"></span><br><span class="line">keytool -list -v -keystore  xxx.keystore</span><br><span class="line">查看签名秘钥</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ADB-进阶CMD"><a href="#ADB-进阶CMD" class="headerlink" title="ADB 进阶CMD"></a>ADB 进阶CMD</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev:每隔 1s 输出一次APP CPU信息，命令如下</span><br><span class="line">$adb shell</span><br><span class="line">$adb top -d 1 | grep com.packagename.xxx</span><br><span class="line"></span><br><span class="line">dev: 获取Apk安装的路径</span><br><span class="line">adb shell pm path com.packagename.xxx</span><br><span class="line"></span><br><span class="line">dev: 导出apk文件</span><br><span class="line">adb pull /data/app/com.packagename.xxx/base.apk</span><br><span class="line"></span><br><span class="line">adb shell pm list package</span><br><span class="line">example:</span><br><span class="line">$ adb shell pm list package tao</span><br><span class="line">package:com.taobao.taobao</span><br><span class="line"></span><br><span class="line">dev:结合 grep 搜索包名</span><br><span class="line">$ adb shell pm list package | grep -i z</span><br><span class="line">package:ru.zdevs.zarchiver</span><br><span class="line"></span><br><span class="line">查询进程优先级</span><br><span class="line">adb shell dumpsys meminfo</span><br></pre></td></tr></table></figure>

<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gradle</span><br><span class="line">查看主要的任务</span><br><span class="line">./gradlew tasks </span><br><span class="line">查看所有任务，包括缓存任务</span><br><span class="line">./gradlew tasks --all</span><br><span class="line">调试模式构建并打印堆栈日志</span><br><span class="line">./gradlew build --info --debug --stacktrace</span><br></pre></td></tr></table></figure>

<h2 id="bundletool"><a href="#bundletool" class="headerlink" title="bundletool"></a>bundletool</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Linux-Android"><a href="#Linux-Android" class="headerlink" title="Linux - Android"></a>Linux - Android</h2><p>1、查看 CPU 详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>Android卡顿优化-前章</title>
    <url>/2021/09/07/Android%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96-%E5%89%8D%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Android存储路径更新(前章)</title>
    <url>/2021/09/06/Android%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote>
<ul>
<li>作者：青蛙要fly<br>来源：<a href="https://juejin.cn/post/6844903566113505293#heading-1">掘金</a><br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ul>
</blockquote>
<h1 id="什么是适配"><a href="#什么是适配" class="headerlink" title="什么是适配"></a>什么是适配</h1><p>摘录 ==&gt; <strong>重学安卓：豁然开朗 存储访问 适配解析</strong> </p>
<blockquote>
<p>当我们提起适配的时候，我们是在说什么<br>在思考 “为什么要适配存储访问” 之前，我们先来确认一下，当我们提起适配的时候，我们到底是在说什么 —— 为什么是 “适配”，为什么不是 “改进” 或 “升级” 呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为这是一种 历史包袱：适配涉及的是 对已停止维护的老系统的 兼容，以及对新系统新设计的 API 的 支持。</span><br></pre></td></tr></table></figure>

<h1 id="Google-为什么要强制适配"><a href="#Google-为什么要强制适配" class="headerlink" title="Google 为什么要强制适配"></a>Google 为什么要强制适配</h1><p>适配通常是出于 隐私安全、硬件匹配 等因素的考虑。硬件匹配，比如这些年 Android 的 “刘海屏状态栏、折叠屏页面重建、全面屏手势” 等等；</p>
<p>而我们今天所谈存储及主要涉及的是 隐私安全，尤其国内盗取用户信息已经成为了常态，而这可以大大提高我们作为用户的安全和隐私保护度。</p>
<p>我们这里再细节一点深究 Android10 的分区存储的强制适配的原因，是因为Android的外部目录，即使App卸载了，原本遗留在该目录下的文件依然存在，这就很容易被被有心之人盯上，所以这是Google开启分区存储的主要原因。</p>
<h1 id="存储访问以及适配"><a href="#存储访问以及适配" class="headerlink" title="存储访问以及适配"></a>存储访问以及适配</h1><blockquote>
<p>“存储访问”主要是从“效率和复用的角度出发”，透过缓存来提上效率，降低服务器的负担，透过 持久化存储 来实现媒体数据的复用</p>
</blockquote>
<blockquote>
<p>“存储访问适配”的主要是从“保护用户隐私”出发，透过新的传输机制，来确保本App的私密空间不被越界和泄露</p>
</blockquote>
<h2 id="为什么要适配存储访问"><a href="#为什么要适配存储访问" class="headerlink" title="为什么要适配存储访问"></a>为什么要适配存储访问</h2><p>接收和发送中的细节。主要的关键就是”缓存“。</p>
<ul>
<li>收发</li>
</ul>
<ul>
<li><p>收</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.向服务端发起请求，</span><br><span class="line"></span><br><span class="line">2.收到响应结果，展示到界面（数据在 “内存 RAM” 中），并 缓存一份数据到私有目录（数据被持久化存储到 “闪存 ROM” 中），</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>发</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在内存中编辑数据，点击按钮提交，</span><br><span class="line"></span><br><span class="line">2.提交时，会先展示结果到界面、并且 缓存一份数据到私有目录，同时再提交给服务端，</span><br></pre></td></tr></table></figure>

<p>1.从”效率到平衡“</p>
<p>1.1 对手机来说，有了缓存，下次再加载已经访问的内容时，可以直接从本地调取，而无需重新下载，对app的性能是很大的提高，节省了 时间，流量，电量。</p>
<p>本地闪存速度 300MB/s以上 &gt; https 请求有几十毫秒的延迟。<br>并且 https 请求涉及 加解密，大量的https 请求意味着大量的运算，损失电量。</p>
<p>1.2 对服务端来说，客户端缓存存在，使得服务器的”超高并发“有所缓减，大幅度降低网络拥堵和服务器奔溃。</p>
<p>2.从”复用到隐私“</p>
<h2 id="Android10-Q-—分区存储的由来"><a href="#Android10-Q-—分区存储的由来" class="headerlink" title="Android10(Q)—分区存储的由来"></a>Android10(Q)—分区存储的由来</h2><p>在 Android 版本的不断升级更替中，Google团队对存储目录操作的限制也是越来越严格。<br>至于为什么要限制，其实是有迹可循的。第一点是出于用户安全数据的保护，Android (Q)10 之前，Android的文件存储现象就像个垃圾桶，只要app取得了存储空间的读写权限，WRITE_EXTERNAL_STORAGE，就可以肆意创建文件，难以管理。<br>用户体验也特别差，打开文件管理器，会发现，想找个具体的文件根本无从下手。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Android = 10(Q)  新增了分区存储的概念，targetSdkVersion == 29  </span><br><span class="line">Android &gt; 10(Q)  强制开启分区存储的概念，targetSdkVersion &gt;= 30</span><br><span class="line">// 这里我们在罗列上一些开发的细节</span><br><span class="line"></span><br><span class="line">当targetSdk &lt;= 28时，应用使用传统存储方式；</span><br><span class="line">当targetSdk &lt;= 29时，可以通过在应用清单的application标签中添加android:requestLegacyExternalStorage=&quot;true&quot; ，从而关闭分区存储功能，继续使用传统访问方式。</span><br><span class="line">当targetSdk &gt;= 30时，Android会强制执行分区存储，无法关闭。可以通过Environment.isExternalStorageLegacy() 判断应用存储的运行方式，true表示以传统的兼容方式运行，false表示以分区存储运行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="科普-targetSdkVersion"><a href="#科普-targetSdkVersion" class="headerlink" title="科普 - targetSdkVersion"></a>科普 - targetSdkVersion</h2><p>在开发中targetSdkVersion到底是啥含义？</p>
<h2 id="Android手机的存储"><a href="#Android手机的存储" class="headerlink" title="Android手机的存储"></a>Android手机的存储</h2><ul>
<li>安卓设备的物理存储针对app可以分为两大块，内部存储和外部存储(而外部存储包含了私有目录和共享目录)</li>
</ul>
<p>内部存储：</p>
<ul>
<li>内部存储  </li>
</ul>
<ul>
<li>  /data/<pre><code>     /app/ : apk
     /data/ : package:sp,data,webview-cash
</code></pre>
</li>
<li><pre><code>/system/
</code></pre>
</li>
<li><pre><code>/cache/
</code></pre>
</li>
</ul>
<p>/data/data/ : 设备中每一个安装的 App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹，这个文件夹也用来存放SharedPreferences 和 SQLiteDatabase 的数据， App 中的 WebView 缓存页面信息也在这文件夹下。</p>
<p>Android 6.0以上的手机或者模拟器该路径可能为： /data/data/ 变为 /data/user/0</p>
<p>当app被卸载的时候，这个文件夹 会被删除掉。</p>
<p>开发过程中，可通过 Context对象提供的 API 读取操作 内部存储中的文件</p>
<p>强烈建议大家开发的手机尽量Root或者使用64位的模拟器 👍🏻,可以对整体目录有个清晰了解。</p>
<p>为了帮助大家更好的理解，请看这这张脑图，对于开发和理解应该是够用了。</p>
<p><img src="android%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8.awebp" alt="android内部存储-1"><br><img src="android%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A82.awebp" alt="android内部存储-2"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * Environment.getDataDirectory() : /data</span><br><span class="line">    * context.getFilesDir() : /data/user/0/com.e.dk_wd/files</span><br><span class="line">    * context.getCacheDir() : /data/user/0/com.e.dk_wd/cache</span><br><span class="line">    * context.getDataDir() : /data/user/0/com.e.dk_wd</span><br><span class="line">*/</span><br><span class="line">    Log.i(&quot;----&quot;, &quot;Environment.getDataDirectory() : &quot; + Environment.getDataDirectory().absolutePath)</span><br><span class="line">    Log.i(&quot;----&quot;, &quot;context.getFilesDir() : &quot; + this.filesDir!!.absolutePath)</span><br><span class="line">    Log.i(&quot;----&quot;, &quot;context.getCacheDir() : &quot; + this.cacheDir!!.absolutePath)</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        Log.i(&quot;----&quot;, &quot;context.getDataDir() : &quot; + this.dataDir!!.absolutePath)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果你想看app的看存储的话，提前root，或者你用模拟器打开即可。</p>
<p>外部存储：</p>
<p>现在的手机基本上都是内置了 <strong>SD</strong> 卡，同时也提供 <strong>SD 卡的拓展</strong>。<br>所说的外部存储，就是手机设备内置的 SD卡 和 扩展的SD卡 提供的存储空间<br>外部存储 也会为 安装的app 提供一块区域（文件夹） ，用来存放私有的文件<br>通常的路径是：**/storage/emulated/0/Android/data/包名/**</p>
<p>这里提供一下获取方式:</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_ALARMS)</td>
<td align="center">/storage/sdcard0/Alarms</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_DCIM)</td>
<td align="center">/storage/sdcard0/DCIM</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)</td>
<td align="center">/storage/sdcard0/Download</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_MOVIES)</td>
<td align="center">/storage/sdcard0/Movies</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_MUSIC)</td>
<td align="center">/storage/sdcard0/Music</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_NOTIFICATIONS)</td>
<td align="center">/storage/sdcard0/Notifications</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_PICTURES)</td>
<td align="center">/storage/sdcard0/Pictures</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_PODCASTS)</td>
<td align="center">/storage/sdcard0/Podcasts</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_RINGTONES)</td>
<td align="center">/storage/sdcard0/Ringtones</td>
</tr>
</tbody></table>
<h3 id="分区存储概览"><a href="#分区存储概览" class="headerlink" title="分区存储概览"></a>分区存储概览</h3><p>这里我们先看一张图，先大概有个概念</p>
<p><img src="%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95.awebp" alt="分区存储"></p>
<p>Android存储的改变基本上遵循了3个原则:<br>更好的从属性: 系统知道哪些文件属于哪些应用，这可以让用户更方便地管理他们的文件。当应用被卸载后，除非用户需要，否则应用之前所创建的文件也不应该保留在设备上；<br>保护应用数据: 当一个应用将 它所属的文件 写入外部存储时，这些文件是不应该被其他应用所访问的；<br>保护用户数据: 当用户下载了一些文件，比如带有敏感信息的邮件附件，这些文件应该对其他应用不可见。  </p>
<p>Android10分区存储对<strong>外部存储</strong>重新进行了设计</p>
<ul>
<li>私有存储 (Private Storage) : 每个应用在都拥有自己的私有目录，其它应用看不到，彼此也无法访问到该目录：内部存储私有目录 (/data/data/packageName) ；外部存储私有目录 (/sdcard/Android/data/packageName)，</li>
<li>共享存储 (Shared Storage) : 存储其他应用可访问文件， 包含媒体文件、文档文件以及其他文件，对应设备DCIM、Pictures、Alarms、Music、Notifications、Podcasts、Ringtones、Movies、Download等目录<h4 id="私有存储"><a href="#私有存储" class="headerlink" title="私有存储"></a>私有存储</h4>应用私有目录文件访问方式与之前Android版本一致，可以通过file path获取资源。<br>这里有个细节点，访问app自身外部私有目录是不需要要任何权限的。  </li>
</ul>
<p><strong>需要注意的不同点是：开启了分区存储特性后，应用只能访问自身的私有空间，即使获得了存储权限，也无法访问其他应用的私有空间</strong></p>
<h2 id="番外篇-–-FileProvider-的存在缘由和适配"><a href="#番外篇-–-FileProvider-的存在缘由和适配" class="headerlink" title="番外篇  – FileProvider 的存在缘由和适配"></a>番外篇  – FileProvider 的存在缘由和适配</h2><p>FileProvider 适配前的混沌世界。<br>FileProvider 实际上是 Android 4.4 时期便存在的设计，它被强制适配是发生在 Android 7.0。</p>
<p>关于 FileProvider，官方文档 有过这样一段描述：</p>
<p>“每当别的 App 透过 File Uri 来访问你 App 的私有文件时，为了达成访问，需要从底层文件系统将访问权限开放，并且直到权限被收回前，其他任意 App 都是可以访问的。”</p>
<p>如何理解这段话含义？</p>
<p>笔者认为，上述描述中没有提及 “权限被收回的时机”，因而隐含的关键信息是 “时机不可控 和 作用域不受限”，也即，当下虽然只是你 AppA 和 AppB 之间的文件传输，但这文件传输的达成，需要从底层文件系统更改权限，</p>
<p>这就好比，你和朋友约好下午 3 点来你家玩，本来你只须到点开个小窗守着朋友的到来，可你却把自家 前门 后门 左门 右门 统统打开了，这让路过的小偷得以 趁虚而入、盗走他想要的东西。</p>
<p>FileProvider 是如何解决这问题的<br>很简单，既然 通过 File Uri 访问，涉及底层文件系统访问权限的修改，那改用别的方式便是 —— 通过 Content URI 访问。</p>
<p>这是一种类似于 Web 开发的 “虚拟目录映射” 的设计，通过 Content URI，系统会自动呈现实际路径中的内容，就和你直接通过实际路径访问到的结果是一样的，唯一的区别在于，使用 Content URI 无需开启 “底层文件系统权限”，且 FileProvider 在此基础上增加了“只需授予 运行时级别 临时权限”的设计，如此你俩在传输文件时，潜伏的 App 无法趁虚而入，且 在对方与传输相关的 Activity 离开栈顶或 Service 停止运行后，权限便及时作废。</p>
<p>划重点 👆 👆 👆</p>
<p>提示：运行时权限的特质是，只针对被授予的进程，而非对所有进程无差别开放</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Apk安装的流程(前章)</title>
    <url>/2021/08/20/Android-Apk%E5%AE%89%E8%A3%85%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>最近自己又去阅读了Android源码，感觉以前有些困惑清晰了不少。<br>android源码庞大而复杂，一个源文件文件少则都是几千行代码。抓住核心很重要，那么多API的调用链根本记不完，不能一窥全貌，就只能迷失在森林之中，其实重要的是去梳理流程，搞清楚这个模块的设计初衷是为了什么，如果让你自己来你会怎么设计，如何写出高质量的代码。<br>思维上的提高才是本质上的进步！！！</p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>APK安装的方式其实有很多种，网上也有很多好的文章，不过学会才是最重要的，做出我们自己的总结。<br>从2021 年 8 月起 新应用需要使用 Android App Bundle 才能在 Google Play 中发布(<a href="https://developer.android.com/guide/app-bundle">Android ABB</a>)，在加上国内华为也支持了该ABB形式文件上架应用，后面也兴会成为主流。</p>
<p>关于相关的 Android App Bundle的知识可以点击这里<a href="https://zhupengbo.com/2021/07/19/google-aab/">🏷</a>)</p>
<h1 id="APK安装的方式"><a href="#APK安装的方式" class="headerlink" title="APK安装的方式"></a>APK安装的方式</h1><p>本章节只讲大致流程，代码流程我们后面再慢慢梳理</p>
<ul>
<li>安装方式</li>
</ul>
<ul>
<li>1.系统应用和预制应用的安装</li>
<li>2.通过商店</li>
<li>3.Adb</li>
<li>4.通过SD卡</li>
</ul>
<h1 id="🏷-科普"><a href="#🏷-科普" class="headerlink" title="🏷 科普"></a>🏷 科普</h1><h2 id="Android科普"><a href="#Android科普" class="headerlink" title="Android科普"></a>Android科普</h2><p><a href="https://blog.csdn.net/qq_28193019/article/details/102880179">安装目录的基本知识</a></p>
<p>既然是APK安装,有输入点就有输出点，所以就会有对应的目录，每个不同的目录存放这对应的文件。  </p>
<!-- | Class |     Name  | 
|:------------- |:---------------:|  -->

<table>
<thead>
<tr>
<th align="left">目录</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/system/app</td>
<td align="center">系统自带的应用程序,获得 root 权限才能删除</td>
</tr>
<tr>
<td align="left">/data/app</td>
<td align="center">第三方应用apk文件.安装时把apk文件复制到此目录</td>
</tr>
<tr>
<td align="left">/data/anr</td>
<td align="center">存放anr信息（/data/anr/traces.txt用于存放app ANR信息）</td>
</tr>
<tr>
<td align="left">/data/data</td>
<td align="center">应用程序数据</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}</td>
<td align="center">特定应用程序数据目录</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/cache</td>
<td align="center">临时文件，系统会自动清理</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/databases</td>
<td align="center">数据库</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/files</td>
<td align="center">一般文件</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/shared_pres</td>
<td align="center">SharedPreference</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/lib</td>
<td align="center">so文件</td>
</tr>
<tr>
<td align="left">/data/dalvik-cache</td>
<td align="center">存放odex文件.将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,ART模式的可执行文件格式为.aot,启动ART时,系统会执行dex文件转换至aot文件)</td>
</tr>
<tr>
<td align="left">/data/system/packages.list</td>
<td align="center">类似于Window的注册表,该文件是解析apk时由writeLP()创建的。记录了系统的permissons,以及解析apk的AndroidManifest获取的应用name,codePath,flag,ts,version,userid等信息。解析完apk后将更新信息写入这个文件并保存到flash,下次开机的时候直接从里面读取相关信息并添加到内存相关列表中.当有apk升级,安装或删除时会更新这个文件。</td>
</tr>
<tr>
<td align="left">/data/system/packages.xml</td>
<td align="center">指定应用的默认存储位置/data/data/com.xx.xx/package.xml中包含了该应用申请的权限,签名和代码所在的位置等信息系,并且两者都有同一个userld.</td>
</tr>
<tr>
<td align="left">/data/user/0</td>
<td align="center">软链接，指向/data/data</td>
</tr>
<tr>
<td align="left">/data/user_de/0/${package_name}</td>
<td align="center">设备存储保护区，在快速启动模式可以访问这个文件夹</td>
</tr>
<tr>
<td align="left">/proc/cpuinfo</td>
<td align="center">cpu信息</td>
</tr>
<tr>
<td align="left">/proc/smaps</td>
<td align="center">内存占用信息</td>
</tr>
<tr>
<td align="left">/sdcard</td>
<td align="center">软链接，最终指向/storage/emulated/0【跟Android版本和ROM版本有关】</td>
</tr>
<tr>
<td align="left">/storage/emulated/0</td>
<td align="center">外部存储的根目录</td>
</tr>
<tr>
<td align="left">/storage/emulated/0/Android/data/${package_name}</td>
<td align="center">应用的额外数据</td>
</tr>
<tr>
<td align="left">/system/app</td>
<td align="center">系统应用apk文件</td>
</tr>
<tr>
<td align="left">/system/lib</td>
<td align="center">系统应用so库</td>
</tr>
<tr>
<td align="left">————————————————</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>在/data/data/包名目录下，每个app都有自己的目录，目录名就是应用程序在AndroidManifest.xml文件中定义的包。每个应用程序的代码，对自己的目录是有绝对的控制权限的。在每个目录下，一般有如下几个子目录（结合上面的表格）：</p>
<p>databases : 存放数据库<br>cache : 存放缓存数据<br>files : 存放应用程序自己控制的文件<br>lib : 存放使用的包</p>
<h2 id="Linux科普"><a href="#Linux科普" class="headerlink" title="Linux科普"></a>Linux科普</h2><p>为什么这里需要了解Linux的知识点，<br>Linux进程有两个ID，一个就是用户ID，为每个用户的唯一标识符；<br>另一个是组ID，为用户组的唯一标识符</p>
<p>当你在手机点击一个APK之后,APK中的AndroidManifest.xml会被解析,在手机root之后，或者用模拟器打开根目录 <strong>/data/system/</strong> ，我们获得超级权限之后，可以在查看目前手机在系统已经注册的app，解析的内容会被存储到 <strong>/data/system/packages.xml</strong> 和 <strong>/data/system/packages.list</strong> 中。我们打开packages.list和packages.xml，我们已Apk的包名为索引，可以看到对应的内容。</p>
<p>packages.list</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.game.dalan2.s3 10130 1 /data/user/0/com.game.dalan2.s3 default 3003</span><br></pre></td></tr></table></figure>

<p>packages.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;package name=&quot;com.game.dalan2.s3&quot; codePath=&quot;/data/app/com.game.dalan2.s3-1&quot; nativeLibraryPath=&quot;/data/app/com.game.dalan2.s3-1/lib&quot; primaryCpuAbi=&quot;x86&quot; publicFlags=&quot;940097350&quot; privateFlags=&quot;0&quot; ft=&quot;17b8267bd90&quot; it=&quot;17b586694ad&quot; ut=&quot;17b8267cb67&quot; version=&quot;1&quot; userId=&quot;10130&quot;&gt;</span><br><span class="line">     &lt;sigs count=&quot;1&quot;&gt;</span><br><span class="line">         &lt;cert index=&quot;9&quot; key=&quot;忽略&quot; /&gt;</span><br><span class="line">     &lt;/sigs&gt;</span><br><span class="line">     &lt;perms&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.INTERNET&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">         &lt;item name=&quot;android.permission.ACCESS_WIFI_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">     &lt;/perms&gt;</span><br><span class="line">     &lt;proper-signing-keyset identifier=&quot;147&quot; /&gt;</span><br><span class="line"> &lt;/package&gt;</span><br></pre></td></tr></table></figure>

<p>packages.list中指名了该应用默认存储的位置<br>packages.xml中包含了该应用申请的权限、签名和代码所在位置等信息，并且两者都有一个userId为10060。  </p>
<p>之所以每个应用都有一个userId，是因为Android在系统设计上把每个应用当作Linux系统上的一个用户对待，这样就可以利用已有的Linux上用户管理机制来设计Android应用，比如应用目录，应用权限，应用进程管理等。</p>
<p>这个解析的过程也可以理解为在APK在系统的注册。</p>
<p>相关知识点可以查看这里 <a href="https://stackoverflow.com/questions/12442979/android-understanding-the-apk-installation-process">Stack Overflow</a></p>
<h1 id="Apk安装的流程"><a href="#Apk安装的流程" class="headerlink" title="Apk安装的流程"></a>Apk安装的流程</h1><p>这里大致只讲流程，详细的代码我们后面再一一罗列出来:<br>简单来说分为四步：</p>
<p>1)将APK的信息通过IO流的形式写入到PackageInstaller.Session中。</p>
<p>2)调用PackageInstaller.Session的commit方法，将APK的信息交由PKMS处理。</p>
<p>3)拷贝APK</p>
<p>4)最后进行安装</p>
<h1 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h1><h2 id="什么是覆盖安装-？"><a href="#什么是覆盖安装-？" class="headerlink" title="什么是覆盖安装 ？"></a>什么是覆盖安装 ？</h2><p>无论在国内还是出海国外上架海外游戏App，我们在每次上架新版本的时候，都是需要<strong>versionCode</strong>+1,用户再通过商店渠道再把 versioncode+1的apk覆盖掉原先的apk,这个过程就是覆盖安装，。<br>不过还是有前置条件：<br>    1.包名跟旧的一致<br>    2.签名跟原来的一致<br>    3.组件不冲突</p>
<p>更详细的内容看这张表：</p>
<table>
<thead>
<tr>
<th align="left">正常安装</th>
<th align="center">覆盖安装</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">删除旧版本APK之后重新进行安装</td>
<td align="center">（不删除之前的旧版本包，直接安装）</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SQLite的数据也会被删除</td>
<td align="center">SQLite的数据不会丢失</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">shared_prefs中的数据会被删除</td>
<td align="center">shared_prefs中的数据不会丢失</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4.4之前的版本不会比较apk的Version_code</td>
<td align="center"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？"><a href="#部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？" class="headerlink" title="部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？"></a>部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？</h2><p>首先要清除对应的安装包，就得知道安装包的目录是在哪，计算机的世界有入口就有出口。<br>我们这里在做一些知识的扩展：<br>现在部分手机的App是具有分享Apk的功能，也就是传输本机上的apk，比如说QQ，还有一些第三方的软件具备之类的功能。手机安装app时，会在根目录和外存储器合生成文件夹。反过来说，你删除app的时候，这些对应生成文件夹也会被系统删除。根目录会放置app的安装包，而且统一命名为base.apk，还有一些重要的app用户数据。(你想查看，前提是开启root)<br>外存储器就是你能看到的文件夹，里面放置可操作的文件，例如保存的图片，视频。所以即使你安装app后删除安装包，也是删除了外存储器的安装包，QQ传输app安装包就是传输<strong>根目录</strong>的安装包。</p>
<h2 id="Android目录扫盲"><a href="#Android目录扫盲" class="headerlink" title="Android目录扫盲"></a>Android目录扫盲</h2><p>关于存储的目录，我们后面额外再开一张新的文章，android对于目录和权限其实做了不少的修改。<br>接下来这段是很多Code的误区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Environment.getExternalStorageDirectory()</span><br></pre></td></tr></table></figure>
<p>实际上是获取的手机自带的sd卡，这个自带的sd卡你在手机的文件管理应用里看，显示的中文名是“内部存储”，这个“内部存储”实际上就是手机自带的sd卡，也就是ExternalStorage</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发篇-1</title>
    <url>/2021/08/13/Java-%E5%B9%B6%E5%8F%91%E7%AF%87-1/</url>
    <content><![CDATA[<p><a href="https://www.zhihu.com/question/22950899">https://www.zhihu.com/question/22950899</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Activity</title>
    <url>/2021/08/11/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>在最近的任务栈里面看见的task未必还活着。<br>在最近的任务栈里面看不见的task未必就死了。</p>
<h2 id="android-launchMode"><a href="#android-launchMode" class="headerlink" title="android-launchMode"></a>android-launchMode</h2><p>在这里我推荐大家去看扔物线的课程: <a href="https://www.bilibili.com/video/BV1CA41177Se">Android 面试黑洞</a></p>
<p>Activity有4种启动模式，分别是：Standard、SingleTop、SingleTask和SingleInstance，它们控制了被启动Activity的启动行为。<br>Activity任务栈（Task）是一个标准的栈结构<br>用于在ActivityManagerService侧管理所有的Activity（AMS通过TaskRecord标识一个任务栈，通过ActivityRecord标识一个Activity）。</p>
<table>
<thead>
<tr>
<th align="left">launchMode</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE【知识扩展】</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Standard</td>
<td align="center">标准模式</td>
<td align="left">标准模式，也是系统的默认模式。该模式下，每次启动Activity，都会创建一个新实例，并且将其加入到启动该Activity的那个Activity所在的任务栈中，所以目标Activity的多个实例可以位于不同的任务栈。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SingleTop</td>
<td align="center">栈顶复用模式</td>
<td align="left">该模式下，若目标Activity的实例已经存在，但是没有位于栈顶，那么仍然会创建新的实例，并添加到任务栈；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SingleTask</td>
<td align="center">栈内复用模式</td>
<td align="left">clearTop的作用，整个任务栈只能有一个activity的实例。</td>
<td align="left">如果此时任务栈内已经存在 Activity C 的实例且未位于栈顶，当启动 Activity C 时，会将 Activity C 上方的实例全部出栈让其位于任务栈顶并 Activity C 中的 onNewIntent() 方法会被调用</td>
</tr>
<tr>
<td align="left">SingleInstance</td>
<td align="center">单一实例</td>
<td align="left">要求该Activity所在的Task只有有这么一个Activity，</td>
<td align="left">下面没有旧，上面没有新</td>
</tr>
</tbody></table>
<h2 id="MORE【知识扩展】"><a href="#MORE【知识扩展】" class="headerlink" title="MORE【知识扩展】"></a>MORE【知识扩展】</h2><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><p>当我们使用Application的Context来启动一个Activity的时候，会报AndroidRuntimeException，因为standard模式下启动的Activity，会默认进入启动它的Activity的任务栈中，而非Activity类型的context却并没有所谓的任务栈，所以就会出现问题，解决这个问题的方法是需要为要启动的Activity指定标记位：FLAG_ACTIVITY_NEW_TASK，这个标记的作用是为启动的Activity创建一个新的任务栈。</p>
<h3 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h3><p>该模式下，若目标Activity的实例已经存在，但是没有位于栈顶，那么仍然会创建新的实例，并添加到任务栈；</p>
<p>若目标Activity的实例已经存在，且位于栈顶，那么就不会创建新的实例，而是复用已有实例，并依次调用目标Activity的onPause -&gt; onNewIntent -&gt; onResume方法。<br>知识扩展！！！</p>
<p>singleTop模式的activity特点就是除了外部可以启动它显示信息外，它也可以用同样的方式启动自己更新显示信息，这样就减少了冗余代码，降低了维护成本。</p>
<p>他的onCreate、onStart方法不会被调用，避免多次初始化，应用宝用的就是这套方案。</p>
<h3 id="SingleTask-A和B都是不同的2个应用"><a href="#SingleTask-A和B都是不同的2个应用" class="headerlink" title="SingleTask A和B都是不同的2个应用"></a>SingleTask A和B都是不同的2个应用</h3><p>首先做个假设：A-Activity 启动 B_Activity,launchMode下文进行了标注<br>A_Activity[Standard] ==&gt; B_Activity[SingleTask]<br>B_Activity的Activity被启动时，不会进入启动A的Task里,而是创建属于B自己的Task里，置于B-Task栈顶,然后把整个B-Task 压到 A-Task上面,这种方式打开的方式是入场动画是应用间的切换。</p>
<p>如果这时按下返回键，这里回退的顺序是 B-Task 来回退，而不是返回原来的A_Activity[Standard]。原来的A要在前台显示，必须是B-Task的栈的Activity完全关闭才可以，这里场景动画也是场景间的切换。  </p>
<p>这里要明确一个概念：不止应用的Activity内部可以叠成栈，不同应用之间的Task也可以叠成栈。</p>
<p>Task的叠加只适用于前台的Task。</p>
<p>SingleTask是保证了一个栈内有且只有被该属性修饰Activity的实例对象，全局单例</p>
<h3 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h3><p>为了描述清晰，我们还是要举个例子:<br>A_Activity[Standard] ==&gt; B_Activity[SingleInstance]<br>还是 A 短信应用 打开 B 邮箱应用<br>邮件App不仅为了当前跳转的Activity创建对象，而且会创建一个单独的B-Task,然后把当前的打开应用的Activity的实例放到B-Task。<br>第二种情况是当前Activity已经被创建过了，则会回调当前应用的Activity生命周期的**onNewIntent()**方法</p>
<p>这2种情况的变化，这个B-Task都会被拿过来压在A-Task上面，入场动画是切换Task的动画。</p>
<p>假设用户这个时候点返回，上面的Task因为只有一个Activity，手机会直接回到短信App，入场动画是切换Task的动画。</p>
<p>假设用户没有直接点返回，而是选择查看了最近的任务又返回到之B-Task，这个时候短信的A-Task已经被退到后台，所以用户再点返回的话，又因为当前的Task内只有一个B-Activity，所以是直接回退到桌面。</p>
<p>假设用户又没有点返回，也没有选择查看任务，而是选择了在B-Task，又打开了一个C-App的Activity，由于SingleInstance的限制，所以C-task并不会叠在B-Task之上，而是另辟蹊径，而是装到另一个Task中，然后整个Task跌在B-Task上面。</p>
<p>知识点: 我来解释一下另辟蹊径的意思，这个时候相对邮箱App此时有2个Task，一个是独栈的，也就是短信调用的那个，还有一个是后台的Task，C的Activity是被放到了后台的Task。</p>
<blockquote>
<p>在最近的任务栈里面看不见的task未必就死了。这句话也是在这里体现。<br>在延伸出一个属性:Android:taskAffinity，</p>
</blockquote>
<h2 id="Android-taskAffinity属性"><a href="#Android-taskAffinity属性" class="headerlink" title="Android:taskAffinity属性"></a>Android:taskAffinity属性</h2><blockquote>
<p>在android里，一般情况下一个App默认只有一个Task，可以显示在最近的列表里面，但是用来甄别唯一性的不是App，而是<strong>taskAffinity</strong>，每一个Activity都有属于自己的Activity，相当于每个Activity的预先分组。<br><img src="taskAffinity%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99.png" alt="taskAffinity"><br>android:taskAffinity是Activity的一个属性，表示该Activity期望的任务栈的名称。<br>默认情况下，一个应用程序中所有Activity的taskAffinity都是相同的，即应用程序的包名。当然，我们可以在配置文件中为每个Activity指定不同的taskAffinity（只有和已有包名不同，才有意义）。<br><img src="taskAffinity%E6%9C%80%E8%BF%91%E5%88%97%E8%A1%A8.png" alt="taskAffinity"><br>另外每一个Task也有taskAffinity，他的值取自栈底的Activity的taskAffinity值，这个栈底Activity也就是第一个启动应用的Activity。</p>
</blockquote>
<p>另外一点taskAffinity也可以在androidManifest被定制。<br><img src="taskAffinity%E5%BC%80%E5%8F%91%E6%8E%A8%E8%8D%90.png" alt="taskAffinity">  </p>
<p>一般情况下，该属性主要和SingleTask启动模式或者android:allowTaskReparenting属性结合使用（下面会详细介绍），在其他情况下没有意义。</p>
<h3 id="Task-Reparenting"><a href="#Task-Reparenting" class="headerlink" title="Task - Reparenting"></a>Task - Reparenting</h3><p>B AndroidManifest属性 设置为android:allowTaskReparenting = True</p>
<p>场景具体化:A 短信应用 打开 B 邮箱应用</p>
<p>B还是会进入到A的Task里,但稍后用户从桌面点击B应用的时候，原先放在A-Task里面的B-Activity会被挪到B应用的Task的栈顶,这个时候你在切回短信Task，你会发现原先的B-Activity已经不见了。<br>(有争议… Android 8,9是有问题的，10以上正常)</p>
<h3 id="前台Task"><a href="#前台Task" class="headerlink" title="前台Task"></a>前台Task</h3><p>前台叠加的多个Task进入后台第一时间就会拆开</p>
<blockquote>
<p>1.按Home键回到桌面<br>2.按最近任务键 查看最近的任务  </p>
<ul>
<li>前台Task 在最近列表显示出来的时候就已经进入到了后台，而不是切到其他任务之后。</li>
</ul>
</blockquote>
<p>但是光知道理论还是不够的，由于我们开发的时候大部分的情况都是多变的，我们在前面的章节可以了解到不同的应用的Activity是启动Task内叠加的。</p>
<p>首先做个假设：A-Activity 启动 B_Activity,launchMode下文进行了标注<br>A_Activity[Standard] ==&gt; B_Activity[SingleTask]<br>我们再把场景具体化，A 短信应用 打开 B 邮箱应用，这个时间我们没有按下返回键，而是按最近任务键，再重新回去原来的Task，这个时候看起来没有变化，但是实际上A的Task已经被去除掉了，只留下B的Task，这个时候我们再按下返回键，把B的Task内的Activity全部关闭，这个时候返回的系统的桌面而不是短信的APP。</p>
<h2 id="Android十万个为什么系列"><a href="#Android十万个为什么系列" class="headerlink" title="Android十万个为什么系列"></a>Android十万个为什么系列</h2><h3 id="当前-app-正在前台运行，不在栈顶的-Activity-有可能会因为系统资源，例如内存等不足回收吗？"><a href="#当前-app-正在前台运行，不在栈顶的-Activity-有可能会因为系统资源，例如内存等不足回收吗？" class="headerlink" title="当前 app 正在前台运行，不在栈顶的 Activity 有可能会因为系统资源，例如内存等不足回收吗？"></a>当前 app 正在前台运行，不在栈顶的 Activity 有可能会因为系统资源，例如内存等不足回收吗？</h3><p>我现在还记得这个问题，那年我毕业，投了心仪公司的简历，过了Hr的面试，来到了技术环节，和蔼的面试官问了:我们日常开发比较多组件的是Activity，假设 App 正在前台运行，不在栈顶的Activity有可能会被回收吗?<br>那时年少，我感觉我天灵盖被人开了，当场差点直接自闭，懵逼，接下来回答支支吾吾，面试结果是显而易见的。。。  <strong>(ಥ_ಥ)</strong><br>回去的路上越想越不对劲，到家之后立马查源码，好家伙找到了！平时不看源码，关键时刻被别人搞得一愣一愣！</p>
<p>凡事先说结论: 会 ！！！<br>这里看的源码是API30,在网上也看到一些相关答案答案，这里我们提炼一下要点，重点我们日常开发对场景预测，比方说游戏A-APP开启了一个B-App应用的界面，这个时候B-App开启了一个比较消耗耗内存的线程，如果这个内存不断地增大，最后游戏A-App的生命周期onDestroy()就会被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void attach(boolean system, long startSeq) &#123;</span><br><span class="line">        sCurrentActivityThread = this;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        if (!system) &#123;</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            try &#123;</span><br><span class="line">               //ApplicationThread是ActivityThread和AMS沟通的桥梁</span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            // Watch for getting close to heap limit.</span><br><span class="line">            BinderInternal.addGcWatcher(new Runnable() &#123;</span><br><span class="line">                @Override public void run() &#123;</span><br><span class="line">                    if (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                    long dalvikMax = runtime.maxMemory();</span><br><span class="line">                    long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                    if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123;</span><br><span class="line">                        if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024)</span><br><span class="line">                                + &quot; total=&quot; + (runtime.totalMemory()/1024)</span><br><span class="line">                                + &quot; used=&quot; + (dalvikUsed/1024));</span><br><span class="line">                        mSomeActivitiesChanged = false;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            ActivityTaskManager.getService().releaseSomeActivities(mAppThread);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            throw e.rethrowFromSystemServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="当-app-处于后台运行，app-进程未被杀死，其内部的-Activity-会被回收吗？"><a href="#当-app-处于后台运行，app-进程未被杀死，其内部的-Activity-会被回收吗？" class="headerlink" title="当 app 处于后台运行，app 进程未被杀死，其内部的 Activity 会被回收吗？"></a>当 app 处于后台运行，app 进程未被杀死，其内部的 Activity 会被回收吗？</h3><h3 id="当-app-处于后台运行，app-的进程会被杀死吗？"><a href="#当-app-处于后台运行，app-的进程会被杀死吗？" class="headerlink" title="当 app 处于后台运行，app 的进程会被杀死吗？"></a>当 app 处于后台运行，app 的进程会被杀死吗？</h3>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-进程与线程</title>
    <url>/2021/08/04/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>名词是对客观事物的指代，形容词是对客观事物的描述。</p>
<p>进程和线程又分别是什么? 进程和线程区别到底是什么?<br>带着简单的疑问，我们慢慢往下看看，本文不会过多章节去分析代码，而是比较多去谈自己的理解！</p>
<h1 id="计算机扩展概念"><a href="#计算机扩展概念" class="headerlink" title="计算机扩展概念"></a>计算机扩展概念</h1><p>其实无论是谈生意也好，还是谈工作也好，首先必须要解决一个问题，就是明确主题和双方信息差的问题！<br>为了更好的理解，我们需要了解一些基础的计算机知识(linux)。具体文献请参考原文</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><a href="http://www.linfo.org/cpu.html">CPU</a></h2><blockquote>
<p>A CPU contains three main sections: (1) <strong>an arithmetic/logic unit</strong>, (2) <strong>a control unit</strong> and (3) <strong><a href="http://www.linfo.org/register.html">registers</a></strong>. The arithmetic/logic unit contains circuitry that performs data manipulation. The control unit consists of circuitry for coordinating the machine’s activities. The registers are high speed memory cells that are used for holding instructions for data that is currently being processed.  </p>
</blockquote>
<p>CPU 包含三个主要部分：(1)<strong>算术/逻辑单元</strong>，(2)<strong>控制单元</strong>和 (3)<strong>寄存器</strong>。<br>算术/逻辑单元包含执行数据操作的电路。<br>控制单元由用于协调机器活动的电路组成。<br>寄存器是<strong>高速存储</strong>单元，用于保存当前正在处理的数据的指令。</p>
<h3 id="Register-Definition-—-寄存器"><a href="#Register-Definition-—-寄存器" class="headerlink" title="Register Definition — 寄存器"></a><a href="http://www.linfo.org/register.html">Register Definition</a> — 寄存器</h3><blockquote>
<p>A register is a very small amount of very fast memory that is built into the CPU (central processing unit) in order to speed up its operations by providing quick access to commonly used values.<br>寄存器是非常快又微型的存储器内置于Cpu，是通过访问快速提供的值,已加快Cpu(中央处理单元)的操作</p>
</blockquote>
<p>作用:寄存器是<strong>高速存储</strong>单元，用于保存当前正在处理的数据的指令。</p>
<p>专用寄存器存储内部 CPU 数据，例如程序计数器（也称为指令指针）、堆栈指针和状态寄存器。</p>
<h4 id="寄存器概念扩展"><a href="#寄存器概念扩展" class="headerlink" title="寄存器概念扩展"></a>寄存器概念扩展</h4><p>寄存器是存储器层次结构的顶部，是系统操作数据的最快方式。<br>在它们下面是几个级别的高速缓存，至少其中一些也内置在 CPU 中，而其中一些可能在其他专用芯片上。高速缓存比寄存器慢，但要丰富得多。在不同级别的高速缓存之下是主存储器，它更慢但更丰富（例如，与只有 32 个寄存器相比，数百兆字节）。但反过来，它仍然比存储设备和媒体（例如，硬盘驱动器和 CDROM）快得多，容量也小得多。</p>
<h4 id="其他作用"><a href="#其他作用" class="headerlink" title="其他作用"></a>其他作用</h4><p><strong>指令寄存器</strong>保存CPU正在执行的指令。<br><strong>地址寄存器</strong>保存内存地址，用于访问内存。<br><strong>数据寄存器</strong>用于存储整数。  </p>
<hr>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程是<strong>操作系统</strong>分配资源的最小单位,线程是CPU调度的基本单位,线程之间共享进程资源。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>其实就这么简单的一句话，就可以引申出很多概念。<br>逆向思维(反推)，从已有的结果出发挖掘更多的可能性.  </p>
<blockquote>
<p>到底线程之间共享了哪些进程资源？<br>共享资源意味着什么？<br>共享资源这种机制是如何实现的？<br>线程有哪些是线程私有的  </p>
</blockquote>
<hr>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote>
<p>线程运行的本质就是函数。<br>函数的执行总会有一个源头，这个源头就是所谓的入口函数，相当于java的main的函数，<em>CPU</em> 从入口函数开始执行从而形成一个执行流，只不过我们人为的给执行流起一个名字，这个名字就叫线程。  </p>
</blockquote>
<h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><p>凡事从本质出发，我们就要去分析函数包含了些哪些信息。线程之间既然共享了进程资源，那就会对应不共享的资源，也就是线程私有资源<br>函数运行时的信息包含了栈帧中，栈帧中保存了函数的返回值，调用其他函数的参数，局部变量，该函数的寄存器初始值。  </p>
<p><img src="%E5%87%BD%E6%95%B0%E4%BF%A1%E6%81%AF.jpeg" alt="函数信息"></p>
<p>这里延伸出一个问题，因为线程是可以被操作系统随时暂停运行的和恢复运行的，那是怎么做到的？<br>可以通过保存以及恢复程序计数器的值就可以知道线程的从哪里运行又从哪里开始。</p>
<p>由于每个线程的本质都是函数的运行，函数运行时的信息是保存在栈中的，因此<strong>每个线程都有对应自己独立，私有的栈区</strong></p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%8C%BA.jpeg" alt="线程私有"></p>
<p>同时像函数的局部变量也是存放到寄存器之中，运行完就释放掉，回收内存。</p>
<p>所属线程的栈区，程序计数器，栈指针以及函数运行使用的寄存器都是线程私有的。</p>
<h3 id="线程间的共享"><a href="#线程间的共享" class="headerlink" title="线程间的共享"></a>线程间的共享</h3><h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h4><p>编译后的可执行机器指令,从可执行文件中加载到内存的，可执行程序中的代码区就是用来初始化进程地址空间中的代码区的。</p>
<h4 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h4><p>进程地址空间中的数据区，这里存放的就是所谓的全局变量。<br>全局变量简单的理解，一般不会被系统回收的变量，即使函数执行完后该变量依然存在，对于其他线程也是可见的 </p>
<h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>对象存放的地址空间，可被GC。<br>变量的地址，也就是指针。<br>任何一个线程都可以访问指针指向的数据，因此堆区也是线程共享的属于进程的资源。</p>
<h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>因为线程不像进程，进程是互相隔离，且独立。<br>如果一个线程能拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说这些线程可以任意修改本属于另一个线程栈区中的变量。<br>一个线程的栈区对其它线程是可以见的，也就是说我们可以修改属于任何一个线程的栈区  </p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>如果程序在运行过程中打开了一些文件，那么进程地址空间中还保存有打开的文件信息，进程打开的文件也可以被所有的线程使用，这也属于线程间的共享资源。</p>
<p>如图<br><img src="%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB.jpeg" alt="线程共享"><br>线程共享的地址，除了线程上下文的信息  </p>
<p>对于这个地方，我们引入java虚拟机<br>如图<br><img src="jvm.jpeg" alt="线程共享">  </p>
<p>这里再扩展一下,jdk.1.8.0其实以及取消了方法区,与之对于的是元空间</p>
<ul>
<li>以下jdk1.8 的标准（）<ul>
<li> 移除了永久代（PermGen），替换为元空间（Metaspace）；</li>
<li> 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li>
<li> 永久代中的 interned Strings 和 class static variables 转移到了 Java heap；<br>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize） </li>
</ul>
</li>
</ul>
<p><img src="jdk-1.8.0.png" alt="jdk-1.8.0.png">  </p>
<p>其实以下的概念我们都在上文讲过:</p>
<h3 id="java线程私有："><a href="#java线程私有：" class="headerlink" title="java线程私有："></a>java线程私有：</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>• 程序计数器：<br>    1. 每一个线程都需要有独立的计数器，各个线程互不干扰，独立存储<br>    2. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制<br>    3. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡 </p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>• Java虚拟机栈：<br>• 描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。<br>• 栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。<br>• Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。  </p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>• 本地方法栈<br>• 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。  </p>
<ul>
<li>线程共享:<br>• 堆<br>• 方法区<br>• 直接内存(非运行时数据区）<br>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。<br>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。    </li>
</ul>
<!-- ### Android十万个为什么 
#### Android中的context
很多人面试包括开发，最常遇到的一个名词就是Context，就是android的上下文，但是很多开发者其实不知道Context代表了什么意思，这里我的理解是 (格外提一点 寄存器是多个，不是一个)
> 线程的栈区 + 程序计数器 + 栈指针 + 函数运行使用的寄存器 = 上下文

Android操作系统可以随时中断并且回复正常，依靠的就是线程上下文。

这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了的进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存 -->

<!-- 作者：zhonyong
链接：https://www.zhihu.com/question/25532384/answer/81152571
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统Binder驱动分析(2)</title>
    <url>/2021/07/31/Android%E7%B3%BB%E7%BB%9FBinder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90-2/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我的文章比较多是对自己知识的梳理，有些概念没讲得那么清楚，但会贴出参考的链接，请大家自便</p>
<h1 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote>
<p>IPC : Inter-Process Communication (进程间的通信)<br>RPC : Remote Procedure Call (远程过程调用)<br>RPC是IPC的基础上进行了封装</p>
</blockquote>
<h3 id="简单例子-大致有个概念"><a href="#简单例子-大致有个概念" class="headerlink" title="简单例子: 大致有个概念"></a>简单例子: 大致有个概念</h3><p>再简单的分析下要素 (led是例子)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A(①封装数据 ②发送给B) ===&gt;(IPC) B(①取出数据 @调用数据) </span><br><span class="line">源 : A   </span><br><span class="line">目的 B 先向 ServerManger注册led服务  </span><br><span class="line">    A 向 ServerManger 查询led服务,得到一个Handler  </span><br><span class="line">数据：char_Buff   --&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Binder究竟是什么"><a href="#Binder究竟是什么" class="headerlink" title="Binder究竟是什么#"></a>Binder究竟是什么#</h2><p>Binder是Android系统中负责每个<strong>用户进程</strong>与<strong>内核</strong>通信的驱动模块。 </p>
<h3 id="Binder的优势"><a href="#Binder的优势" class="headerlink" title="Binder的优势"></a>Binder的优势</h3><p><a href="https://blog.csdn.net/universus/article/details/6211589">推荐文章</a><br>主要是基于性能、稳定性和安全性几方面的原因。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><table>
<thead>
<tr>
<th align="left">IPC</th>
<th align="center">数据拷贝次数</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">共享内存</td>
<td align="center">0</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Binder</td>
<td align="center">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Socket</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">管道</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">消息队列</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>Binder 基于 C/S 架构，架构清晰、职责明确又相互独立</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。<br>首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。<br>Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。</p>
<!-- (App UID 可 **packagename** 包名来区分)  -->
<p>传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。<br>可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>以下对比 Binder IPC 对比 传统IPC 的区别</p>
<h3 id="Linux-下的传统-IPC-通信原理"><a href="#Linux-下的传统-IPC-通信原理" class="headerlink" title="Linux 下的传统 IPC 通信原理"></a>Linux 下的传统 IPC <a href="https://zhuanlan.zhihu.com/p/35519585">通信原理</a></h3><p><img src="%E4%BC%A0%E7%BB%9FIPC.jpg" alt="Linux传统 IPC"></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<p>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；<br>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。  </p>
<h2 id="专栏-Android十万个为什么"><a href="#专栏-Android十万个为什么" class="headerlink" title="专栏:Android十万个为什么"></a>专栏:Android十万个为什么</h2><h3 id="什么是实名Binder"><a href="#什么是实名Binder" class="headerlink" title="什么是实名Binder?"></a>什么是实名Binder?</h3><h3 id="什么是匿名Binder？"><a href="#什么是匿名Binder？" class="headerlink" title="什么是匿名Binder？"></a>什么是匿名Binder？</h3><h3 id="“内核缓存区”-和-“数据接收缓存区”-存在的意义"><a href="#“内核缓存区”-和-“数据接收缓存区”-存在的意义" class="headerlink" title="“内核缓存区” 和 “数据接收缓存区” 存在的意义"></a>“内核缓存区” 和 “数据接收缓存区” 存在的意义</h3><p>Linux是使用的虚拟内存寻址方式，虚拟内存需要映射一块真的的物理内存，<br>内核缓存区和数据接收区的映射就是指向了同一块物理内存。接收方下次也可能是发送方，如果共用一块缓存那么岂不是发送方，内核，接收方都指向了同一块物理内存，违反了进程隔离的设计原则。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-崩溃优化</title>
    <url>/2021/07/29/Android-%E5%A5%94%E6%BA%83%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="崩溃优化"><a href="#崩溃优化" class="headerlink" title="崩溃优化"></a>崩溃优化</h1><h2 id="Android-崩溃分析"><a href="#Android-崩溃分析" class="headerlink" title="Android 崩溃分析"></a>Android 崩溃分析</h2><p>Android 崩溃基本分为 <strong>Java 崩溃</strong>和 <strong>Native 崩溃</strong><br>简单来说，Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出。<br>那 Native 崩溃又是怎么产生的呢？一般都是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，<br>这些都会产生相应的 <strong>signal 信号</strong>，导致程序异常退出。</p>
<h3 id="Native-崩溃"><a href="#Native-崩溃" class="headerlink" title="Native 崩溃"></a>Native 崩溃</h3><blockquote>
<ol>
<li>在 Unix-like 系统中，所有的崩溃都是编程错误或者硬件错误相关的，系统遇到不可恢复的错误时会触发崩溃机制让程序退出，如除零、段地址错误等。</li>
<li>异常发生时，CPU 通过异常中断的方式，触发异常处理流程。不同的处理器，有不同的异常中断类型和中断处理方式。</li>
<li>linux 把这些中断处理，统一为信号量，可以注册信号量向量进行处理。</li>
<li>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。  </li>
</ol>
</blockquote>
<h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="signal.png" alt="信号机制"> </p>
<h5 id="1-信号的接收"><a href="#1-信号的接收" class="headerlink" title="(1) 信号的接收"></a>(1) 信号的接收</h5><p>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入<strong>内核态</strong> 。<br>！！！注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<h5 id="2-信号的检测"><a href="#2-信号的检测" class="headerlink" title="(2) 信号的检测"></a>(2) 信号的检测</h5><p>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<p>1.进程从内核态返回到用户态前进行信号检测</p>
<p>2.进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</p>
<p>当发现有新信号时，便会进入下一步，信号的处理。</p>
<h5 id="3-信号的处理"><a href="#3-信号的处理" class="headerlink" title="(3) 信号的处理"></a>(3) 信号的处理</h5><p>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<p>四、捕捉native crash<br>1.注册信号处理函数<br>第一步就是要用信号处理函数捕获到native crash(SIGSEGV, SIGBUS等)。在posix系统，可以用sigaction()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;signal.h&gt; </span><br><span class="line">int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));</span><br></pre></td></tr></table></figure>
<p>signum：代表信号编码，可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号，如果为这两个信号定义自己的处理函数，将导致信号安装错误。</p>
<p>act：指向结构体sigaction的一个实例的指针，该实例指定了对特定信号的处理，如果设置为空，进程会执行默认处理。</p>
<p>oldact：和参数act类似，只不过保存的是原来对相应信号的处理，也可设置为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sigaction sa_old;  </span><br><span class="line">memset(&amp;sa, 0, sizeof(sa));  </span><br><span class="line">sigemptyset(&amp;sa.sa_mask);  </span><br><span class="line">sa.sa_sigaction = my_handler;  </span><br><span class="line">sa.sa_flags = SA_SIGINFO;</span><br><span class="line">if (sigaction(sig, &amp;sa, &amp;sa_old) == 0) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.设置额外栈空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigaltstack(const stack_t *ss, stack_t *oss);</span><br></pre></td></tr></table></figure>
<p>SIGSEGV很有可能是栈溢出引起的，如果在默认的栈上运行很有可能会破坏程序运行的现场，无法获取到正确的上下文。而且当栈满了（太多次递归，栈上太多对象），系统会在同一个已经满了的栈上调用SIGSEGV的信号处理函数，又再一次引起同样的信号。</p>
<p>我们应该开辟一块新的空间作为运行信号处理函数的栈。可以使用sigaltstack在任意线程注册一个可选的栈，保留一下在紧急情况下使用的空间。（系统会在危险情况下把栈指针指向这个地方，使得可以在一个新的栈上运行信号处理函数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack_t stack;  </span><br><span class="line">memset(&amp;stack, 0, sizeof(stack));  </span><br><span class="line">/* Reserver the system default stack size. We don&#x27;t need that much by the way. */  </span><br><span class="line">stack.ss_size = SIGSTKSZ;  </span><br><span class="line">stack.ss_sp = malloc(stack.ss_size);  </span><br><span class="line">stack.ss_flags = 0;  </span><br><span class="line">/* Install alternate stack size. Be sure the memory region is valid until you revert it. */  </span><br><span class="line">if (stack.ss_sp != NULL &amp;&amp; sigaltstack(&amp;stack, NULL) == 0) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.兼容其他signal处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static void my_handler(const int code, siginfo_t *const si, void *const sc) &#123;</span><br><span class="line">...  </span><br><span class="line">  /* Call previous handler. */  </span><br><span class="line">  old_handler.sa_sigaction(code, si, sc);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某些信号可能在之前已经被安装过信号处理函数，而sigaction一个信号量只能注册一个处理函数，这意味着我们的处理函数会覆盖其他人的处理信号</p>
<p>保存旧的处理函数，在处理完我们的信号处理函数后，在重新运行老的处理函数就能完成兼容。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 与 Unity 的交互</title>
    <url>/2021/07/29/Android%E4%B8%8EUnity%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p><img src="Unity%E7%9B%AE%E5%BD%95.jpg" alt="路径示例"></p>
<p>游戏的主 Activity 在onCreate时候创建一个 GLSurfaceView，它继承自 View，是引擎用于绘制游戏内容的。同时 GLSurfaceView 也接受玩家的点击事件，用于引擎与玩家的交互。</p>
<p>判断方向的翻转</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统Binder驱动分析(1)</title>
    <url>/2021/07/29/Android%E7%B3%BB%E7%BB%9FBinder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="提前掌握Binder的基础知识-预习"><a href="#提前掌握Binder的基础知识-预习" class="headerlink" title="提前掌握Binder的基础知识(预习)"></a>提前掌握Binder的基础知识(预习)</h1><p>Android系统架构的底层就是linux,本篇文章如有不懂的地方，建议参考<a href="http://www.linfo.org/">原文文档</a>,以便更好帮助自己学习。<br>希望能跟大家多多交流 !!!  </p>
<h2 id="Linux的基础知识"><a href="#Linux的基础知识" class="headerlink" title="Linux的基础知识"></a>Linux的基础知识</h2><p>Binder究竟是什么<br>什么是linux的系统内存<br>内核空间是什么<br>进程隔离<br>用户空间是什么</p>
<h2 id="Binder究竟是什么"><a href="#Binder究竟是什么" class="headerlink" title="Binder究竟是什么"></a>Binder究竟是什么</h2><p>Binder是Android系统中负责每个<strong>用户进程</strong>与<strong>内核</strong>通信的机制(驱动)</p>
<h2 id="内核空间是什么"><a href="#内核空间是什么" class="headerlink" title="内核空间是什么"></a>内核空间是什么</h2><p><a href="http://www.linfo.org/kernel_space.html">内核空间</a></p>
<blockquote>
<p>System memory in Linux can be divided into two distinct regions: kernel space and user space. Kernel space is where the kernel (i.e., the core of the operating system) executes (i.e., runs) and provides its services.<br>系统内存在的Linux可以分为两个不同的区域：<strong>内核空间</strong>和<strong>用户空间</strong>。内核空间是内核（即操作系统的核心）执行（即运行）并提供其服务的地方。</p>
</blockquote>
<h3 id="内核的作用是什么"><a href="#内核的作用是什么" class="headerlink" title="内核的作用是什么:"></a>内核的作用是什么:</h3><blockquote>
<p>One of the roles of the kernel is to manage individual user processes within this space and to prevent them from interfering with each other.<br>内核的作用之一是管理该空间内的各个用户进程并防止它们相互干扰。<br>这里涉及到一个概念 : <strong>进程隔离</strong></p>
</blockquote>
<h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
</blockquote>
<h4 id="内核空间的误区"><a href="#内核空间的误区" class="headerlink" title="内核空间的误区"></a>内核空间的误区</h4><blockquote>
<p>The kernel is a program that constitutes the central core of a computer operating system. It is not a process, but rather a controller of processes, and it has complete control over everything that occurs on the system. This includes managing individual user processes within user space and preventing them from interfering with each other.</p>
</blockquote>
<p>内核是构成计算机操作系统中央核心的程序。它不是一个进程，而是一个进程的控制器，它可以完全控制系统上发生的一切。这包括管理用户空间内的单个用户进程并防止它们相互干扰。</p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p><a href="http://www.linfo.org/user_space.html">用户空间</a></p>
<blockquote>
<p>User space is that portion of system memory in which user processes run<br>用户空间是用户进程在其中运行的系统内存部分</p>
</blockquote>
<h3 id="用户空间跟用户进程的区别"><a href="#用户空间跟用户进程的区别" class="headerlink" title="用户空间跟用户进程的区别"></a>用户空间跟用户进程的区别</h3><blockquote>
<p> User space is that set of memory locations in which user processes (i.e., everything other than the kernel) run<br>用户空间是一组内存位置，用户进程（即内核以外的所有东西）在其中运行。<br>每个正在运行的App都是一个用户进程,再不干涉的情景下，互相独立互不影响，都有属于自己的进程的用户空间。</p>
</blockquote>
<h2 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用/内核态/用户态"></a>系统调用/内核态/用户态</h2><blockquote>
<p>Kernel space can be accessed by user processes only through the use of system calls<br>用户空间访问内核空间的唯一方式就是系统调用</p>
</blockquote>
<p><strong>内核态</strong> : 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行<br><strong>用户态</strong> : 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。<br>处理器在特权等级高的时候才能执行那些特权CPU指令。 </p>
<h2 id="扩展概念"><a href="#扩展概念" class="headerlink" title="扩展概念"></a>扩展概念</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用是 <strong>类 Unix</strong> 操作系统中活动进程对内核执行的服务的请求，例如输入/输出(I/O) 或进程创建。活动进程是当前在 CPU 中进行的进程，与在 CPU 中等待其下一次运行的进程相反。I/O 是将数据传入或传出 CPU 以及传入或传出外围设备（如磁盘驱动器、键盘、鼠标和打印机）的任何程序、操作或设备。<br>系统调用主要通过如下两个函数来实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy_from_user() // 将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() // 将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>
<h3 id="Linux-使用两级保护机制："><a href="#Linux-使用两级保护机制：" class="headerlink" title="Linux 使用两级保护机制："></a>Linux 使用两级保护机制：</h3><p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<h3 id="Linux-内存映射"><a href="#Linux-内存映射" class="headerlink" title="Linux 内存映射"></a>Linux 内存映射</h3><p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h3 id="动态内核可加载模块"><a href="#动态内核可加载模块" class="headerlink" title="动态内核可加载模块"></a>动态内核可加载模块</h3><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。<br>它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>android-Handler机制-2</title>
    <url>/2021/07/27/android-Handler%E6%9C%BA%E5%88%B6-2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Message</td>
<td align="center">消息</td>
<td align="left">使用了享元设计模式 链表的数据结构</td>
<td align="left">详情</td>
</tr>
<tr>
<td align="left">MessageQuene</td>
<td align="center">消息队列</td>
<td align="left">单链表的数据结构</td>
<td align="left">优先级的队列 — 根据时间先后顺序排队的单链表</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="center">message的处理者</td>
<td align="left">即线程间传递的对象，传递的信息包含在其中    Handler的构造函 ，在构造函数中初始化了一个Looper 和 MessageQueue。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ThreadLocal</td>
<td align="center">数据结构是键值对</td>
<td align="left">只有在指定的线程可以获取到存储的数据</td>
<td align="left">获取线程唯一的变量 Theadlocal value 线程内部的数据存储类,使用场景：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本</td>
</tr>
<tr>
<td align="left">Looper</td>
<td align="center">循环器</td>
<td align="left"><img src="code_looper_1.jpg" alt="code_looper"></td>
<td align="left">类Looper的prepare的函数,即是对Looper进行了初始化，将Looper对象引用保存在sThreadLocal中，先保证了Looper和Threadlocal-1V1关系,由于sThreadLocal获取的值是通过获取当前线程获取线程唯一的变量,这样就保证了一个线程只有一个looper</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-APK的资源加载</title>
    <url>/2021/07/27/Android-APK%E7%9A%84%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="APK的资源"><a href="#APK的资源" class="headerlink" title="APK的资源"></a>APK的资源</h1><p>Android 资源大概分为两个部分：assets 和 res </p>
<h2 id="assets-资源"><a href="#assets-资源" class="headerlink" title="assets 资源"></a>assets 资源</h2><p>assets 资源放在 assets 目录下，它里面保存一些原始的文件，可以以任何方式来进行组织，这些文件最终会原封不动的被打包进 APK 文件中，通过AssetManager 来获取 asset 资源，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AssetManager assetManager = context.getAssets();</span><br><span class="line">InputStream is = assetManager.open(&quot;fileName&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="res-资源"><a href="#res-资源" class="headerlink" title="res 资源"></a>res 资源</h2><p>res 资源放在主工程的 res 目录下，这类资源一般都会在编译阶段生成一个资源 ID 供我们使用，res 目录包括 animator、anim、 color、drawable、layout、menu、raw、values、XML等，通过 getResource() 去获取 Resources 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resources res = getContext().getResources();</span><br></pre></td></tr></table></figure>

<p>在APK的生成过程中，会生成资源索引表 <strong>resources.arsc</strong> 文件和 <strong>R.java文件</strong></p>
<p><a href="https://zhupengbo.com/2021/07/26/android-APK%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/">APK构建指南</a> 关于R.id 请看这里。</p>
<p>resources.arsc 资源索引表 </p>
<h2 id="AssetManager"><a href="#AssetManager" class="headerlink" title="AssetManager"></a>AssetManager</h2><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-APK构建流程</title>
    <url>/2021/07/26/android-APK%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Apk构建流程"><a href="#Apk构建流程" class="headerlink" title="Apk构建流程"></a>Apk构建流程</h1><h2 id="Apk是什么"><a href="#Apk是什么" class="headerlink" title="Apk是什么"></a>Apk是什么</h2><p>维基百科，自由的百科全书<br>跳到导航跳到搜索<br>APK<br>APK format icon (2014-2019).png<br>扩展名    .apk、.xapk、.apks、.apkm<br>互联网媒体类型    application/vnd.android.package-archive<br>格式类型    包管理器 存档文件<br>专门属    软件包<br>延伸自    JAR 和 ZIP</p>
<p>APK 文件基于 ZIP 文件格式，它与JAR文件的构造方式相似。它的互联网媒体类型是：application/vnd.android.package-archive[5]。</p>
<p>扩展资料:<br>    Android5.0引入了Split APK机制，这是为了解决65536上限以及APK安装包越来越大等问题。Split APK机制可以将一个APK，拆分成多个独立APK。<br>    在引入了Split APK机制后，APK有两种分类：</p>
<pre><code>Single APK：安装文件为一个完整的APK，即base APK。Android称其为Monolithic。
Mutiple APK：安装文件在一个文件目录中，其内部有多个被拆分的APK，这些APK由一个 base APK和一个或多个split APK组成。Android称其为Cluster。
</code></pre>
<h2 id="Apk构成的属性"><a href="#Apk构成的属性" class="headerlink" title="Apk构成的属性"></a>Apk构成的属性</h2><pre><code>META-INF目录：包含两个签名文件（CERT.SF和CERT.RSA），以及一个manifest文件（MANIFEST.MF）
                  
assets目录：包含工程中的asset目录下的文件，可以使用AssetManager获取
                  
res目录：包含那些没有被编译到resources.arsc的资源
                
lib目录：包含适用于不同处理器的第三方依赖库，这里边可以有多个子目录，比如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, 以及mips
              
resources.arsc文件：存储编译好的资源，包括项目工程中的res/values目录里的xml文件，它们都被编译成二进制格式，也包括一些路径，指向那些没有被编译的资源，比如layout文件和图片
              
classes.dex文件：项目中的java类都被编译到该dex文件，这个文件可以被Android的Dalvik/ART虚拟机解析。
            
AndroidManifest.xml：二进制格式的manifest文件，这个文件是必须的。
        
这些文件是Android系统运行一个应用程序时会用到的数据和代码，下面介绍系统如何安装一个APK包。
</code></pre>
<h2 id="Apk编译的流程"><a href="#Apk编译的流程" class="headerlink" title="Apk编译的流程"></a>Apk编译的流程</h2><ol>
<li>通过<strong>aapt-Android Asset Packing Tool</strong> 打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）  </li>
</ol>
<blockquote>
<p>这一过程主要是aapt对res和asset文件夹，AndroidManifest.xml，android库(aar,jar)等的资源文件进行处理。  </p>
<ul>
<li>先检查<strong>AndroidManifest.xml</strong>的合法性  </li>
<li>然后编译res与asserts目录下的资源并生成resource.arsc文件  </li>
<li>再生成R文件。</li>
</ul>
</blockquote>
<p>除了assets和res/raw资源被原封不动地打包进APK之外，其它的资源都会被编译或者处理，<em>大部分文本格式的XML资源文件会被编译成二进制格式的XML资源文件</em>。<br>除了assets资源之外，其他的资源都会在R文件中被赋予一个资源ID。也就是说，R文件中只会存在id，真正的资源存在于resource.arsc中，resource.arsc相当于一个资源索引表，资源id是key，value是资源路径。我们使用drawable-xdpi或者drawable-xxdpi这些不同分辨率的图片的时候，就是依靠resource.arsc根据设备的分辨率选择不同的图片</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190915004258.png" alt="R.java"><br> (R.java相关知识)<br>2. 处理.aidl文件，生成对应的Java接口文件<br>3. 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 (编译期超出64k?)<br>4. 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex<br>5. 通过<strong>Japkbuilder</strong>J工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk<br>6. 通过<strong>Jarsigner</strong>工具，对上面的apk进行debug或release签名<br>通过zipalign工具，将签名后的apk进行对齐处理<br>(引申出问题，为什么需要签名，签名的方式有几种，有什么区别？)<br>7. 通过<strong>zipalign</strong>工具，将签名后的apk进行对齐处理<br>(引申一个问题，为什么需要对齐？)<br>8. 混淆proguard：proguard主要的目的是混淆代码，保护应用源代码。次要的功能还有移除无用类等，优化字节码，缩小包体积。  </p>
<h1 id="APK扩展性问题"><a href="#APK扩展性问题" class="headerlink" title="APK扩展性问题:"></a>APK扩展性问题:</h1><h2 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h2><h3 id="1-R-java是什么-R-java构成"><a href="#1-R-java是什么-R-java构成" class="headerlink" title="1. R.java是什么(R.java构成)"></a>1. <em>R.java是什么(R.java构成)</em></h3><blockquote>
<p>R.java由ADT(aapt)编译生成，<br>记录应用apk-res路径所有资源，并根据这些资源建立对应的ID(生成唯一的标识符)<br>编译期间，同一个资源在普通的apk中只会属于一个<strong>package</strong>，一个<strong>type</strong>，只拥有一个<strong>entry次序</strong>。<br>以0x01开头的就是系统已经内置的资源id，以0x7f开头的是咱们自己添加的app资源id </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/%E8%B5%84%E6%BA%90id.png" alt="R.java"> </p>
<blockquote>
<p>由于项目开发是多模块的开发 - 编译期相关的知识</p>
<ul>
<li>主模块中的R.java中的字段以final修饰，以常量形式存在。  </li>
<li>库模块中的R.java中的字段不以final修饰，以变量形式被项目中的代码所引用。  </li>
</ul>
</blockquote>
<h4 id="Android资源的合并"><a href="#Android资源的合并" class="headerlink" title="Android资源的合并"></a>Android资源的合并</h4><blockquote>
<p>覆盖的优先级如下：<br>build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependences</p>
</blockquote>
<blockquote>
<p>这种依赖关系不同于gradle里面的implementation依赖传递，implementation是跨级不能传递，但是R文件的生成是跨级可以传递的。<br>module的R文件数 = 依赖的module/aar数量 + 1(自身的R文件)<br>R.文件的生成是底层到上层 </p>
</blockquote>
<h3 id="为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？"><a href="#为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？" class="headerlink" title="为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？"></a>为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？</h3><blockquote>
<p><em>比较早的aapt的版本生成的非主模块的资源id确实都是final修饰的，这样会带来一个问题，这些资源id全部内联到代码中，一旦新增或者删除，修改了资源，资源id就会有变化，所有的代码都需要重新编译，造成严重的编译耗时</em>。  </p>
</blockquote>
<p>后来改为主模块final常量方式内联，非主模块引用方式，这样等按照从下到上编译到App模块的时候，所有的资源id都已经确定了，底层模块的资源只需要通过引用就能拿到自己对应的id，而修改(新增，删除，修改)了资源之后，也只需要重新生成R文件就好了。编译耗时大大减少。</p>
<p>在我们平常打包的时候，反编译apk，再合并资源回编时，也是要重新生成R文件。  </p>
<p>开发时，在其他module代码引用资源文件时,使用以下代码进行索引  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return a resource identifier for the given resource name.  A fully</span><br><span class="line"> * qualified resource name is of the form &quot;package:type/entry&quot;.  The first</span><br><span class="line"> * two components (package and type) are optional if defType and</span><br><span class="line"> * defPackage, respectively, are specified here.</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;Note: use of this function is discouraged.  It is much more</span><br><span class="line"> * efficient to retrieve resources by identifier than by name.</span><br><span class="line"> * </span><br><span class="line"> * @param name The name of the desired resource.</span><br><span class="line"> * @param defType Optional default resource type to find, if &quot;type/&quot; is</span><br><span class="line"> *                not included in the name.  Can be null to require an</span><br><span class="line"> *                explicit type.</span><br><span class="line"> * @param defPackage Optional default package to find, if &quot;package:&quot; is</span><br><span class="line"> *                   not included in the name.  Can be null to require an</span><br><span class="line"> *                   explicit package.</span><br><span class="line"> * </span><br><span class="line"> * @return int The associated resource identifier.  Returns 0 if no such</span><br><span class="line"> *         resource was found.  (0 is not a valid resource ID.)</span><br><span class="line"> */</span><br><span class="line">public int getIdentifier(String name, String defType, String defPackage) &#123;</span><br><span class="line">    return mResourcesImpl.getIdentifier(name, defType, defPackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？"><a href="#为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？" class="headerlink" title="为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？"></a>为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？</h3><p>因为资源id只是表示资源的次序，而不是别的跟资源本身绑定的属性。当到了不同的模块以后，参与编译的资源变多了，那次序肯定会改变。资源id也就改变了。并且子模块的资源id只是引用形式存在于代码中，id具体是什么值并不是很care。</p>
<h3 id="apk或者aab，为什么需要对齐？"><a href="#apk或者aab，为什么需要对齐？" class="headerlink" title="apk或者aab，为什么需要对齐？"></a><em>apk或者aab</em>，为什么需要对齐？</h3><blockquote>
<p>zipalign的主要工作是将apk包进行对齐处理，使apk包中的所有资源文件举例文件起始偏移为4字节的整数倍，这样通过内存映射访问apk时的速度会更快。<br>为什么快呢？如果每个资源的开始位置上都是一个资源之后的4n字节，那么访问下一个资源就不用遍历，直接跳到4字节之后即可 </p>
</blockquote>
<h3 id="apk或者aab混淆的方式有哪些"><a href="#apk或者aab混淆的方式有哪些" class="headerlink" title="apk或者aab混淆的方式有哪些()"></a><em>apk或者aab</em>混淆的方式有哪些()</h3><blockquote>
</blockquote>
<p>压缩(Shrink)：检测并移除代码中无用的类、字段、方法和特性<br>优化(Optimize)：字节码进行优化，移除无用的指令。<br>混淆(Obfuscate)：使用a、b、c、d这样简短而无意义的名称，对垒、字段和方法进行重命名。<br>预检测(Preveirfy)：在Java平台对处理后的代码进行预检测，确保加载class文件是可执行的 </p>
<h3 id="“Android”-64k报错"><a href="#“Android”-64k报错" class="headerlink" title="“Android” 64k报错"></a>“Android” 64k报错</h3><p>应用及第三方库包含的方法数(method)总和超过65536，在开发的时候，会遇到一个构建的错误。<br>指明您的应用达到Android构建规定的应用的限制：</p>
<h4 id="构建错误的原因"><a href="#构建错误的原因" class="headerlink" title="构建错误的原因:"></a>构建错误的原因:</h4><h5 id="dex文件格式的限制"><a href="#dex文件格式的限制" class="headerlink" title="dex文件格式的限制"></a>dex文件格式的限制</h5><p>Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 二进制文件形式的可执行字节码文件，这些文件包含用来运行应用的已编译代码。<br>Dalvik Executable 规范将可在单个 DEX 文件内引用的方法总数限制为 65536 (其中包括 Android 框架方法、库方法以及您自己的代码中的方法)</p>
<h5 id="其他限制"><a href="#其他限制" class="headerlink" title="其他限制"></a>其他限制</h5><p>系统对dex文件进行优化操作时分配的缓冲区大小的限制 ，方法如果超出缓存区，同样也是会报错的。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Handle---消息分发机制(ThreadLocal)</title>
    <url>/2021/07/26/android-Handler%E6%9C%BA%E5%88%B6-1/</url>
    <content><![CDATA[<h1 id="创建handler的背景"><a href="#创建handler的背景" class="headerlink" title="创建handler的背景"></a>创建handler的背景</h1><p>Android应用启动App的线程定义为UI线程(主线程)，由于为了保证系统流畅性，用户页面不能被阻塞，除UI线程外其他线程不能做更新UI的操作，但是由于Java多线程通信又都是堵塞方法，所以就得设计一套工作线程和主线程可以兼容的方法，目的无非2个，工作线程和UI线程的多线程通信，UI线程不能被堵塞问题。</p>
<blockquote>
<p>Handler 就是为了创建Android系统中UI线程和工作线程的多线程通信机制</p>
</blockquote>
<blockquote>
<p>Handler 不是独立线程，因为它的引用会在别的线程作为发送端，也就是Handler 本身就是多线程共享引用，Handler需要一个独立在线程内部的切私有的类帮助它接受信息 – Looper。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-&gt;Looper</span><br><span class="line"></span><br><span class="line">public static void loop() &#123;</span><br><span class="line">      for (;;) &#123;</span><br><span class="line">            //1、取消息</span><br><span class="line">            Message msg = queue.next(); // might block</span><br><span class="line">            ...</span><br><span class="line">            //2、消息处理前回调</span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                        msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //3、消息开始处理</span><br><span class="line">            msg.target.dispatchMessage(msg);// 分发处理消息</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            //4、消息处理完回调</span><br><span class="line">            if (logging != null) &#123;</span><br><span class="line">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于loop循环存在，所以主线程可以长时间运行。如果想要在主线程执行某个任务，唯一的办法就是通过主线程Handler post一个任务到消息队列里去，然后loop循环中拿到这个msg，交给这个msg的target处理，这个target是Handler.</p>
<p>导致卡顿的原因可能有两个地方</p>
<p>注释1的queue.next()阻塞，–<br>注释3的dispatchMessage耗时太久。 –</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //1、nextPollTimeoutMillis 不为0则阻塞</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // Try to retrieve the next message.  Return if found.</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = null;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            // 2、先判断当前第一条消息是不是同步屏障消息，</span><br><span class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                //3、遇到同步屏障消息，就跳过去取后面的异步消息来处理，同步消息相当于被设立了屏障</span><br><span class="line">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //4、正常的消息处理，判断是否有延时</span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    //3.1 </span><br><span class="line">                    // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Got a message.</span><br><span class="line">                    mBlocked = false;</span><br><span class="line">                    if (prevMsg != null) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = null;</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //5、如果没有取到异步消息，那么下次循环就走到1那里去了，nativePollOnce为-1，会一直阻塞</span><br><span class="line">                // No more messages.</span><br><span class="line">                nextPollTimeoutMillis = -1;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>next方法的大致流程是这样的：</p>
<p>MessageQueue是一个链表数据结构，判断MessageQueue的头部（第一个消息）是不是一个同步屏障消息，所谓同步屏障消息，就是给同步消息加一层屏障，让同步消息不被处理，只会处理异步消息；</p>
<p>如果遇到同步屏障消息，就会跳过MessageQueue中的同步消息，只获取里面的异步消息来处理。如果里面没有异步消息，那就会走到注释5，nextPollTimeoutMillis设置为-1，下次循环调用注释1的nativePollOnce就会阻塞；</p>
<p>如果looper能正常获取到消息，不管是异步消息或者同步消息，处理流程都是一样的，在注释4，先判断是否带延时，如果是，nextPollTimeoutMillis就会被赋值，然后下次循环调用注释1的nativePollOnce就会阻塞一段时间。如果不是delay消息，就直接返回这个msg，给handler处理；</p>
<p>从上面分析可以看出，next方法是不断从MessageQueue里取出消息，有消息就处理，没有消息就调用nativePollOnce阻塞，nativePollOnce 底层是Linux的epoll机制，这里涉及到一个Linux IO 多路复用的知识点</p>
<p>作者：蓝师傅<br>链接：<a href="https://juejin.cn/post/6973564044351373326">https://juejin.cn/post/6973564044351373326</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Message</td>
<td align="center">消息</td>
<td align="left">使用了享元设计模式 链表的数据结构</td>
<td align="left">详情</td>
</tr>
<tr>
<td align="left">MessageQuene</td>
<td align="center">消息队列</td>
<td align="left">单链表的数据结构</td>
<td align="left">优先级的队列 — 根据时间先后顺序排队的单链表</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="center">message的处理者</td>
<td align="left">即线程间传递的对象，传递的信息包含在其中    Handler的构造函 ，在构造函数中初始化了一个Looper 和 MessageQueue。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ThreadLocal</td>
<td align="center">数据结构是键值对</td>
<td align="left">只有在指定的线程可以获取到存储的数据</td>
<td align="left">获取线程唯一的变量 Theadlocal value 线程内部的数据存储类,使用场景：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本</td>
</tr>
<tr>
<td align="left">Looper</td>
<td align="center">循环器</td>
<td align="left"><img src="code_looper_1.jpg" alt="code_looper"></td>
<td align="left">类Looper的prepare的函数,即是对Looper进行了初始化，将Looper对象引用保存在sThreadLocal中，先保证了Looper和Threadlocal-1V1关系,由于sThreadLocal获取的值是通过获取当前线程获取线程唯一的变量,这样就保证了一个线程只有一个looper</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/">技术小黑屋</a><br><a href="https://www.jianshu.com/p/8fd635f50016">简书-InheritableThreadLocal</a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事物的创造从未有应该或不应该，但被创造出来后如何被人利用却成了最大的问题。</span><br></pre></td></tr></table></figure>
<p>我觉得这个话应用到编程上也是一样的，把自身关注点放到事物是什么背景下创造出来的，了解事物的出生，发展，迭代，衰亡，站在巨人的肩膀上看问题。</p>
<p>深刻理解事物的本质和特性，这也是导致变化的原因，本质影响结果的走向，特性影响过程的变化。<br>无法对现象作出最终解释的理论都是无用的，因为其不能反映客观事实！</p>
<!-- 我们回归正题,要分析他的本质和特性，就要回归本源(看源码)! -->

<h1 id="ThreadLocal-简述"><a href="#ThreadLocal-简述" class="headerlink" title="ThreadLocal 简述"></a>ThreadLocal 简述</h1><p>ThreadLocal是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰。 </p>
<p>ThreadLocal就是提供给每个线程操作变量的工具类，做到了线程之间的变量隔离目的。</p>
<h2 id="TheadLocal-原理及应用场景"><a href="#TheadLocal-原理及应用场景" class="headerlink" title="TheadLocal 原理及应用场景"></a>TheadLocal 原理及应用场景</h2><ul>
<li>ThreadLocal主要有2大特性   </li>
</ul>
<ul>
<li>全局性 线程内可访问  </li>
<li>唯一性 使用ThreadLocal维护变量时，每个线程都会获得该线程独享一份变量副本。</li>
</ul>
<p>这里借鉴下大神的图<br><img src="thread.jpeg" alt="code_looper">  </p>
<hr>
<p>1.每个Thread线程内部都有一个ThreadLocalMap。<br>2.Map里面存储线程本地对象ThreadLocal（key）和线程的变量副本（value）。<br>3.Thread内部的Map是由ThreadLocal维护，ThreadLocal负责向map获取和设置线程的变量值。<br>4.一个Thread可以有多个ThreadLocal。</p>
<p><strong>Thread</strong><br>当我们初始化一个线程的时候,其内部干去创建了一个ThreadLocalMap的Map容器待用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Thread implements Runnable &#123;</span><br><span class="line">    /* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line">     * by the ThreadLocal class. */</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocal</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sets the current thread&#x27;s copy of this thread-local variable to the specified value. </span><br><span class="line">Most subclasses will have no need to override this method, relying solely on the &#123;@link #initialValue&#125; method to set the values of thread-locals.</span><br><span class="line"></span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get the map associated with a ThreadLocal </span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里其实可以发现真正起到作用的其实这个<strong>ThreadLocal内部类ThreadLocalMap</strong>。<br>由于<strong>ThreadLocalMap</strong>的数据结构是Map键值对(K,V)，这里的K是本地线程threadLocals，V是线程的变量副本（value）。</p>
<p>但是这样还是不够，我还是没弄明白ThreadLocal是怎么把变量复制到Thread的ThreadLocalMap中的？</p>
<p>直到我去google到这篇<a href="https://zhuanlan.zhihu.com/p/158033837">文章</a> 😯 😄 😏 </p>
<p>当我们初始化一个线程的时候其内部干去创建了一个ThreadLocalMap的Map容器待用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Thread implements Runnable &#123;</span><br><span class="line">    /* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line">     * by the ThreadLocal class. */</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当ThreadLocalMap被创建加载的时候ThreadLocalMap静态内部类Entry也随之加载，完成初始化动作。<br><strong>ThreadLocalMap</strong>内部类<strong>Entry</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        /** The value associated with this ThreadLocal. */</span><br><span class="line">       Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能到这里大家多少有些困惑，我们重新整理下流程<br>当我们在Thread内部调用set方法时:<br><strong>ThreadLocal</strong><br>1.会去获取调用当前方法的线程Thread。<br>2.然后顺其自然的拿到当前线程内部的ThreadLocalMap容器。<br>3.最后就把变量副本给丢进去。<br>ThreadLocal（就认为是个维护线程内部变量的工具！）只是在Set的时候去操作了Thread内部的·ThreadLocalMap将变量拷贝到了Thread内部的Map容器中，Key就是当前的ThreadLocal,Value就是变量的副本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于涉及的类很多，我们这里把架构图拆分下<br><img src="threadlocal%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="threadLocal架构图">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the value in the current thread&#x27;s copy of this</span><br><span class="line"> * thread-local variable.  If the variable has no value for the</span><br><span class="line"> * current thread, it is first initialized to the value returned</span><br><span class="line"> * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line"> *</span><br><span class="line"> * @return the current thread&#x27;s value of this thread-local</span><br><span class="line"> */</span><br><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null)</span><br><span class="line">            return (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">获取当前线程的ThreadLocalMap对象</span><br><span class="line">从map中根据this（当前的threadlocal对象）获取线程存储的Entry节点。</span><br><span class="line">从Entry节点获取存储的对应Value副本值返回。</span><br><span class="line">map为空的话返回初始值null，即线程变量副本为null。</span><br></pre></td></tr></table></figure>


<h1 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h1><h2 id="Key的弱引用问题"><a href="#Key的弱引用问题" class="headerlink" title="Key的弱引用问题"></a>Key的弱引用问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.</span><br></pre></td></tr></table></figure>
<p>为了处理非常大和生命周期非常长的线程(<strong>usages</strong>)，哈希表使用弱引用作为 key。</p>
<p>ThreadLocal在没有外部对象强引用时如Thread，发生GC时弱引用Key会被回收，而Value是强引用不会回收，如果创建ThreadLocal的线程一直持续运行如线程池中的线程，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p>
<p>key 如果使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。<br>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。</p>
<p>通常ThreadLocalMap的生命周期跟Thread（注意线程池中的Thread）一样长，如果没有手动删除对应key（线程使用结束归还给线程池了，其中的KV不再被使用但又不会GC回收，可认为是内存泄漏），一定会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal会被GC回收，不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除，Java8已经做了上面的代码优化。</p>
<p>总结<br>每个ThreadLocal只能保存一个变量副本，如果想要一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。<br>ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。<br>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>再看看内部的剖析图<br><img src="ThreadLocal%E5%86%85%E9%83%A8%E5%89%96%E6%9E%90%E5%9B%BE.webp" alt="ThreadLocal结果图"></p>
<p>ThreadLocal底层原理是线程内部维护了ThreadLocalMap，至于怎么加载ThreadLocalMap，上面已经有详细的解释了，这里我们不做太多的解释，我们把 Threadlocal 对象作为 key，要存储的的数据作为 value ，这里Threadlocal的对象作为线程局部变量的入口。<br>再扩展一下源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">        // Map中的Entry对象，弱引用类型，key是ThreadLocal对象，value是线程局部变量</span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 初始化容量16，必须是2的幂次方</span><br><span class="line">        private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">        // 存储数据的数组，可扩容，长度必须是2的幂次方 </span><br><span class="line">        private Entry[] table;</span><br><span class="line"></span><br><span class="line">        // table数组的大小</span><br><span class="line">        private int size = 0;</span><br><span class="line"></span><br><span class="line">        // table数组的阈值，达到则扩容</span><br><span class="line">        private int threshold; // Default to 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>再看demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line">    private static final ThreadLocal&lt;String&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 设置线程局部变量</span><br><span class="line">        THREAD_LOCAL.set(&quot;我是你爹&quot;);</span><br><span class="line">        // 使用线程局部变量</span><br><span class="line">        peelChenpi();</span><br><span class="line">        // 删除线程局部变量</span><br><span class="line">        THREAD_LOCAL.remove();</span><br><span class="line">        // 使用线程局部变量</span><br><span class="line">        peelChenpi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void peelChenpi() &#123;</span><br><span class="line">        System.out.println(THREAD_LOCAL.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我是你爹</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>我们需要从已知的开始反推。<br>为什么 ThreadLocalMap 内部存储机构是维护一个数组呢？因为一个线程是可以通过多个不同的 ThreadLocal 对象来设置多个线程局部变量的，这些局部变量都是存储在自己线程的同一个 ThreadLocalMap 对象中。通过不同的 ThreadLocal 对象可以取得当前线程的不同局部变量值。</p>
<p>作者：熬夜不加班<br>链接：<a href="https://www.jianshu.com/p/4c3e54656f4a">https://www.jianshu.com/p/4c3e54656f4a</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="ThreadLocal线程安全问题"><a href="#ThreadLocal线程安全问题" class="headerlink" title="ThreadLocal线程安全问题"></a>ThreadLocal线程安全问题</h2><p>ThreadLocal 类中的所有方法都是没有加锁的，因为 ThreadLocal 最终操作的都是对当前线程的 ThreadLocalMap 对象进行操作，既然线程处理自己的局部变量，就肯定不会有线程安全问题</p>
<h2 id="思考之外"><a href="#思考之外" class="headerlink" title="思考之外"></a>思考之外</h2><p>Thread 的 threadLocals 变量是默认访问权限的，只能被同个包下的类访问，所以我们是不能直接使用 Thread 的 threadLocals 变量的，这也就是为什么能控制不同线程只能获取自己的数据，达到了线程隔离。Threadlocal 类是访问它的入口。</p>
<h2 id="ThreadLocal内存泄露"><a href="#ThreadLocal内存泄露" class="headerlink" title="ThreadLocal内存泄露"></a>ThreadLocal内存泄露</h2><p>线程的生命周期都比较长，加上现在普遍使用的线程池，会让线程的生命更加长。<br>不remove，当然不会释放。这和Key，到底是不是弱引用，关系不大。<br>严格来说，ThreadLocal没有内存泄漏问题。有的话，那就是你忘记执行remove方法。这是不正确使用引起的。  </p>
<h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><!-- 我们打开ThreadLocal源码，开头的序言转译一下。 -->
<!-- ```
  This class provides thread-local variables.  These variables differ from
  their normal counterparts in that each thread that accesses one (via its
  {@code get} or {@code set} method) has its own, independently initialized
  copy of the variable.  {@code ThreadLocal} instances are typically private
  static fields in classes that wish to associate state with a thread (e.g.,
  a user ID or Transaction ID).
  此类提供线程局部变量。这些变量不同于它们的正常对应物，因为每个线程访问一个（通过其
  {@code get} 或 {@code set} 方法）有自己的，独立初始化的
  变量的副本。 {@code ThreadLocal} 实例通常是私有的
  希望将状态与线程相关联的类中的静态字段（例如，
  用户 ID 或交易 ID）。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">还有一段很重要的描述</span><br></pre></td></tr></table></figure>
<p>Each thread holds an implicit reference to its copy of a thread-local<br>variable as long as the thread is alive and the {@code ThreadLocal}<br>instance is accessible; after a thread goes away, all of its copies of<br>thread-local instances are subject to garbage collection (unless other<br>eferences to these copies exist).</p>
<p>每个线程都持有一个对其本地线程副本的隐式引用<br>只要线程还活着并且 {@code ThreadLocal} 变量<br>实例可访问；一个线程消失后，它的所有副本<br>线程本地实例受垃圾回收的影响（除非其他<br>存在对这些副本的引用）<br>@author  Josh Bloch and Doug Lea<br>@since   1.2</p>
<pre><code class="--&gt;">




</code></pre>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android App Bundles</title>
    <url>/2021/07/19/google-aab/</url>
    <content><![CDATA[<h1 id="Google-Android-App-Bundles"><a href="#Google-Android-App-Bundles" class="headerlink" title="Google - Android App Bundles"></a>Google - Android App Bundles</h1><p>2018 年的 Google I/O ，Google 向 Android 引入了新 App 动态化框架（即 Android App Bundle，缩写为<strong>AAB</strong>)</p>
<blockquote>
<p>App 动态化框架，动态化概念指的是 Play Dynamic Delivery </p>
<blockquote>
<p><strong>上线要求</strong>:从 2021 年 8 月起，新应用需要使用 Android App Bundle 才能在 Google Play 中发布。  </p>
</blockquote>
</blockquote>
<h2 id="About-Android-App-Bundles"><a href="#About-Android-App-Bundles" class="headerlink" title="About Android App Bundles"></a>About Android App Bundles</h2><blockquote>
<p>Android App Bundle 是一种包含编译后代码和资源文件的新的上传格式（.aab） </p>
</blockquote>
<p>补充:<strong>Android Application Bundle</strong> != <strong>Apk</strong><br>App Bundle 纯粹是为了上传设计的文件，用户无法直接安装和使用它。<br>虽然AAB和Apk本质上都是压缩包,但是内部的目录结构完全不同，以下是一个Abb正常的aab文件结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–BundleConfig.pb ： 打包bundle的时候，自动生成</span><br><span class="line">–base : base目录</span><br><span class="line">——assets: 对应apk的assets目录</span><br><span class="line">——dex: 原apk中classes.dex,classes2.dex…都放这里</span><br><span class="line">——lib: 原apk中lib目录都放这里</span><br><span class="line">——manifest: 原apk的AndroidManifest.xml放这里，需要是编译后的AndroidManifest.xml</span><br><span class="line">——res：apk中的资源放这里，需要是编译后的资源</span><br><span class="line">——root: apk中相对于根目录的其他资源文件</span><br><span class="line">——resources.pb：编译资源的时候会生成的</span><br><span class="line">——assets.pb:编译bundle的时候会生成的</span><br><span class="line">——native.pb: 编译bundle的时候会生成的</span><br></pre></td></tr></table></figure>

<h2 id="Google-Play-Dynamic-Delivery"><a href="#Google-Play-Dynamic-Delivery" class="headerlink" title="Google Play Dynamic Delivery"></a>Google Play Dynamic Delivery</h2><blockquote>
<p>简介:Google Play 推出新 app 交付模式，叫做动态交付 (Dynamic Delivery)，它根据每个用户的设备信息，使用开发者上传的 app bundle 来生成对应的 apk 文件。</p>
<blockquote>
<p><img src="https://conorlee.top/images/blogimages/2019/640.gif" alt="AAB">  </p>
</blockquote>
</blockquote>
<h2 id="Play-Asset-Delivery"><a href="#Play-Asset-Delivery" class="headerlink" title="Play Asset Delivery"></a>Play Asset Delivery</h2><blockquote>
<p>Play Asset Delivery (PAD)可以让依靠 Google Play 来托管和提供你的资产包，PAD提供灵活的分发模式，本质上减少包的体积，让用户更佳的体验,目前分发模式有3种，分别为<br><strong>1.install-time 2.fast-follow 3.on-demand</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分发模式</th>
<th align="center">大小限制</th>
<th align="left">简介</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">install-time  =&gt; 安装时分发</td>
<td align="center">总下载大小上限为1GB</td>
<td align="left">资源包在用户安装应用时进行分发，”预先”资源包</td>
<td align="left">在应用启动是使用，用户无法修改或删除这些资源包</td>
</tr>
<tr>
<td align="left">fast-follow =&gt; 快速跟进式分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包在用户安装应用后立即自动下载</td>
<td align="left">用户无需打开应用即可开始 fast-follow 下载。此类下载不会阻止用户访问应用。</td>
</tr>
<tr>
<td align="left">on-demand =&gt; 按需分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包会在应用运行时进行下载</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意 ！！！</strong>：如果为资源包选择 <strong>install-time 分发类型</strong>，就无需在游戏中使用 <strong>Play Asset Delivery API</strong>。这些资源包与主应用 APK同时安装。<br>目前公司项目使用就是分发模式就是 <strong>install-time</strong></p>
<p>由于google规定需要apk&lt;150m，等于aab中的base目录&lt;150m，如果超出限制，需要把多出的资源迁移到install-time，让google去动态下发资源</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>由<strong>S1-EN</strong>项目举例，该项目使用模块化，该项目包含以下的模块</p>
<h2 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h2><table>
<thead>
<tr>
<th align="left">模块</th>
<th align="center">类型</th>
<th align="left">简介</th>
<th align="left">包含依赖</th>
</tr>
</thead>
<tbody><tr>
<td align="left">EN</td>
<td align="center">APP</td>
<td align="left">完整项目</td>
<td align="left">ENGameResource</td>
</tr>
<tr>
<td align="left">EN_HW</td>
<td align="center">AAB</td>
<td align="left"></td>
<td align="left">ENGameResource,install_time</td>
</tr>
<tr>
<td align="left">ENGameResource</td>
<td align="center">游戏资源</td>
<td align="left">对应替换游戏资源</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">ENAPPLib</td>
<td align="center">LIB</td>
<td align="left"></td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">install_time</td>
<td align="center">AAB-分发模式</td>
<td align="left">安装时分发</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">on_demand</td>
<td align="center">AAB-分发模式</td>
<td align="left">按需分发</td>
<td align="left">无</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABB = ENGameResource + EN_HW + install_time</span><br></pre></td></tr></table></figure>

<h2 id="出包需求"><a href="#出包需求" class="headerlink" title="出包需求"></a>出包需求</h2><p>我们以S1-EN 欧美出包来举例，一般需要出2个类型的包，一直为正常的APK，给运营测试，另外一种为AAB给发行上架应用。</p>
<p>对应出包格式和命名可以查看此目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\192.168.1.181\apk\欧美\</span><br></pre></td></tr></table></figure>
<p>一般我们是先出APK,后出AAB。</p>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>我们是先从145打包机上，打包一个完整的APK，复制到本地进行解压出对应的游戏资源。<br>解压的过程可以自由发挥，在我的电脑我是内置了解压的Apk的程序。<br>使用APKDB编辑,会出现以下页面，回车即可</p>
<p><img src="APKDB.png" alt="Android-AAB"></p>
<p>右键Apk-&gt;使用APKDB编辑-&gt;按下回车</p>
<p><img src="%E8%A7%A3%E5%8E%8B%E5%90%8E.png" alt="Android-AAB"></p>
<p>实际上我们只需要用到截图中的几个目录</p>
<p><strong>ABB = ENGameResource + EN_HW + install_time</strong></p>
<p>所以对应项目替换的路径，看下图</p>
<p><img src="ABB%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5.png" alt="Android-AAB"></p>
<!-- # 项目 -->

<!-- # 软件使用说明
### 需要提前安装的环境   
* 需要自己额外再安装的路径  
    1. python3
    2. aapt  
    3. gradle 
    4. as-pro  ==> 模板工程 
* 该工具内置了反编译的环境 请勿随意修改路径  
    1. apktool  
    2. dex2jar  
    3. smali  

2 需要在该工具路径下/tool/apktool/signature/config/apk.ini文件配置以下路径

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置项 后续看项目的需求支持可增加参数</span><br><span class="line">[config]</span><br><span class="line"># 注意所有配置项需要顶行写，&quot;=&quot; 号两边和行首尾不能有空格</span><br><span class="line"># AS 路径 </span><br><span class="line">as_path=/Users/zhupengbo/Desktop/S3/S3_Hw</span><br><span class="line"># AAB 生成的路径 必填</span><br><span class="line">abb_path=/Users/zhupengbo/tool/apktool/apk/abb</span><br><span class="line"># 版本号和版本名</span><br><span class="line">versionCode=1</span><br><span class="line">versionName=1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.该项目增加了pad配置表<br>3.1 <strong>aab_pad.xls</strong> 配置表路径在 <strong>/apktool/signature/config</strong> 的路径下<br>3.2 配置的方法<br>支持配置<strong>文件路径</strong>和<strong>文件夹</strong><br>S3项目以resource路径下进行配表，该路径包含了游戏内的资源  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置形式为:resource/路径</span><br></pre></td></tr></table></figure>

<p><strong>aab_pad.xls 格式如下-示例</strong></p>
<table>
<thead>
<tr>
<th align="left">Path</th>
</tr>
</thead>
<tbody><tr>
<td align="left">resource/model</td>
</tr>
<tr>
<td align="left">resource/Video</td>
</tr>
<tr>
<td align="left">resource/allRes.json</td>
</tr>
<tr>
<td align="left">resource/ui</td>
</tr>
</tbody></table>
<p>4 该工具支持下终端下执行，调用示例</p>
<pre><code>/Users/zhupengbo/tool/apktool/android_pack.sh /Users/zhupengbo/tool/apktool/apk/apk/AAA.apk
``` --&gt;

</code></pre>
]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo CMD</title>
    <url>/2021/07/19/hexo/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;博客名称&quot;  =&gt; hexo new &quot;博客名称&quot;   #这两个都是创建新文章，前者是简写模式</span><br><span class="line">hexo p  =&gt; hexo publish</span><br><span class="line">hexo g  =&gt; hexo generate  #生成</span><br><span class="line">hexo s  =&gt; hexo server  #启动服务预览</span><br><span class="line">hexo d  =&gt; hexo deploy  #部署  </span><br><span class="line"></span><br><span class="line">hexo server   #Hexo 会监视文件变动并自动更新，无须重启服务器。</span><br><span class="line">hexo server -s   #静态模式</span><br><span class="line">hexo server -p 5000   #更改端口</span><br><span class="line">hexo server -i 192.168.1.1   #自定义IP</span><br><span class="line">hexo clean   #清除缓存，网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g   #生成静态网页</span><br><span class="line">hexo d   #开始部署</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
