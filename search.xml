<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机English词汇普及更正</title>
    <url>/2021/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BAEnglish%E8%AF%8D%E6%B1%87%E6%99%AE%E5%8F%8A%E6%9B%B4%E6%AD%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-CMD集合</title>
    <url>/2021/09/07/Android-CMD%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h2><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">重启adb </span><br><span class="line">adb kill-server &amp;&amp; adb server &amp;&amp; adb shell</span><br><span class="line">查看当前的进程</span><br><span class="line">adb shell ps | grep <span class="keyword">package</span>-name </span><br><span class="line">过滤日志</span><br><span class="line">adb logcat </span><br><span class="line">查看链接cpu架构信息</span><br><span class="line">adb shell </span><br><span class="line">cat/<span class="keyword">proc</span>/cpuinfo </span><br><span class="line">查看已经连接的设备<span class="title"></span></span><br><span class="line"><span class="title">adb</span> devices</span><br><span class="line">指定设备安装apk<span class="title"></span></span><br><span class="line"><span class="title">adb</span> -s<span class="title"> xxx</span> install<span class="title"> xxx.apk</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">keytool</span> -list -v -keystore<span class="title">  xxx.keystore</span></span><br><span class="line">查看签名秘钥</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ADB-进阶CMD"><a href="#ADB-进阶CMD" class="headerlink" title="ADB 进阶CMD"></a>ADB 进阶CMD</h2><p>描述：每隔 1s 输出一次APP CPU信息，命令如下</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$adb</span> shell</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$adb</span> top -d 1 | grep com.packagename.xxx</span></span><br></pre></td></tr></table></figure>

<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">Gradle</span><br><span class="line">查看主要的任务</span><br><span class="line"><span class="string">./gradlew</span> tasks </span><br><span class="line">查看所有任务，包括缓存任务</span><br><span class="line"><span class="string">./gradlew</span> tasks <span class="params">--all</span></span><br><span class="line">调试模式构建并打印堆栈日志</span><br><span class="line"><span class="string">./gradlew</span> build <span class="params">--info</span> <span class="params">--debug</span> <span class="params">--stacktrace</span></span><br></pre></td></tr></table></figure>

<h2 id="bundletool"><a href="#bundletool" class="headerlink" title="bundletool"></a>bundletool</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Linux-Android"><a href="#Linux-Android" class="headerlink" title="Linux - Android"></a>Linux - Android</h2><p>1、查看 CPU 详细信息</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>cpuinfo</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>Android卡顿优化-前章</title>
    <url>/2021/09/07/Android%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96-%E5%89%8D%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Android存储路径更新(前章)</title>
    <url>/2021/09/06/Android%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在Android版本的不断升级更替中，Google对存储目录操作的限制也是越来越严格。<br>至于为什么要限制，其实是有迹可循的。第一点是出于用户安全数据的保护，Android (Q)10 之前，Android的文件存储现象就像个垃圾桶，只要app取得了存储空间的读写权限，WRITE_EXTERNAL_STORAGE，就可以肆意创建文件，难以管理。用户体验也特别差，打开文件管理器，会发现，想找个具体的文件根本无从下手。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Android <span class="number">10</span> (Q)  新增了分区存储的概念，targetSdkVersion=<span class="number">29</span>  </span><br><span class="line">Android &gt;<span class="number">10</span><span class="literal">()</span> *强制开启分区存储的概念，targetSdkVersion&gt;=<span class="number">30</span></span><br><span class="line"><span class="comment">// 这里我们在罗列上一些开发的细节</span></span><br><span class="line"></span><br><span class="line">当targetSdk &lt;= <span class="number">28</span>时，应用使用传统存储方式；</span><br><span class="line">当targetSdk &lt;= <span class="number">29</span>时，可以通过在应用清单的application标签中添加android:requestLegacyExternalStorage=<span class="string">&quot;true&quot;</span> ，从而关闭分区存储功能，继续使用传统访问方式。</span><br><span class="line">当targetSdk &gt;= <span class="number">30</span>时，Android会强制执行分区存储，无法关闭。可以通过<span class="module-access"><span class="module"><span class="identifier">Environment</span>.</span></span>is<span class="constructor">ExternalStorageLegacy()</span>判断应用存储的运行方式，<span class="literal">true</span>表示以传统的兼容方式运行，<span class="literal">false</span>表示以分区存储运行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="科普-targetSdkVersion"><a href="#科普-targetSdkVersion" class="headerlink" title="科普 - targetSdkVersion"></a>科普 - targetSdkVersion</h2><p>在开发中targetSdkVersion到底是啥含义？</p>
<h2 id="Android手机的存储"><a href="#Android手机的存储" class="headerlink" title="Android手机的存储"></a>Android手机的存储</h2><ul>
<li>安卓设备的物理存储分为两大块，内部存储和外部存储</li>
</ul>
<p>内部存储：<br>设备中每一个安装的 App，系统都会在内部存储空间的 data/data 目录下以应用包名为名字自动创建与之对应的文件夹，这个文件夹也用来 存放SharedPreferences 和 SQLiteDatabase 的数据， App 中的 WebView 缓存页面信息也在这文件夹下；<br>但是 当app被卸载的时候，这个文件夹 会被删除掉。<br>开发过程中，可通过 Context对象提供的 API 读取操作 内部存储中的文件</p>
<p>强烈建议大家开发的手机尽量Root或者使用64位的模拟器 👍🏻,可以对整体目录有个清晰了解。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * Environment.getDataDirectory() : /data</span><br><span class="line">    * context.getFilesDir() : <span class="regexp">/data/u</span>ser<span class="regexp">/0/</span>com.e.dk_wd/files</span><br><span class="line">    * context.getCacheDir() : <span class="regexp">/data/u</span>ser<span class="regexp">/0/</span>com.e.dk_wd/cache</span><br><span class="line">    * context.getDataDir() : <span class="regexp">/data/u</span>ser<span class="regexp">/0/</span>com.e.dk_wd</span><br><span class="line">*/</span><br><span class="line">    Log.i(<span class="string">&quot;----&quot;</span>, <span class="string">&quot;Environment.getDataDirectory() : &quot;</span> + Environment.getDataDirectory().absolutePath)</span><br><span class="line">    Log.i(<span class="string">&quot;----&quot;</span>, <span class="string">&quot;context.getFilesDir() : &quot;</span> + this.filesDir!!.absolutePath)</span><br><span class="line">    Log.i(<span class="string">&quot;----&quot;</span>, <span class="string">&quot;context.getCacheDir() : &quot;</span> + this.cacheDir!!.absolutePath)</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;----&quot;</span>, <span class="string">&quot;context.getDataDir() : &quot;</span> + this.dataDir!!.absolutePath)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果你想看app的看存储的话，提前root，或者你用模拟器打开即可。</p>
<p>外部存储：</p>
<p>现在的手机基本上都是内置了 <strong>SD</strong> 卡，同时也提供 <strong>SD 卡的拓展</strong>。<br>所说的外部存储，就是手机设备内置的 SD卡 和 扩展的SD卡 提供的存储空间<br>外部存储 也会为 安装的app 提供一块区域（文件夹） ，用来存放私有的文件<br>通常的路径是：**/storage/emulated/0/Android/data/包名/**</p>
<p>这里提供一下获取方式:</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_ALARMS)</td>
<td align="center">/storage/sdcard0/Alarms</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_DCIM)</td>
<td align="center">/storage/sdcard0/DCIM</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)</td>
<td align="center">/storage/sdcard0/Download</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_MOVIES)</td>
<td align="center">/storage/sdcard0/Movies</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_MUSIC)</td>
<td align="center">/storage/sdcard0/Music</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_NOTIFICATIONS)</td>
<td align="center">/storage/sdcard0/Notifications</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_PICTURES)</td>
<td align="center">/storage/sdcard0/Pictures</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_PODCASTS)</td>
<td align="center">/storage/sdcard0/Podcasts</td>
</tr>
<tr>
<td align="left">Environment.getExternalStoragePublicDirectory(DIRECTORY_RINGTONES)</td>
<td align="center">/storage/sdcard0/Ringtones</td>
</tr>
</tbody></table>
<h3 id="分区存储概览"><a href="#分区存储概览" class="headerlink" title="分区存储概览"></a>分区存储概览</h3><p>这里我们先看一张图，先大概有个概念</p>
<p><img src="%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95.awebp" alt="分区存储"></p>
<p>Android存储的改变基本上遵循了3个原则:<br>更好的从属性: 系统知道哪些文件属于哪些应用，这可以让用户更方便地管理他们的文件。当应用被卸载后，除非用户需要，否则应用之前所创建的文件也不应该保留在设备上；<br>保护应用数据: 当一个应用将 它所属的文件 写入外部存储时，这些文件是不应该被其他应用所访问的；<br>保护用户数据: 当用户下载了一些文件，比如带有敏感信息的邮件附件，这些文件应该对其他应用不可见。  </p>
<p>Android10分区存储对<strong>外部存储</strong>重新进行了设计</p>
<ul>
<li>私有存储 (Private Storage) : 每个应用在都拥有自己的私有目录，其它应用看不到，彼此也无法访问到该目录：内部存储私有目录 (/data/data/packageName) ；外部存储私有目录 (/sdcard/Android/data/packageName)，</li>
<li>共享存储 (Shared Storage) : 存储其他应用可访问文件， 包含媒体文件、文档文件以及其他文件，对应设备DCIM、Pictures、Alarms、Music、Notifications、Podcasts、Ringtones、Movies、Download等目录<h4 id="私有存储"><a href="#私有存储" class="headerlink" title="私有存储"></a>私有存储</h4>应用私有目录文件访问方式与之前Android版本一致，可以通过file path获取资源。<br>这里有个细节点，访问app自身外部私有目录是不需要要任何权限的。  </li>
</ul>
<p><strong>需要注意的不同点是：开启了分区存储特性后，应用只能访问自身的私有空间，即使获得了存储权限，也无法访问其他应用的私有空间</strong></p>
<h4 id="共有目录"><a href="#共有目录" class="headerlink" title="共有目录"></a>共有目录</h4><p>其实开启分区存储，对内部还有和外部私有目录是没有影响的。<br>这个目录有个明显的地方，该目录保存之后的文件，即使在app卸载后文件也依旧停留在了手机上，所以这也是被google团队重点关照的地方。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Apk安装的流程(前章)</title>
    <url>/2021/08/20/Android-Apk%E5%AE%89%E8%A3%85%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>最近自己又去阅读了Android源码，感觉以前有些困惑清晰了不少。<br>android源码庞大而复杂，一个源文件文件少则都是几千行代码。抓住核心很重要，那么多API的调用链根本记不完，不能一窥全貌，就只能迷失在森林之中，其实重要的是去梳理流程，搞清楚这个模块的设计初衷是为了什么，如果让你自己来你会怎么设计，如何写出高质量的代码。<br>思维上的提高才是本质上的进步！！！</p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>APK安装的方式其实有很多种，网上也有很多好的文章，不过学会才是最重要的，做出我们自己的总结。<br>从2021 年 8 月起 新应用需要使用 Android App Bundle 才能在 Google Play 中发布(<a href="https://developer.android.com/guide/app-bundle">Android ABB</a>)，在加上国内华为也支持了该ABB形式文件上架应用，后面也兴会成为主流。</p>
<p>关于相关的 Android App Bundle的知识可以点击这里<a href="https://zhupengbo.com/2021/07/19/google-aab/">🏷</a>)</p>
<h1 id="APK安装的方式"><a href="#APK安装的方式" class="headerlink" title="APK安装的方式"></a>APK安装的方式</h1><p>本章节只讲大致流程，代码流程我们后面再慢慢梳理</p>
<ul>
<li>安装方式</li>
</ul>
<ul>
<li>1.系统应用和预制应用的安装</li>
<li>2.通过商店</li>
<li>3.Adb</li>
<li>4.通过SD卡</li>
</ul>
<h1 id="🏷-科普"><a href="#🏷-科普" class="headerlink" title="🏷 科普"></a>🏷 科普</h1><h2 id="Android科普"><a href="#Android科普" class="headerlink" title="Android科普"></a>Android科普</h2><p><a href="https://blog.csdn.net/qq_28193019/article/details/102880179">安装目录的基本知识</a></p>
<p>既然是APK安装,有输入点就有输出点，所以就会有对应的目录，每个不同的目录存放这对应的文件。  </p>
<!-- | Class |     Name  | 
|:------------- |:---------------:|  -->

<table>
<thead>
<tr>
<th align="left">目录</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/system/app</td>
<td align="center">系统自带的应用程序,获得 root 权限才能删除</td>
</tr>
<tr>
<td align="left">/data/app</td>
<td align="center">第三方应用apk文件.安装时把apk文件复制到此目录</td>
</tr>
<tr>
<td align="left">/data/anr</td>
<td align="center">存放anr信息（/data/anr/traces.txt用于存放app ANR信息）</td>
</tr>
<tr>
<td align="left">/data/data</td>
<td align="center">应用程序数据</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}</td>
<td align="center">特定应用程序数据目录</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/cache</td>
<td align="center">临时文件，系统会自动清理</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/databases</td>
<td align="center">数据库</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/files</td>
<td align="center">一般文件</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/shared_pres</td>
<td align="center">SharedPreference</td>
</tr>
<tr>
<td align="left">/data/data/${package_name}/lib</td>
<td align="center">so文件</td>
</tr>
<tr>
<td align="left">/data/dalvik-cache</td>
<td align="center">存放odex文件.将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,ART模式的可执行文件格式为.aot,启动ART时,系统会执行dex文件转换至aot文件)</td>
</tr>
<tr>
<td align="left">/data/system/packages.list</td>
<td align="center">类似于Window的注册表,该文件是解析apk时由writeLP()创建的。记录了系统的permissons,以及解析apk的AndroidManifest获取的应用name,codePath,flag,ts,version,userid等信息。解析完apk后将更新信息写入这个文件并保存到flash,下次开机的时候直接从里面读取相关信息并添加到内存相关列表中.当有apk升级,安装或删除时会更新这个文件。</td>
</tr>
<tr>
<td align="left">/data/system/packages.xml</td>
<td align="center">指定应用的默认存储位置/data/data/com.xx.xx/package.xml中包含了该应用申请的权限,签名和代码所在的位置等信息系,并且两者都有同一个userld.</td>
</tr>
<tr>
<td align="left">/data/user/0</td>
<td align="center">软链接，指向/data/data</td>
</tr>
<tr>
<td align="left">/data/user_de/0/${package_name}</td>
<td align="center">设备存储保护区，在快速启动模式可以访问这个文件夹</td>
</tr>
<tr>
<td align="left">/proc/cpuinfo</td>
<td align="center">cpu信息</td>
</tr>
<tr>
<td align="left">/proc/smaps</td>
<td align="center">内存占用信息</td>
</tr>
<tr>
<td align="left">/sdcard</td>
<td align="center">软链接，最终指向/storage/emulated/0【跟Android版本和ROM版本有关】</td>
</tr>
<tr>
<td align="left">/storage/emulated/0</td>
<td align="center">外部存储的根目录</td>
</tr>
<tr>
<td align="left">/storage/emulated/0/Android/data/${package_name}</td>
<td align="center">应用的额外数据</td>
</tr>
<tr>
<td align="left">/system/app</td>
<td align="center">系统应用apk文件</td>
</tr>
<tr>
<td align="left">/system/lib</td>
<td align="center">系统应用so库</td>
</tr>
<tr>
<td align="left">————————————————</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>在/data/data/包名目录下，每个app都有自己的目录，目录名就是应用程序在AndroidManifest.xml文件中定义的包。每个应用程序的代码，对自己的目录是有绝对的控制权限的。在每个目录下，一般有如下几个子目录（结合上面的表格）：</p>
<p>databases : 存放数据库<br>cache : 存放缓存数据<br>files : 存放应用程序自己控制的文件<br>lib : 存放使用的包</p>
<h2 id="Linux科普"><a href="#Linux科普" class="headerlink" title="Linux科普"></a>Linux科普</h2><p>为什么这里需要了解Linux的知识点，<br>Linux进程有两个ID，一个就是用户ID，为每个用户的唯一标识符；<br>另一个是组ID，为用户组的唯一标识符</p>
<p>当你在手机点击一个APK之后,APK中的AndroidManifest.xml会被解析,在手机root之后，或者用模拟器打开根目录 <strong>/data/system/</strong> ，我们获得超级权限之后，可以在查看目前手机在系统已经注册的app，解析的内容会被存储到 <strong>/data/system/packages.xml</strong> 和 <strong>/data/system/packages.list</strong> 中。我们打开packages.list和packages.xml，我们已Apk的包名为索引，可以看到对应的内容。</p>
<p>packages.list</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">com</span>.game.dalan<span class="number">2</span>.s<span class="number">3</span> <span class="number">10130</span> <span class="number">1</span> /data/user/<span class="number">0</span>/com.game.dalan<span class="number">2</span>.s<span class="number">3</span> default <span class="number">3003</span></span><br></pre></td></tr></table></figure>

<p>packages.xml</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;package <span class="built_in">name</span>=<span class="string">&quot;com.game.dalan2.s3&quot;</span> codePath=<span class="string">&quot;/data/app/com.game.dalan2.s3-1&quot;</span> nativeLibraryPath=<span class="string">&quot;/data/app/com.game.dalan2.s3-1/lib&quot;</span> primaryCpuAbi=<span class="string">&quot;x86&quot;</span> publicFlags=<span class="string">&quot;940097350&quot;</span> privateFlags=<span class="string">&quot;0&quot;</span> ft=<span class="string">&quot;17b8267bd90&quot;</span> <span class="keyword">it</span>=<span class="string">&quot;17b586694ad&quot;</span> ut=<span class="string">&quot;17b8267cb67&quot;</span> <span class="built_in">version</span>=<span class="string">&quot;1&quot;</span> userId=<span class="string">&quot;10130&quot;</span>&gt;</span><br><span class="line">     &lt;sigs <span class="built_in">count</span>=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">         &lt;cert index=<span class="string">&quot;9&quot;</span> key=<span class="string">&quot;忽略&quot;</span> /&gt;</span><br><span class="line">     &lt;/sigs&gt;</span><br><span class="line">     &lt;perms&gt;</span><br><span class="line">         &lt;<span class="built_in">item</span> <span class="built_in">name</span>=<span class="string">&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">         &lt;<span class="built_in">item</span> <span class="built_in">name</span>=<span class="string">&quot;android.permission.CHANGE_NETWORK_STATE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">         &lt;<span class="built_in">item</span> <span class="built_in">name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">         &lt;<span class="built_in">item</span> <span class="built_in">name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">         &lt;<span class="built_in">item</span> <span class="built_in">name</span>=<span class="string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span> granted=<span class="string">&quot;true&quot;</span> flags=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">     &lt;/perms&gt;</span><br><span class="line">     &lt;proper-signing-keyset identifier=<span class="string">&quot;147&quot;</span> /&gt;</span><br><span class="line"> &lt;/package&gt;</span><br></pre></td></tr></table></figure>

<p>packages.list中指名了该应用默认存储的位置<br>packages.xml中包含了该应用申请的权限、签名和代码所在位置等信息，并且两者都有一个userId为10060。  </p>
<p>之所以每个应用都有一个userId，是因为Android在系统设计上把每个应用当作Linux系统上的一个用户对待，这样就可以利用已有的Linux上用户管理机制来设计Android应用，比如应用目录，应用权限，应用进程管理等。</p>
<p>这个解析的过程也可以理解为在APK在系统的注册。</p>
<p>相关知识点可以查看这里 <a href="https://stackoverflow.com/questions/12442979/android-understanding-the-apk-installation-process">Stack Overflow</a></p>
<h1 id="Apk安装的流程"><a href="#Apk安装的流程" class="headerlink" title="Apk安装的流程"></a>Apk安装的流程</h1><p>这里大致只讲流程，详细的代码我们后面再一一罗列出来:<br>简单来说分为四步：</p>
<p>1)将APK的信息通过IO流的形式写入到PackageInstaller.Session中。</p>
<p>2)调用PackageInstaller.Session的commit方法，将APK的信息交由PKMS处理。</p>
<p>3)拷贝APK</p>
<p>4)最后进行安装</p>
<h1 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h1><h2 id="什么是覆盖安装-？"><a href="#什么是覆盖安装-？" class="headerlink" title="什么是覆盖安装 ？"></a>什么是覆盖安装 ？</h2><p>无论在国内还是出海国外上架海外游戏App，我们在每次上架新版本的时候，都是需要<strong>versionCode</strong>+1,用户再通过商店渠道再把 versioncode+1的apk覆盖掉原先的apk,这个过程就是覆盖安装，。<br>不过还是有前置条件：<br>    1.包名跟旧的一致<br>    2.签名跟原来的一致<br>    3.组件不冲突</p>
<p>更详细的内容看这张表：</p>
<table>
<thead>
<tr>
<th align="left">正常安装</th>
<th align="center">覆盖安装</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">删除旧版本APK之后重新进行安装</td>
<td align="center">（不删除之前的旧版本包，直接安装）</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SQLite的数据也会被删除</td>
<td align="center">SQLite的数据不会丢失</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">shared_prefs中的数据会被删除</td>
<td align="center">shared_prefs中的数据不会丢失</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4.4之前的版本不会比较apk的Version_code</td>
<td align="center"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？"><a href="#部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？" class="headerlink" title="部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？"></a>部分手机在APK安装成功后提示清除安装包，要清除安装包的是在哪里？</h2><p>首先要清除对应的安装包，就得知道安装包的目录是在哪，计算机的世界有入口就有出口。<br>我们这里在做一些知识的扩展：<br>现在部分手机的App是具有分享Apk的功能，也就是传输本机上的apk，比如说QQ，还有一些第三方的软件具备之类的功能。手机安装app时，会在根目录和外存储器合生成文件夹。反过来说，你删除app的时候，这些对应生成文件夹也会被系统删除。根目录会放置app的安装包，而且统一命名为base.apk，还有一些重要的app用户数据。(你想查看，前提是开启root)<br>外存储器就是你能看到的文件夹，里面放置可操作的文件，例如保存的图片，视频。所以即使你安装app后删除安装包，也是删除了外存储器的安装包，QQ传输app安装包就是传输<strong>根目录</strong>的安装包。</p>
<h2 id="Android目录扫盲"><a href="#Android目录扫盲" class="headerlink" title="Android目录扫盲"></a>Android目录扫盲</h2><p>关于存储的目录，我们后面额外再开一张新的文章，android对于目录和权限其实做了不少的修改。<br>接下来这段是很多Code的误区</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Environment</span>.</span></span>get<span class="constructor">ExternalStorageDirectory()</span></span><br></pre></td></tr></table></figure>
<p>实际上是获取的手机自带的sd卡，这个自带的sd卡你在手机的文件管理应用里看，显示的中文名是“内部存储”，这个“内部存储”实际上就是手机自带的sd卡，也就是ExternalStorage
    </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发篇-1</title>
    <url>/2021/08/13/Java-%E5%B9%B6%E5%8F%91%E7%AF%87-1/</url>
    <content><![CDATA[<p><a href="https://www.zhihu.com/question/22950899">https://www.zhihu.com/question/22950899</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Activity</title>
    <url>/2021/08/11/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>在最近的任务栈里面看见的task未必还活着。<br>在最近的任务栈里面看不见的task未必就死了。</p>
<h2 id="android-launchMode"><a href="#android-launchMode" class="headerlink" title="android-launchMode"></a>android-launchMode</h2><p>在这里我推荐大家去看扔物线的课程: <a href="https://www.bilibili.com/video/BV1CA41177Se">Android 面试黑洞</a></p>
<p>Activity有4种启动模式，分别是：Standard、SingleTop、SingleTask和SingleInstance，它们控制了被启动Activity的启动行为。<br>Activity任务栈（Task）是一个标准的栈结构<br>用于在ActivityManagerService侧管理所有的Activity（AMS通过TaskRecord标识一个任务栈，通过ActivityRecord标识一个Activity）。</p>
<table>
<thead>
<tr>
<th align="left">launchMode</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE【知识扩展】</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Standard</td>
<td align="center">标准模式</td>
<td align="left">标准模式，也是系统的默认模式。该模式下，每次启动Activity，都会创建一个新实例，并且将其加入到启动该Activity的那个Activity所在的任务栈中，所以目标Activity的多个实例可以位于不同的任务栈。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SingleTop</td>
<td align="center">栈顶复用模式</td>
<td align="left">该模式下，若目标Activity的实例已经存在，但是没有位于栈顶，那么仍然会创建新的实例，并添加到任务栈；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SingleTask</td>
<td align="center">栈内复用模式</td>
<td align="left">clearTop的作用，整个任务栈只能有一个activity的实例。</td>
<td align="left">如果此时任务栈内已经存在 Activity C 的实例且未位于栈顶，当启动 Activity C 时，会将 Activity C 上方的实例全部出栈让其位于任务栈顶并 Activity C 中的 onNewIntent() 方法会被调用</td>
</tr>
<tr>
<td align="left">SingleInstance</td>
<td align="center">单一实例</td>
<td align="left">要求该Activity所在的Task只有有这么一个Activity，</td>
<td align="left">下面没有旧，上面没有新</td>
</tr>
</tbody></table>
<h2 id="MORE【知识扩展】"><a href="#MORE【知识扩展】" class="headerlink" title="MORE【知识扩展】"></a>MORE【知识扩展】</h2><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><p>当我们使用Application的Context来启动一个Activity的时候，会报AndroidRuntimeException，因为standard模式下启动的Activity，会默认进入启动它的Activity的任务栈中，而非Activity类型的context却并没有所谓的任务栈，所以就会出现问题，解决这个问题的方法是需要为要启动的Activity指定标记位：FLAG_ACTIVITY_NEW_TASK，这个标记的作用是为启动的Activity创建一个新的任务栈。</p>
<h3 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h3><p>该模式下，若目标Activity的实例已经存在，但是没有位于栈顶，那么仍然会创建新的实例，并添加到任务栈；</p>
<p>若目标Activity的实例已经存在，且位于栈顶，那么就不会创建新的实例，而是复用已有实例，并依次调用目标Activity的onPause -&gt; onNewIntent -&gt; onResume方法。<br>知识扩展！！！</p>
<p>singleTop模式的activity特点就是除了外部可以启动它显示信息外，它也可以用同样的方式启动自己更新显示信息，这样就减少了冗余代码，降低了维护成本。</p>
<p>他的onCreate、onStart方法不会被调用，避免多次初始化，应用宝用的就是这套方案。</p>
<h3 id="SingleTask-A和B都是不同的2个应用"><a href="#SingleTask-A和B都是不同的2个应用" class="headerlink" title="SingleTask A和B都是不同的2个应用"></a>SingleTask A和B都是不同的2个应用</h3><p>首先做个假设：A-Activity 启动 B_Activity,launchMode下文进行了标注<br>A_Activity[Standard] ==&gt; B_Activity[SingleTask]<br>B_Activity的Activity被启动时，不会进入启动A的Task里,而是创建属于B自己的Task里，置于B-Task栈顶,然后把整个B-Task 压到 A-Task上面,这种方式打开的方式是入场动画是应用间的切换。</p>
<p>如果这时按下返回键，这里回退的顺序是 B-Task 来回退，而不是返回原来的A_Activity[Standard]。原来的A要在前台显示，必须是B-Task的栈的Activity完全关闭才可以，这里场景动画也是场景间的切换。  </p>
<p>这里要明确一个概念：不止应用的Activity内部可以叠成栈，不同应用之间的Task也可以叠成栈。</p>
<p>Task的叠加只适用于前台的Task。</p>
<p>SingleTask是保证了一个栈内有且只有被该属性修饰Activity的实例对象，全局单例</p>
<h3 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h3><p>为了描述清晰，我们还是要举个例子:<br>A_Activity[Standard] ==&gt; B_Activity[SingleInstance]<br>还是 A 短信应用 打开 B 邮箱应用<br>邮件App不仅为了当前跳转的Activity创建对象，而且会创建一个单独的B-Task,然后把当前的打开应用的Activity的实例放到B-Task。<br>第二种情况是当前Activity已经被创建过了，则会回调当前应用的Activity生命周期的**onNewIntent()**方法</p>
<p>这2种情况的变化，这个B-Task都会被拿过来压在A-Task上面，入场动画是切换Task的动画。</p>
<p>假设用户这个时候点返回，上面的Task因为只有一个Activity，手机会直接回到短信App，入场动画是切换Task的动画。</p>
<p>假设用户没有直接点返回，而是选择查看了最近的任务又返回到之B-Task，这个时候短信的A-Task已经被退到后台，所以用户再点返回的话，又因为当前的Task内只有一个B-Activity，所以是直接回退到桌面。</p>
<p>假设用户又没有点返回，也没有选择查看任务，而是选择了在B-Task，又打开了一个C-App的Activity，由于SingleInstance的限制，所以C-task并不会叠在B-Task之上，而是另辟蹊径，而是装到另一个Task中，然后整个Task跌在B-Task上面。</p>
<p>知识点: 我来解释一下另辟蹊径的意思，这个时候相对邮箱App此时有2个Task，一个是独栈的，也就是短信调用的那个，还有一个是后台的Task，C的Activity是被放到了后台的Task。</p>
<blockquote>
<p>在最近的任务栈里面看不见的task未必就死了。这句话也是在这里体现。<br>在延伸出一个属性:Android:taskAffinity，</p>
</blockquote>
<h2 id="Android-taskAffinity属性"><a href="#Android-taskAffinity属性" class="headerlink" title="Android:taskAffinity属性"></a>Android:taskAffinity属性</h2><blockquote>
<p>在android里，一般情况下一个App默认只有一个Task，可以显示在最近的列表里面，但是用来甄别唯一性的不是App，而是<strong>taskAffinity</strong>，每一个Activity都有属于自己的Activity，相当于每个Activity的预先分组。<br><img src="taskAffinity%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99.png" alt="taskAffinity"><br>android:taskAffinity是Activity的一个属性，表示该Activity期望的任务栈的名称。<br>默认情况下，一个应用程序中所有Activity的taskAffinity都是相同的，即应用程序的包名。当然，我们可以在配置文件中为每个Activity指定不同的taskAffinity（只有和已有包名不同，才有意义）。<br><img src="taskAffinity%E6%9C%80%E8%BF%91%E5%88%97%E8%A1%A8.png" alt="taskAffinity"><br>另外每一个Task也有taskAffinity，他的值取自栈底的Activity的taskAffinity值，这个栈底Activity也就是第一个启动应用的Activity。</p>
</blockquote>
<p>另外一点taskAffinity也可以在androidManifest被定制。<br><img src="taskAffinity%E5%BC%80%E5%8F%91%E6%8E%A8%E8%8D%90.png" alt="taskAffinity">  </p>
<p>一般情况下，该属性主要和SingleTask启动模式或者android:allowTaskReparenting属性结合使用（下面会详细介绍），在其他情况下没有意义。</p>
<h3 id="Task-Reparenting"><a href="#Task-Reparenting" class="headerlink" title="Task - Reparenting"></a>Task - Reparenting</h3><p>B AndroidManifest属性 设置为android:allowTaskReparenting = True</p>
<p>场景具体化:A 短信应用 打开 B 邮箱应用</p>
<p>B还是会进入到A的Task里,但稍后用户从桌面点击B应用的时候，原先放在A-Task里面的B-Activity会被挪到B应用的Task的栈顶,这个时候你在切回短信Task，你会发现原先的B-Activity已经不见了。<br>(有争议… Android 8,9是有问题的，10以上正常)</p>
<h3 id="前台Task"><a href="#前台Task" class="headerlink" title="前台Task"></a>前台Task</h3><p>前台叠加的多个Task进入后台第一时间就会拆开</p>
<blockquote>
<p>1.按Home键回到桌面<br>2.按最近任务键 查看最近的任务  </p>
<ul>
<li>前台Task 在最近列表显示出来的时候就已经进入到了后台，而不是切到其他任务之后。</li>
</ul>
</blockquote>
<p>但是光知道理论还是不够的，由于我们开发的时候大部分的情况都是多变的，我们在前面的章节可以了解到不同的应用的Activity是启动Task内叠加的。</p>
<p>首先做个假设：A-Activity 启动 B_Activity,launchMode下文进行了标注<br>A_Activity[Standard] ==&gt; B_Activity[SingleTask]<br>我们再把场景具体化，A 短信应用 打开 B 邮箱应用，这个时间我们没有按下返回键，而是按最近任务键，再重新回去原来的Task，这个时候看起来没有变化，但是实际上A的Task已经被去除掉了，只留下B的Task，这个时候我们再按下返回键，把B的Task内的Activity全部关闭，这个时候返回的系统的桌面而不是短信的APP。</p>
<h2 id="Android十万个为什么系列"><a href="#Android十万个为什么系列" class="headerlink" title="Android十万个为什么系列"></a>Android十万个为什么系列</h2><h3 id="当前-app-正在前台运行，不在栈顶的-Activity-有可能会因为系统资源，例如内存等不足回收吗？"><a href="#当前-app-正在前台运行，不在栈顶的-Activity-有可能会因为系统资源，例如内存等不足回收吗？" class="headerlink" title="当前 app 正在前台运行，不在栈顶的 Activity 有可能会因为系统资源，例如内存等不足回收吗？"></a>当前 app 正在前台运行，不在栈顶的 Activity 有可能会因为系统资源，例如内存等不足回收吗？</h3><p>我现在还记得这个问题，那年我毕业，投了心仪公司的简历，过了Hr的面试，来到了技术环节，和蔼的面试官问了:我们日常开发比较多组件的是Activity，假设 App 正在前台运行，不在栈顶的Activity有可能会被回收吗?<br>那时年少，我感觉我天灵盖被人开了，当场差点直接自闭，懵逼，接下来回答支支吾吾，面试结果是显而易见的。。。  <strong>(ಥ_ಥ)</strong><br>回去的路上越想越不对劲，到家之后立马查源码，好家伙找到了！平时不看源码，关键时刻被别人搞得一愣一愣！</p>
<p>凡事先说结论: 会 ！！！<br>这里看的源码是API30,在网上也看到一些相关答案答案，这里我们提炼一下要点，重点我们日常开发对场景预测，比方说游戏A-APP开启了一个B-App应用的界面，这个时候B-App开启了一个比较消耗耗内存的线程，如果这个内存不断地增大，最后游戏A-App的生命周期onDestroy()就会被调用。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> attach(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq) &#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//ApplicationThread是ActivityThread和AMS沟通的桥梁</span></span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Watch for getting close to heap limit.</span></span><br><span class="line">            BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                @Override <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">Runtime</span> <span class="keyword">runtime</span> = <span class="keyword">Runtime</span>.getRuntime();</span><br><span class="line">                    <span class="keyword">long</span> dalvikMax = <span class="keyword">runtime</span>.maxMemory();</span><br><span class="line">                    <span class="keyword">long</span> dalvikUsed = <span class="keyword">runtime</span>.totalMemory() - <span class="keyword">runtime</span>.freeMemory();</span><br><span class="line">                    <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">&quot;Dalvik max=&quot;</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                                + <span class="string">&quot; total=&quot;</span> + (<span class="keyword">runtime</span>.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                                + <span class="string">&quot; used=&quot;</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                        mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ActivityTaskManager.getService().releaseSomeActivities(mAppThread);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="当-app-处于后台运行，app-进程未被杀死，其内部的-Activity-会被回收吗？"><a href="#当-app-处于后台运行，app-进程未被杀死，其内部的-Activity-会被回收吗？" class="headerlink" title="当 app 处于后台运行，app 进程未被杀死，其内部的 Activity 会被回收吗？"></a>当 app 处于后台运行，app 进程未被杀死，其内部的 Activity 会被回收吗？</h3><h3 id="当-app-处于后台运行，app-的进程会被杀死吗？"><a href="#当-app-处于后台运行，app-的进程会被杀死吗？" class="headerlink" title="当 app 处于后台运行，app 的进程会被杀死吗？"></a>当 app 处于后台运行，app 的进程会被杀死吗？</h3>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机杂谈-进程与线程</title>
    <url>/2021/08/04/Android%E6%9D%82%E8%B0%88-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>名词是对客观事物的指代，形容词是对客观事物的描述。</p>
<p>进程和线程又分别是什么? 进程和线程区别到底是什么?<br>带着简单的疑问，我们慢慢往下看看，本文不会过多章节去分析代码，而是比较多去谈自己的理解！</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程是<strong>操作系统</strong>分配资源的单位,线程是调度的基本单位,线程之间共享进程资源。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>其实就这么简单的一句话，就可以引申出很多概念。<br>逆向思维(反推)，从已有的结果出发挖掘更多的可能性.  </p>
<blockquote>
<p>到底线程之间共享了哪些进程资源？<br>共享资源意味着什么？<br>共享资源这种机制是如何实现的？<br>线程有哪些是线程私有的  </p>
</blockquote>
<h3 id="计算机扩展概念"><a href="#计算机扩展概念" class="headerlink" title="计算机扩展概念"></a>计算机扩展概念</h3><p>其实无论是谈生意也好，还是谈工作也好，首先必须要解决一个问题，就是明确主题和双方信息差的问题！<br>为了更好的理解，我们需要了解一些基础的计算机知识(linux)。具体文献请参考原文</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><a href="http://www.linfo.org/cpu.html">CPU</a></h3><blockquote>
<p>A CPU contains three main sections: (1) <strong>an arithmetic/logic unit</strong>, (2) <strong>a control unit</strong> and (3) <strong><a href="http://www.linfo.org/register.html">registers</a></strong>. The arithmetic/logic unit contains circuitry that performs data manipulation. The control unit consists of circuitry for coordinating the machine’s activities. The registers are high speed memory cells that are used for holding instructions for data that is currently being processed.<br>CPU 包含三个主要部分：(1)<strong>算术/逻辑单元</strong>，(2)<strong>控制单元</strong>和 (3)<strong>寄存器</strong>。<br>算术/逻辑单元包含执行数据操作的电路。<br>控制单元由用于协调机器活动的电路组成。<br>寄存器是<strong>高速存储</strong>单元，用于保存当前正在处理的数据的指令。</p>
</blockquote>
<h3 id="Register-Definition-—-寄存器"><a href="#Register-Definition-—-寄存器" class="headerlink" title="Register Definition — 寄存器"></a><a href="http://www.linfo.org/register.html">Register Definition</a> — 寄存器</h3><blockquote>
<p>A register is a very small amount of very fast memory that is built into the CPU (central processing unit) in order to speed up its operations by providing quick access to commonly used values.<br>寄存器是非常快又微型的存储器内置于Cpu，是通过访问快速提供的值,已加快Cpu(中央处理单元)的操作</p>
</blockquote>
<p>作用:寄存器是<strong>高速存储</strong>单元，用于保存当前正在处理的数据的指令。</p>
<p>专用寄存器存储内部 CPU 数据，例如程序计数器（也称为指令指针）、堆栈指针和状态寄存器。</p>
<h4 id="寄存器概念扩展"><a href="#寄存器概念扩展" class="headerlink" title="寄存器概念扩展"></a>寄存器概念扩展</h4><p>寄存器是存储器层次结构的顶部，是系统操作数据的最快方式。<br>在它们下面是几个级别的高速缓存，至少其中一些也内置在 CPU 中，而其中一些可能在其他专用芯片上。高速缓存比寄存器慢，但要丰富得多。在不同级别的高速缓存之下是主存储器，它更慢但更丰富（例如，与只有 32 个寄存器相比，数百兆字节）。但反过来，它仍然比存储设备和媒体（例如，硬盘驱动器和 CDROM）快得多，容量也小得多。</p>
<h4 id="其他作用"><a href="#其他作用" class="headerlink" title="其他作用"></a>其他作用</h4><p><strong>指令寄存器</strong>保存CPU正在执行的指令。<br><strong>地址寄存器</strong>保存内存地址，用于访问内存。<br><strong>数据寄存器</strong>用于存储整数。  </p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote>
<p>线程运行的本质就是函数。<br>函数的执行总会有一个源头，这个源头就是所谓的入口函数，相当于java的main的函数，<em>CPU</em> 从入口函数开始执行从而形成一个执行流，只不过我们人为的给执行流起一个名字，这个名字就叫线程。  </p>
</blockquote>
<h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><p>凡事从本质出发，我们就要去分析函数包含了些哪些信息。线程之间既然共享了进程资源，那就会对应不共享的资源，也就是线程私有资源<br>函数运行时的信息包含了栈帧中，栈帧中保存了函数的返回值，调用其他函数的参数，局部变量，该函数的寄存器初始值。  </p>
<p><img src="%E5%87%BD%E6%95%B0%E4%BF%A1%E6%81%AF.jpeg" alt="函数信息"></p>
<p>这里延伸出一个问题，因为线程是可以被操作系统随时暂停运行的和恢复运行的，那是怎么做到的？<br>可以通过保存以及恢复程序计数器的值就可以知道线程的从哪里运行又从哪里开始。</p>
<p>由于每个线程的本质都是函数的运行，函数运行时的信息是保存在栈中的，因此<strong>每个线程都有对应自己独立，私有的栈区</strong></p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%8C%BA.jpeg" alt="线程私有"></p>
<p>同时像函数的局部变量也是存放到寄存器之中，运行完就释放掉，回收内存。</p>
<p>所属线程的栈区，程序计数器，栈指针以及函数运行使用的寄存器都是线程私有的。</p>
<h3 id="线程间的共享"><a href="#线程间的共享" class="headerlink" title="线程间的共享"></a>线程间的共享</h3><h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h4><p>编译后的可执行机器指令,从可执行文件中加载到内存的，可执行程序中的代码区就是用来初始化进程地址空间中的代码区的。</p>
<h4 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h4><p>进程地址空间中的数据区，这里存放的就是所谓的全局变量。<br>全局变量简单的理解，一般不会被系统回收的变量，即使函数执行完后该变量依然存在，对于其他线程也是可见的 </p>
<h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>对象存放的地址空间，可被GC。<br>变量的地址，也就是指针。<br>任何一个线程都可以访问指针指向的数据，因此堆区也是线程共享的属于进程的资源。</p>
<h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>因为线程不像进程，进程是互相隔离，且独立。<br>如果一个线程能拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说这些线程可以任意修改本属于另一个线程栈区中的变量。<br>一个线程的栈区对其它线程是可以见的，也就是说我们可以修改属于任何一个线程的栈区  </p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>如果程序在运行过程中打开了一些文件，那么进程地址空间中还保存有打开的文件信息，进程打开的文件也可以被所有的线程使用，这也属于线程间的共享资源。</p>
<p>如图<br><img src="%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB.jpeg" alt="线程共享"><br>线程共享的地址，除了线程上下文的信息  </p>
<p>对于这个地方，我们引入java虚拟机<br>如图<br><img src="jvm.jpeg" alt="线程共享">  </p>
<p>这里再扩展一下,jdk.1.8.0其实以及取消了方法区,与之对于的是元空间</p>
<ul>
<li>以下jdk1.8 的标准（）<ul>
<li> 移除了永久代（PermGen），替换为元空间（Metaspace）；</li>
<li> 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li>
<li> 永久代中的 interned Strings 和 class static variables 转移到了 Java heap；<br>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize） </li>
</ul>
</li>
</ul>
<p><img src="jdk-1.8.0.png" alt="jdk-1.8.0.png">  </p>
<p>其实以下的概念我们都在上文讲过:</p>
<h3 id="java线程私有："><a href="#java线程私有：" class="headerlink" title="java线程私有："></a>java线程私有：</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>• 程序计数器：<br>    1. 每一个线程都需要有独立的计数器，各个线程互不干扰，独立存储<br>    2. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制<br>    3. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡 </p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>• Java虚拟机栈：<br>• 描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。<br>• 栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。<br>• Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。  </p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>• 本地方法栈<br>• 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。  </p>
<ul>
<li>线程共享:<br>• 堆<br>• 方法区<br>• 直接内存(非运行时数据区）<br>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。<br>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。    </li>
</ul>
<!-- ### Android十万个为什么 
#### Android中的context
很多人面试包括开发，最常遇到的一个名词就是Context，就是android的上下文，但是很多开发者其实不知道Context代表了什么意思，这里我的理解是 (格外提一点 寄存器是多个，不是一个)
> 线程的栈区 + 程序计数器 + 栈指针 + 函数运行使用的寄存器 = 上下文

Android操作系统可以随时中断并且回复正常，依靠的就是线程上下文。

这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了的进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存 -->

<!-- 作者：zhonyong
链接：https://www.zhihu.com/question/25532384/answer/81152571
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统Binder驱动分析(2)</title>
    <url>/2021/07/31/Android%E7%B3%BB%E7%BB%9FBinder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90-2/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我的文章比较多是对自己知识的梳理，有些概念没讲得那么清楚，但会贴出参考的链接，请大家自便</p>
<h1 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote>
<p>IPC : Inter-Process Communication (进程间的通信)<br>RPC : Remote Procedure Call (远程过程调用)<br>RPC是IPC的基础上进行了封装</p>
</blockquote>
<h3 id="简单例子-大致有个概念"><a href="#简单例子-大致有个概念" class="headerlink" title="简单例子: 大致有个概念"></a>简单例子: 大致有个概念</h3><p>再简单的分析下要素 (led是例子)</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="keyword">A</span>(①封装数据 ②发送给B) ===&gt;(IPC) B(①取出数据 @调用数据) </span><br><span class="line">源 : <span class="keyword">A</span>   </span><br><span class="line">目的 B 先向 ServerManger注册led服务  </span><br><span class="line">    <span class="keyword">A</span> 向 ServerManger 查询led服务,得到一个Handler  </span><br><span class="line">数据：char_Buff   --&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Binder究竟是什么"><a href="#Binder究竟是什么" class="headerlink" title="Binder究竟是什么"></a>Binder究竟是什么</h2><p>Binder是Android系统中负责每个<strong>用户进程</strong>与<strong>内核</strong>通信的驱动模块。 </p>
<h3 id="Binder的优势"><a href="#Binder的优势" class="headerlink" title="Binder的优势"></a>Binder的优势</h3><p><a href="https://blog.csdn.net/universus/article/details/6211589">推荐文章</a><br>主要是基于性能、稳定性和安全性几方面的原因。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><table>
<thead>
<tr>
<th align="left">IPC</th>
<th align="center">数据拷贝次数</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">共享内存</td>
<td align="center">0</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Binder</td>
<td align="center">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Socket</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">管道</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">消息队列</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>Binder 基于 C/S 架构，架构清晰、职责明确又相互独立</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。<br>首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。<br>Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。</p>
<!-- (App UID 可 **packagename** 包名来区分)  -->
<p>传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。<br>可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>以下对比 Binder IPC 对比 传统IPC 的区别</p>
<h3 id="Linux-下的传统-IPC-通信原理"><a href="#Linux-下的传统-IPC-通信原理" class="headerlink" title="Linux 下的传统 IPC 通信原理"></a>Linux 下的传统 IPC <a href="https://zhuanlan.zhihu.com/p/35519585">通信原理</a></h3><p><img src="%E4%BC%A0%E7%BB%9FIPC.jpg" alt="Linux传统 IPC"></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<p>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；<br>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。  </p>
<h2 id="专栏-Android十万个为什么"><a href="#专栏-Android十万个为什么" class="headerlink" title="专栏:Android十万个为什么"></a>专栏:Android十万个为什么</h2><h3 id="什么是实名Binder"><a href="#什么是实名Binder" class="headerlink" title="什么是实名Binder?"></a>什么是实名Binder?</h3><h3 id="什么是匿名Binder？"><a href="#什么是匿名Binder？" class="headerlink" title="什么是匿名Binder？"></a>什么是匿名Binder？</h3><h3 id="“内核缓存区”-和-“数据接收缓存区”-存在的意义"><a href="#“内核缓存区”-和-“数据接收缓存区”-存在的意义" class="headerlink" title="“内核缓存区” 和 “数据接收缓存区” 存在的意义"></a>“内核缓存区” 和 “数据接收缓存区” 存在的意义</h3><p>Linux是使用的虚拟内存寻址方式，虚拟内存需要映射一块真的的物理内存，<br>内核缓存区和数据接收区的映射就是指向了同一块物理内存。接收方下次也可能是发送方，如果共用一块缓存那么岂不是发送方，内核，接收方都指向了同一块物理内存，违反了进程隔离的设计原则。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-崩溃优化</title>
    <url>/2021/07/29/Android-%E5%A5%94%E6%BA%83%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="崩溃优化"><a href="#崩溃优化" class="headerlink" title="崩溃优化"></a>崩溃优化</h1><h2 id="Android-崩溃分析"><a href="#Android-崩溃分析" class="headerlink" title="Android 崩溃分析"></a>Android 崩溃分析</h2><p>Android 崩溃基本分为 <strong>Java 崩溃</strong>和 <strong>Native 崩溃</strong><br>简单来说，Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出。<br>那 Native 崩溃又是怎么产生的呢？一般都是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，<br>这些都会产生相应的 <strong>signal 信号</strong>，导致程序异常退出。</p>
<h3 id="Native-崩溃"><a href="#Native-崩溃" class="headerlink" title="Native 崩溃"></a>Native 崩溃</h3><blockquote>
<ol>
<li>在 Unix-like 系统中，所有的崩溃都是编程错误或者硬件错误相关的，系统遇到不可恢复的错误时会触发崩溃机制让程序退出，如除零、段地址错误等。</li>
<li>异常发生时，CPU 通过异常中断的方式，触发异常处理流程。不同的处理器，有不同的异常中断类型和中断处理方式。</li>
<li>linux 把这些中断处理，统一为信号量，可以注册信号量向量进行处理。</li>
<li>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。  </li>
</ol>
</blockquote>
<h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="signal.png" alt="信号机制"> </p>
<h5 id="1-信号的接收"><a href="#1-信号的接收" class="headerlink" title="(1) 信号的接收"></a>(1) 信号的接收</h5><p>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入<strong>内核态</strong> 。<br>！！！注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<h5 id="2-信号的检测"><a href="#2-信号的检测" class="headerlink" title="(2) 信号的检测"></a>(2) 信号的检测</h5><p>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<p>1.进程从内核态返回到用户态前进行信号检测</p>
<p>2.进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</p>
<p>当发现有新信号时，便会进入下一步，信号的处理。</p>
<h5 id="3-信号的处理"><a href="#3-信号的处理" class="headerlink" title="(3) 信号的处理"></a>(3) 信号的处理</h5><p>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<p>四、捕捉native crash<br>1.注册信号处理函数<br>第一步就是要用信号处理函数捕获到native crash(SIGSEGV, SIGBUS等)。在posix系统，可以用sigaction()：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"><span class="keyword">int</span> sigaction(<span class="keyword">int</span> signum,<span class="keyword">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact));</span><br></pre></td></tr></table></figure>
<p>signum：代表信号编码，可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号，如果为这两个信号定义自己的处理函数，将导致信号安装错误。</p>
<p>act：指向结构体sigaction的一个实例的指针，该实例指定了对特定信号的处理，如果设置为空，进程会执行默认处理。</p>
<p>oldact：和参数act类似，只不过保存的是原来对相应信号的处理，也可设置为NULL。</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">struct sigaction s<span class="built_in">a_old</span><span class="comment">;  </span></span><br><span class="line">memset(&amp;sa, <span class="number">0</span>, sizeof(sa))<span class="comment">;  </span></span><br><span class="line">sigemptyset(&amp;sa.s<span class="built_in">a_mask</span>)<span class="comment">;  </span></span><br><span class="line">sa.s<span class="built_in">a_sigaction</span> = my_handler<span class="comment">;  </span></span><br><span class="line">sa.s<span class="built_in">a_flags</span> = S<span class="built_in">A_SIGINFO</span><span class="comment">;</span></span><br><span class="line">if (sigaction(sig, &amp;sa, &amp;s<span class="built_in">a_old</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.设置额外栈空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaltstack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">stack_t</span> *ss, <span class="keyword">stack_t</span> *oss)</span></span>;</span><br></pre></td></tr></table></figure>
<p>SIGSEGV很有可能是栈溢出引起的，如果在默认的栈上运行很有可能会破坏程序运行的现场，无法获取到正确的上下文。而且当栈满了（太多次递归，栈上太多对象），系统会在同一个已经满了的栈上调用SIGSEGV的信号处理函数，又再一次引起同样的信号。</p>
<p>我们应该开辟一块新的空间作为运行信号处理函数的栈。可以使用sigaltstack在任意线程注册一个可选的栈，保留一下在紧急情况下使用的空间。（系统会在危险情况下把栈指针指向这个地方，使得可以在一个新的栈上运行信号处理函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">stack_t</span> stack;  </span><br><span class="line"><span class="built_in">memset</span>(&amp;stack, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stack));  </span><br><span class="line"><span class="comment">/* Reserver the system default stack size. We don&#x27;t need that much by the way. */</span>  </span><br><span class="line">stack.ss_size = SIGSTKSZ;  </span><br><span class="line">stack.ss_sp = <span class="built_in">malloc</span>(stack.ss_size);  </span><br><span class="line">stack.ss_flags = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">/* Install alternate stack size. Be sure the memory region is valid until you revert it. */</span>  </span><br><span class="line"><span class="keyword">if</span> (stack.ss_sp != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">sigaltstack</span>(&amp;stack, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.兼容其他signal处理</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static void my<span class="constructor">_handler(<span class="params">const</span> <span class="params">int</span> <span class="params">code</span>, <span class="params">siginfo_t</span> <span class="operator">*</span><span class="params">const</span> <span class="params">si</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">const</span> <span class="params">sc</span>)</span> &#123;<span class="operator"></span></span><br><span class="line"><span class="operator">...  </span></span><br><span class="line"><span class="operator">  </span><span class="comment">/* Call previous handler. */</span>  </span><br><span class="line">  old_handler.sa<span class="constructor">_sigaction(<span class="params">code</span>, <span class="params">si</span>, <span class="params">sc</span>)</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某些信号可能在之前已经被安装过信号处理函数，而sigaction一个信号量只能注册一个处理函数，这意味着我们的处理函数会覆盖其他人的处理信号</p>
<p>保存旧的处理函数，在处理完我们的信号处理函数后，在重新运行老的处理函数就能完成兼容。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 与 Unity 的交互</title>
    <url>/2021/07/29/Android%E4%B8%8EUnity%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Unity</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统Binder驱动分析(1)</title>
    <url>/2021/07/29/Android%E7%B3%BB%E7%BB%9FBinder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="提前掌握Binder的基础知识-预习"><a href="#提前掌握Binder的基础知识-预习" class="headerlink" title="提前掌握Binder的基础知识(预习)"></a>提前掌握Binder的基础知识(预习)</h1><p>Android系统架构的底层就是linux,本篇文章如有不懂的地方，建议参考<a href="http://www.linfo.org/">原文文档</a>,以便更好帮助自己学习。<br>希望能跟大家多多交流 !!!  </p>
<h2 id="Linux的基础知识"><a href="#Linux的基础知识" class="headerlink" title="Linux的基础知识"></a>Linux的基础知识</h2><p>Binder究竟是什么<br>什么是linux的系统内存<br>内核空间是什么<br>进程隔离<br>用户空间是什么</p>
<h2 id="Binder究竟是什么"><a href="#Binder究竟是什么" class="headerlink" title="Binder究竟是什么"></a>Binder究竟是什么</h2><p>Binder是Android系统中负责每个<strong>用户进程</strong>与<strong>内核</strong>通信的机制(驱动)</p>
<h2 id="内核空间是什么"><a href="#内核空间是什么" class="headerlink" title="内核空间是什么"></a>内核空间是什么</h2><p><a href="http://www.linfo.org/kernel_space.html">内核空间</a></p>
<blockquote>
<p>System memory in Linux can be divided into two distinct regions: kernel space and user space. Kernel space is where the kernel (i.e., the core of the operating system) executes (i.e., runs) and provides its services.<br>系统内存在的Linux可以分为两个不同的区域：<strong>内核空间</strong>和<strong>用户空间</strong>。内核空间是内核（即操作系统的核心）执行（即运行）并提供其服务的地方。</p>
</blockquote>
<h3 id="内核的作用是什么"><a href="#内核的作用是什么" class="headerlink" title="内核的作用是什么:"></a>内核的作用是什么:</h3><blockquote>
<p>One of the roles of the kernel is to manage individual user processes within this space and to prevent them from interfering with each other.<br>内核的作用之一是管理该空间内的各个用户进程并防止它们相互干扰。<br>这里涉及到一个概念 : <strong>进程隔离</strong></p>
</blockquote>
<h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
</blockquote>
<h4 id="内核空间的误区"><a href="#内核空间的误区" class="headerlink" title="内核空间的误区"></a>内核空间的误区</h4><blockquote>
<p>The kernel is a program that constitutes the central core of a computer operating system. It is not a process, but rather a controller of processes, and it has complete control over everything that occurs on the system. This includes managing individual user processes within user space and preventing them from interfering with each other.</p>
</blockquote>
<p>内核是构成计算机操作系统中央核心的程序。它不是一个进程，而是一个进程的控制器，它可以完全控制系统上发生的一切。这包括管理用户空间内的单个用户进程并防止它们相互干扰。</p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p><a href="http://www.linfo.org/user_space.html">用户空间</a></p>
<blockquote>
<p>User space is that portion of system memory in which user processes run<br>用户空间是用户进程在其中运行的系统内存部分</p>
</blockquote>
<h3 id="用户空间跟用户进程的区别"><a href="#用户空间跟用户进程的区别" class="headerlink" title="用户空间跟用户进程的区别"></a>用户空间跟用户进程的区别</h3><blockquote>
<p> User space is that set of memory locations in which user processes (i.e., everything other than the kernel) run<br>用户空间是一组内存位置，用户进程（即内核以外的所有东西）在其中运行。<br>每个正在运行的App都是一个用户进程,再不干涉的情景下，互相独立互不影响，都有属于自己的进程的用户空间。</p>
</blockquote>
<h2 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用/内核态/用户态"></a>系统调用/内核态/用户态</h2><blockquote>
<p>Kernel space can be accessed by user processes only through the use of system calls<br>用户空间访问内核空间的唯一方式就是系统调用</p>
</blockquote>
<p><strong>内核态</strong> : 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行<br><strong>用户态</strong> : 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。<br>处理器在特权等级高的时候才能执行那些特权CPU指令。 </p>
<h2 id="扩展概念"><a href="#扩展概念" class="headerlink" title="扩展概念"></a>扩展概念</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用是 <strong>类 Unix</strong> 操作系统中活动进程对内核执行的服务的请求，例如输入/输出(I/O) 或进程创建。活动进程是当前在 CPU 中进行的进程，与在 CPU 中等待其下一次运行的进程相反。I/O 是将数据传入或传出 CPU 以及传入或传出外围设备（如磁盘驱动器、键盘、鼠标和打印机）的任何程序、操作或设备。<br>系统调用主要通过如下两个函数来实现:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">copy_from_user</span><span class="params">()</span></span> <span class="comment">// 将数据从用户空间拷贝到内核空间</span></span><br><span class="line"><span class="function"><span class="title">copy_to_user</span><span class="params">()</span></span> <span class="comment">// 将数据从内核空间拷贝到用户空间</span></span><br></pre></td></tr></table></figure>
<h3 id="Linux-使用两级保护机制："><a href="#Linux-使用两级保护机制：" class="headerlink" title="Linux 使用两级保护机制："></a>Linux 使用两级保护机制：</h3><p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<h3 id="Linux-内存映射"><a href="#Linux-内存映射" class="headerlink" title="Linux 内存映射"></a>Linux 内存映射</h3><p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h3 id="动态内核可加载模块"><a href="#动态内核可加载模块" class="headerlink" title="动态内核可加载模块"></a>动态内核可加载模块</h3><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。<br>它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>android-Handler机制-2</title>
    <url>/2021/07/27/android-Handler%E6%9C%BA%E5%88%B6-2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Message</td>
<td align="center">消息</td>
<td align="left">使用了享元设计模式 链表的数据结构</td>
<td align="left">详情</td>
</tr>
<tr>
<td align="left">MessageQuene</td>
<td align="center">消息队列</td>
<td align="left">单链表的数据结构</td>
<td align="left">优先级的队列 — 根据时间先后顺序排队的单链表</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="center">message的处理者</td>
<td align="left">即线程间传递的对象，传递的信息包含在其中    Handler的构造函 ，在构造函数中初始化了一个Looper 和 MessageQueue。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ThreadLocal</td>
<td align="center">数据结构是键值对</td>
<td align="left">只有在指定的线程可以获取到存储的数据</td>
<td align="left">获取线程唯一的变量 Theadlocal value 线程内部的数据存储类,使用场景：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本</td>
</tr>
<tr>
<td align="left">Looper</td>
<td align="center">循环器</td>
<td align="left"><img src="code_looper_1.jpg" alt="code_looper"></td>
<td align="left">类Looper的prepare的函数,即是对Looper进行了初始化，将Looper对象引用保存在sThreadLocal中，先保证了Looper和Threadlocal-1V1关系,由于sThreadLocal获取的值是通过获取当前线程获取线程唯一的变量,这样就保证了一个线程只有一个looper</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-外挂篇</title>
    <url>/2021/07/27/android-%E5%A4%96%E6%8C%82%E7%AF%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-APK构建流程</title>
    <url>/2021/07/26/android-APK%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Apk构建流程"><a href="#Apk构建流程" class="headerlink" title="Apk构建流程"></a>Apk构建流程</h1><h2 id="Apk是什么"><a href="#Apk是什么" class="headerlink" title="Apk是什么"></a>Apk是什么</h2><p>维基百科，自由的百科全书<br>跳到导航跳到搜索<br>APK<br>APK format icon (2014-2019).png<br>扩展名    .apk、.xapk、.apks、.apkm<br>互联网媒体类型    application/vnd.android.package-archive<br>格式类型    包管理器 存档文件<br>专门属    软件包<br>延伸自    JAR 和 ZIP</p>
<p>APK 文件基于 ZIP 文件格式，它与JAR文件的构造方式相似。它的互联网媒体类型是：application/vnd.android.package-archive[5]。</p>
<p>扩展资料:<br>    Android5.0引入了Split APK机制，这是为了解决65536上限以及APK安装包越来越大等问题。Split APK机制可以将一个APK，拆分成多个独立APK。<br>    在引入了Split APK机制后，APK有两种分类：</p>
<pre><code>Single APK：安装文件为一个完整的APK，即base APK。Android称其为Monolithic。
Mutiple APK：安装文件在一个文件目录中，其内部有多个被拆分的APK，这些APK由一个 base APK和一个或多个split APK组成。Android称其为Cluster。
</code></pre>
<h2 id="Apk构成的属性"><a href="#Apk构成的属性" class="headerlink" title="Apk构成的属性"></a>Apk构成的属性</h2><pre><code>META-INF目录：包含两个签名文件（CERT.SF和CERT.RSA），以及一个manifest文件（MANIFEST.MF）
                  
assets目录：包含工程中的asset目录下的文件，可以使用AssetManager获取
                  
res目录：包含那些没有被编译到resources.arsc的资源
                
lib目录：包含适用于不同处理器的第三方依赖库，这里边可以有多个子目录，比如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, 以及mips
              
resources.arsc文件：存储编译好的资源，包括项目工程中的res/values目录里的xml文件，它们都被编译成二进制格式，也包括一些路径，指向那些没有被编译的资源，比如layout文件和图片
              
classes.dex文件：项目中的java类都被编译到该dex文件，这个文件可以被Android的Dalvik/ART虚拟机解析。
            
AndroidManifest.xml：二进制格式的manifest文件，这个文件是必须的。
        
这些文件是Android系统运行一个应用程序时会用到的数据和代码，下面介绍系统如何安装一个APK包。
</code></pre>
<h2 id="Apk编译的流程"><a href="#Apk编译的流程" class="headerlink" title="Apk编译的流程"></a>Apk编译的流程</h2><ol>
<li>通过<strong>aapt-Android Asset Packing Tool</strong> 打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）  </li>
</ol>
<blockquote>
<p>这一过程主要是aapt对res和asset文件夹，AndroidManifest.xml，android库(aar,jar)等的资源文件进行处理。  </p>
<ul>
<li>先检查<strong>AndroidManifest.xml</strong>的合法性  </li>
<li>然后编译res与asserts目录下的资源并生成resource.arsc文件  </li>
<li>再生成R文件。</li>
</ul>
</blockquote>
<p>除了assets和res/raw资源被原封不动地打包进APK之外，其它的资源都会被编译或者处理，<em>大部分文本格式的XML资源文件会被编译成二进制格式的XML资源文件</em>。<br>除了assets资源之外，其他的资源都会在R文件中被赋予一个资源ID。也就是说，R文件中只会存在id，真正的资源存在于resource.arsc中，resource.arsc相当于一个资源索引表，资源id是key，value是资源路径。我们使用drawable-xdpi或者drawable-xxdpi这些不同分辨率的图片的时候，就是依靠resource.arsc根据设备的分辨率选择不同的图片</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190915004258.png" alt="R.java"><br> (R.java相关知识)<br>2. 处理.aidl文件，生成对应的Java接口文件<br>3. 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 (编译期超出64k?)<br>4. 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex<br>5. 通过<strong>Japkbuilder</strong>J工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk<br>6. 通过<strong>Jarsigner</strong>工具，对上面的apk进行debug或release签名<br>通过zipalign工具，将签名后的apk进行对齐处理<br>(引申出问题，为什么需要签名，签名的方式有几种，有什么区别？)<br>7. 通过<strong>zipalign</strong>工具，将签名后的apk进行对齐处理<br>(引申一个问题，为什么需要对齐？)<br>8. 混淆proguard：proguard主要的目的是混淆代码，保护应用源代码。次要的功能还有移除无用类等，优化字节码，缩小包体积。  </p>
<h1 id="APK扩展性问题"><a href="#APK扩展性问题" class="headerlink" title="APK扩展性问题:"></a>APK扩展性问题:</h1><h2 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h2><h3 id="1-R-java是什么-R-java构成"><a href="#1-R-java是什么-R-java构成" class="headerlink" title="1. R.java是什么(R.java构成)"></a>1. <em>R.java是什么(R.java构成)</em></h3><blockquote>
<p>R.java由ADT(aapt)编译生成，<br>记录应用apk-res路径所有资源，并根据这些资源建立对应的ID(生成唯一的标识符)<br>编译期间，同一个资源在普通的apk中只会属于一个<strong>package</strong>，一个<strong>type</strong>，只拥有一个<strong>entry次序</strong>。<br>以0x01开头的就是系统已经内置的资源id，以0x7f开头的是咱们自己添加的app资源id </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/%E8%B5%84%E6%BA%90id.png" alt="R.java"> </p>
<blockquote>
<p>由于项目开发是多模块的开发 - 编译期相关的知识</p>
<ul>
<li>主模块中的R.java中的字段以final修饰，以常量形式存在。  </li>
<li>库模块中的R.java中的字段不以final修饰，以变量形式被项目中的代码所引用。  </li>
</ul>
</blockquote>
<h4 id="Android资源的合并"><a href="#Android资源的合并" class="headerlink" title="Android资源的合并"></a>Android资源的合并</h4><blockquote>
<p>覆盖的优先级如下：<br>build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependences</p>
</blockquote>
<blockquote>
<p>这种依赖关系不同于gradle里面的implementation依赖传递，implementation是跨级不能传递，但是R文件的生成是跨级可以传递的。<br>module的R文件数 = 依赖的module/aar数量 + 1(自身的R文件)<br>R.文件的生成是底层到上层 </p>
</blockquote>
<h3 id="为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？"><a href="#为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？" class="headerlink" title="为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？"></a>为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？</h3><blockquote>
<p><em>比较早的aapt的版本生成的非主模块的资源id确实都是final修饰的，这样会带来一个问题，这些资源id全部内联到代码中，一旦新增或者删除，修改了资源，资源id就会有变化，所有的代码都需要重新编译，造成严重的编译耗时</em>。  </p>
</blockquote>
<p>后来改为主模块final常量方式内联，非主模块引用方式，这样等按照从下到上编译到App模块的时候，所有的资源id都已经确定了，底层模块的资源只需要通过引用就能拿到自己对应的id，而修改(新增，删除，修改)了资源之后，也只需要重新生成R文件就好了。编译耗时大大减少。</p>
<p>在我们平常打包的时候，反编译apk，再合并资源回编时，也是要重新生成R文件。  </p>
<p>开发时，在其他module代码引用资源文件时,使用以下代码进行索引  </p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return a resource identifier <span class="keyword">for</span> <span class="keyword">the</span> <span class="keyword">given</span> resource <span class="built_in">name</span>.  A fully</span><br><span class="line"> * qualified resource <span class="built_in">name</span> <span class="keyword">is</span> <span class="keyword">of</span> <span class="keyword">the</span> form <span class="string">&quot;package:type/entry&quot;</span>.  The <span class="keyword">first</span></span><br><span class="line"> * two components (package <span class="keyword">and</span> type) are optional <span class="keyword">if</span> defType <span class="keyword">and</span></span><br><span class="line"> * defPackage, respectively, are specified here.</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;Note: use <span class="keyword">of</span> this function <span class="keyword">is</span> discouraged.  It <span class="keyword">is</span> much more</span><br><span class="line"> * efficient <span class="keyword">to</span> retrieve resources <span class="keyword">by</span> identifier than <span class="keyword">by</span> <span class="built_in">name</span>.</span><br><span class="line"> * </span><br><span class="line"> * @param <span class="built_in">name</span> The <span class="built_in">name</span> <span class="keyword">of</span> <span class="keyword">the</span> desired resource.</span><br><span class="line"> * @param defType Optional default resource type <span class="keyword">to</span> find, <span class="keyword">if</span> <span class="string">&quot;type/&quot;</span> <span class="keyword">is</span></span><br><span class="line"> *                <span class="keyword">not</span> included <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">name</span>.  Can be null <span class="keyword">to</span> require an</span><br><span class="line"> *                explicit type.</span><br><span class="line"> * @param defPackage Optional default package <span class="keyword">to</span> find, <span class="keyword">if</span> <span class="string">&quot;package:&quot;</span> <span class="keyword">is</span></span><br><span class="line"> *                   <span class="keyword">not</span> included <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">name</span>.  Can be null <span class="keyword">to</span> require an</span><br><span class="line"> *                   explicit package.</span><br><span class="line"> * </span><br><span class="line"> * @<span class="literal">return</span> int The associated resource identifier.  Returns <span class="number">0</span> <span class="keyword">if</span> no such</span><br><span class="line"> *         resource was found.  (<span class="number">0</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid resource ID.)</span><br><span class="line"> */</span><br><span class="line">public int getIdentifier(String <span class="built_in">name</span>, String defType, String defPackage) &#123;</span><br><span class="line"><span class="built_in">    return</span> mResourcesImpl.getIdentifier(<span class="built_in">name</span>, defType, defPackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？"><a href="#为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？" class="headerlink" title="为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？"></a>为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？</h3><p>因为资源id只是表示资源的次序，而不是别的跟资源本身绑定的属性。当到了不同的模块以后，参与编译的资源变多了，那次序肯定会改变。资源id也就改变了。并且子模块的资源id只是引用形式存在于代码中，id具体是什么值并不是很care。</p>
<h3 id="apk或者aab，为什么需要对齐？"><a href="#apk或者aab，为什么需要对齐？" class="headerlink" title="apk或者aab，为什么需要对齐？"></a><em>apk或者aab</em>，为什么需要对齐？</h3><blockquote>
<p>zipalign的主要工作是将apk包进行对齐处理，使apk包中的所有资源文件举例文件起始偏移为4字节的整数倍，这样通过内存映射访问apk时的速度会更快。<br>为什么快呢？如果每个资源的开始位置上都是一个资源之后的4n字节，那么访问下一个资源就不用遍历，直接跳到4字节之后即可 </p>
</blockquote>
<h3 id="apk或者aab混淆的方式有哪些"><a href="#apk或者aab混淆的方式有哪些" class="headerlink" title="apk或者aab混淆的方式有哪些()"></a><em>apk或者aab</em>混淆的方式有哪些()</h3><blockquote>
</blockquote>
<p>压缩(Shrink)：检测并移除代码中无用的类、字段、方法和特性<br>优化(Optimize)：字节码进行优化，移除无用的指令。<br>混淆(Obfuscate)：使用a、b、c、d这样简短而无意义的名称，对垒、字段和方法进行重命名。<br>预检测(Preveirfy)：在Java平台对处理后的代码进行预检测，确保加载class文件是可执行的 </p>
<h3 id="“Android”-64k报错"><a href="#“Android”-64k报错" class="headerlink" title="“Android” 64k报错"></a>“Android” 64k报错</h3><p>应用及第三方库包含的方法数(method)总和超过65536，在开发的时候，会遇到一个构建的错误。<br>指明您的应用达到Android构建规定的应用的限制：</p>
<h4 id="构建错误的原因"><a href="#构建错误的原因" class="headerlink" title="构建错误的原因:"></a>构建错误的原因:</h4><h5 id="dex文件格式的限制"><a href="#dex文件格式的限制" class="headerlink" title="dex文件格式的限制"></a>dex文件格式的限制</h5><p>Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 二进制文件形式的可执行字节码文件，这些文件包含用来运行应用的已编译代码。<br>Dalvik Executable 规范将可在单个 DEX 文件内引用的方法总数限制为 65536 (其中包括 Android 框架方法、库方法以及您自己的代码中的方法)</p>
<h5 id="其他限制"><a href="#其他限制" class="headerlink" title="其他限制"></a>其他限制</h5><p>系统对dex文件进行优化操作时分配的缓冲区大小的限制 ，方法如果超出缓存区，同样也是会报错的。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Handle---消息分发机制(ThreadLocal)</title>
    <url>/2021/07/26/android-Handler%E6%9C%BA%E5%88%B6-1/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Message</td>
<td align="center">消息</td>
<td align="left">使用了享元设计模式 链表的数据结构</td>
<td align="left">详情</td>
</tr>
<tr>
<td align="left">MessageQuene</td>
<td align="center">消息队列</td>
<td align="left">单链表的数据结构</td>
<td align="left">优先级的队列 — 根据时间先后顺序排队的单链表</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="center">message的处理者</td>
<td align="left">即线程间传递的对象，传递的信息包含在其中    Handler的构造函 ，在构造函数中初始化了一个Looper 和 MessageQueue。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ThreadLocal</td>
<td align="center">数据结构是键值对</td>
<td align="left">只有在指定的线程可以获取到存储的数据</td>
<td align="left">获取线程唯一的变量 Theadlocal value 线程内部的数据存储类,使用场景：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本</td>
</tr>
<tr>
<td align="left">Looper</td>
<td align="center">循环器</td>
<td align="left"><img src="code_looper_1.jpg" alt="code_looper"></td>
<td align="left">类Looper的prepare的函数,即是对Looper进行了初始化，将Looper对象引用保存在sThreadLocal中，先保证了Looper和Threadlocal-1V1关系,由于sThreadLocal获取的值是通过获取当前线程获取线程唯一的变量,这样就保证了一个线程只有一个looper</td>
</tr>
</tbody></table>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>ThreadLocal用于保存线程全局变量，以方便调用。即，当前线程独有，不与其他线程共享；可在当前线程任何地方获取到该变量。</p>
<h2 id="TheadLocal-原理及应用场景"><a href="#TheadLocal-原理及应用场景" class="headerlink" title="TheadLocal 原理及应用场景"></a>TheadLocal 原理及应用场景</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">事物的创造从未有应该或不应该，但被创造出来后如何被人利用却成了最大的问题。</span><br></pre></td></tr></table></figure>
<p>我觉得这个话应用到编程上也是一样的，把自身关注点放到事物是什么背景下创造出来的，了解事物的出生，发展，迭代，衰亡，站在巨人的肩膀上看问题。</p>
<p>深刻理解事物的本质和特性，这也是导致变化的原因，本质影响结果的走向，特性影响过程的变化。<br>无法对现象作出最终解释的理论都是无用的，因为其不能反映客观事实！我们回归正题,要分析他的本质和特性，就要回归本源(看源码)!</p>
<ul>
<li>ThreadLocal主要有2大特性   </li>
</ul>
<ul>
<li>全局性 线程内可访问  </li>
<li>唯一性 使用ThreadLocal维护变量时，每个线程都会获得该线程独享一份变量副本。</li>
</ul>
<p>这里我们源码开头的序言转译一下</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">This</span> <span class="selector-tag">class</span> <span class="selector-tag">provides</span> <span class="selector-tag">thread-local</span> <span class="selector-tag">variables</span>.  <span class="selector-tag">These</span> <span class="selector-tag">variables</span> <span class="selector-tag">differ</span> <span class="selector-tag">from</span></span><br><span class="line"><span class="selector-tag">their</span> <span class="selector-tag">normal</span> <span class="selector-tag">counterparts</span> <span class="selector-tag">in</span> <span class="selector-tag">that</span> <span class="selector-tag">each</span> <span class="selector-tag">thread</span> <span class="selector-tag">that</span> <span class="selector-tag">accesses</span> <span class="selector-tag">one</span> (via its</span><br><span class="line">&#123;<span class="variable">@code</span> get&#125; or &#123;<span class="variable">@code</span> set&#125; method) <span class="selector-tag">has</span> <span class="selector-tag">its</span> <span class="selector-tag">own</span>, <span class="selector-tag">independently</span> <span class="selector-tag">initialized</span></span><br><span class="line"><span class="selector-tag">copy</span> <span class="selector-tag">of</span> <span class="selector-tag">the</span> <span class="selector-tag">variable</span>.  &#123;<span class="variable">@code</span> ThreadLocal&#125; <span class="selector-tag">instances</span> <span class="selector-tag">are</span> <span class="selector-tag">typically</span> <span class="selector-tag">private</span></span><br><span class="line"><span class="selector-tag">static</span> <span class="selector-tag">fields</span> <span class="selector-tag">in</span> <span class="selector-tag">classes</span> <span class="selector-tag">that</span> <span class="selector-tag">wish</span> <span class="selector-tag">to</span> <span class="selector-tag">associate</span> <span class="selector-tag">state</span> <span class="selector-tag">with</span> <span class="selector-tag">a</span> <span class="selector-tag">thread</span> (e.g.,</span><br><span class="line">a user ID or Transaction ID).</span><br><span class="line">此类提供线程局部变量。这些变量不同于</span><br><span class="line">它们的正常对应物，因为每个线程访问一个（通过其</span><br><span class="line">&#123;<span class="variable">@code</span> get&#125; 或 &#123;<span class="variable">@code</span> set&#125; 方法）有自己的，独立初始化的</span><br><span class="line">变量的副本。 &#123;<span class="variable">@code</span> ThreadLocal&#125; 实例通常是私有的</span><br><span class="line">希望将状态与线程相关联的类中的静态字段（例如，</span><br><span class="line">用户 <span class="selector-tag">ID</span> 或交易 <span class="selector-tag">ID</span>）。</span><br></pre></td></tr></table></figure>
<p>还有一段很重要的描述</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Each</span> <span class="selector-tag">thread</span> <span class="selector-tag">holds</span> <span class="selector-tag">an</span> <span class="selector-tag">implicit</span> <span class="selector-tag">reference</span> <span class="selector-tag">to</span> <span class="selector-tag">its</span> <span class="selector-tag">copy</span> <span class="selector-tag">of</span> <span class="selector-tag">a</span> <span class="selector-tag">thread-local</span></span><br><span class="line"><span class="selector-tag">variable</span> <span class="selector-tag">as</span> <span class="selector-tag">long</span> <span class="selector-tag">as</span> <span class="selector-tag">the</span> <span class="selector-tag">thread</span> <span class="selector-tag">is</span> <span class="selector-tag">alive</span> <span class="selector-tag">and</span> <span class="selector-tag">the</span> &#123;<span class="variable">@code</span> ThreadLocal&#125;</span><br><span class="line"><span class="selector-tag">instance</span> <span class="selector-tag">is</span> <span class="selector-tag">accessible</span>; <span class="selector-tag">after</span> <span class="selector-tag">a</span> <span class="selector-tag">thread</span> <span class="selector-tag">goes</span> <span class="selector-tag">away</span>, <span class="keyword">all</span> <span class="selector-tag">of</span> <span class="selector-tag">its</span> <span class="selector-tag">copies</span> <span class="selector-tag">of</span></span><br><span class="line"><span class="selector-tag">thread-local</span> <span class="selector-tag">instances</span> <span class="selector-tag">are</span> <span class="selector-tag">subject</span> <span class="selector-tag">to</span> <span class="selector-tag">garbage</span> <span class="selector-tag">collection</span> (unless other</span><br><span class="line">eferences to these copies exist).</span><br><span class="line"> </span><br><span class="line">每个线程都持有一个对其本地线程副本的隐式引用</span><br><span class="line">只要线程还活着并且 &#123;<span class="variable">@code</span> ThreadLocal&#125; 变量</span><br><span class="line">实例可访问；一个线程消失后，它的所有副本</span><br><span class="line">线程本地实例受垃圾回收的影响（除非其他</span><br><span class="line">存在对这些副本的引用）</span><br><span class="line"><span class="variable">@author</span>  Josh Bloch and Doug Lea</span><br><span class="line"><span class="variable">@since</span>   <span class="number">1.2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Sets the current thread&#x27;s copy <span class="keyword">of</span> this thread-local variable <span class="keyword">to</span> the specified value. </span><br><span class="line">Most subclasses will have no need <span class="keyword">to</span> override this <span class="keyword">method</span>, relying solely on the &#123;@link #initialValue&#125; <span class="keyword">method</span> <span class="keyword">to</span> set the values <span class="keyword">of</span> thread-locals.</span><br><span class="line"></span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">    ThreadLocalMap map = get<span class="constructor">Map(<span class="params">t</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        create<span class="constructor">Map(<span class="params">t</span>, <span class="params">value</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Get the map associated <span class="keyword">with</span> a ThreadLocal </span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="function"><span class="title">getMap</span>(<span class="params">Thread t</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Thread</span> <span class="symbol">implements</span> <span class="symbol">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里其实可以发现真正起到作用的其实这个<strong>ThreadLocal内部类ThreadLocalMap</strong>。<br>由于<strong>ThreadLocalMap</strong>的数据结构是Map键值对(K,V)，这里的K是本地线程threadLocals，V是线程的变量副本（value）。</p>
<p>但是这样还是不够，我还是没弄明白ThreadLocal是怎么把变量复制到Thread的ThreadLocalMap中的？</p>
<p>直到我去google到这篇<a href="https://zhuanlan.zhihu.com/p/158033837">文章</a> 😯 😄 😏 </p>
<p>当我们初始化一个线程的时候其内部干去创建了一个ThreadLocalMap的Map容器待用</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Thread</span> <span class="symbol">implements</span> <span class="symbol">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当ThreadLocalMap被创建加载的时候其静态内部类Entry也随之加载，完成初始化动作。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">       <span class="type">Object</span> value;</span><br><span class="line">        <span class="type">Entry</span>(<span class="type">ThreadLocal</span>&lt;?&gt; k, <span class="type">Object</span> v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能到这里大家多少有些困惑，我们重新整理下流程<br>当我们在Thread内部调用set方法时:</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> <span class="built_in">set</span>(T value) &#123;</span><br><span class="line">    <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</span><br><span class="line">    ThreadLocalMap <span class="built_in">map</span> = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="built_in">null</span>)</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">set</span>(this, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(<span class="keyword">Thread</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">void</span> createMap(<span class="keyword">Thread</span> t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = <span class="literal">new</span> ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第一步会去获取调用当前方法的线程<span class="keyword">Thread</span>。</span><br><span class="line">然后顺其自然的拿到当前线程内部的ThreadLocalMap容器。</span><br><span class="line">最后就把变量副本给丢进去。</span><br><span class="line">ThreadLocal（就认为是个维护线程内部变量的工具！）只是在<span class="built_in">Set</span>的时候去操作了<span class="keyword">Thread</span>内部的·ThreadLocalMap将变量拷贝到了<span class="keyword">Thread</span>内部的<span class="built_in">Map</span>容器中，Key就是当前的ThreadLocal,Value就是变量的副本</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="keyword">get</span>() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.<span class="keyword">set</span>(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> T initialValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">获取当前线程的ThreadLocalMap对象</span><br><span class="line">从map中根据<span class="keyword">this</span>（当前的threadlocal对象）获取线程存储的Entry节点。</span><br><span class="line">从Entry节点获取存储的对应Value副本值返回。</span><br><span class="line">map为空的话返回初始值<span class="literal">null</span>，即线程变量副本为<span class="literal">null</span>。</span><br></pre></td></tr></table></figure>




<h1 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h1><h2 id="Key的弱引用问题"><a href="#Key的弱引用问题" class="headerlink" title="Key的弱引用问题"></a>Key的弱引用问题</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">To help deal <span class="keyword">with</span> very large <span class="keyword">and</span> <span class="keyword">long</span>-lived usages, <span class="keyword">the</span> hash table entries use WeakReferences <span class="keyword">for</span> <span class="built_in">keys</span>.</span><br></pre></td></tr></table></figure>
<p>为了处理非常大和生命周期非常长的线程(<strong>usages</strong>)，哈希表使用弱引用作为 key。</p>
<p>ThreadLocal在没有外部对象强引用时如Thread，发生GC时弱引用Key会被回收，而Value是强引用不会回收，如果创建ThreadLocal的线程一直持续运行如线程池中的线程，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p>
<p>key 如果使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。<br>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。</p>
<p>通常ThreadLocalMap的生命周期跟Thread（注意线程池中的Thread）一样长，如果没有手动删除对应key（线程使用结束归还给线程池了，其中的KV不再被使用但又不会GC回收，可认为是内存泄漏），一定会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal会被GC回收，不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除，Java8已经做了上面的代码优化。</p>
<p>总结<br>每个ThreadLocal只能保存一个变量副本，如果想要一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。<br>ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。<br>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android App Bundles</title>
    <url>/2021/07/19/google-aab/</url>
    <content><![CDATA[<h1 id="Google-Android-App-Bundles"><a href="#Google-Android-App-Bundles" class="headerlink" title="Google - Android App Bundles"></a>Google - Android App Bundles</h1><p>2018 年的 Google I/O ，Google 向 Android 引入了新 App 动态化框架（即 Android App Bundle，缩写为<strong>AAB</strong>)</p>
<blockquote>
<p>App 动态化框架，动态化概念指的是 Play Dynamic Delivery </p>
<blockquote>
<p><strong>上线要求</strong>:从 2021 年 8 月起，新应用需要使用 Android App Bundle 才能在 Google Play 中发布。  </p>
</blockquote>
</blockquote>
<h2 id="About-Android-App-Bundles"><a href="#About-Android-App-Bundles" class="headerlink" title="About Android App Bundles"></a>About Android App Bundles</h2><blockquote>
<p>Android App Bundle 是一种包含编译后代码和资源文件的新的上传格式（.aab） </p>
</blockquote>
<p>补充:<strong>Android Application Bundle</strong> != <strong>Apk</strong><br>App Bundle 纯粹是为了上传设计的文件，用户无法直接安装和使用它。<br>虽然AAB和Apk本质上都是压缩包,但是内部的目录结构完全不同，以下是一个Abb正常的aab文件结构</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">–BundleConfig.pb ： 打包bundle的时候，自动生成</span><br><span class="line">–base : base目录</span><br><span class="line"><span class="section">——assets: 对应apk的assets目录</span></span><br><span class="line"><span class="section">——dex: 原apk中classes.dex,classes2.dex…都放这里</span></span><br><span class="line"><span class="section">——lib: 原apk中lib目录都放这里</span></span><br><span class="line"><span class="section">——manifest: 原apk的AndroidManifest.xml放这里，需要是编译后的AndroidManifest.xml</span></span><br><span class="line">——res：apk中的资源放这里，需要是编译后的资源</span><br><span class="line"><span class="section">——root: apk中相对于根目录的其他资源文件</span></span><br><span class="line">——resources.pb：编译资源的时候会生成的</span><br><span class="line"><span class="section">——assets.pb:编译bundle的时候会生成的</span></span><br><span class="line"><span class="section">——native.pb: 编译bundle的时候会生成的</span></span><br></pre></td></tr></table></figure>

<h2 id="Google-Play-Dynamic-Delivery"><a href="#Google-Play-Dynamic-Delivery" class="headerlink" title="Google Play Dynamic Delivery"></a>Google Play Dynamic Delivery</h2><blockquote>
<p>简介:Google Play 推出新 app 交付模式，叫做动态交付 (Dynamic Delivery)，它根据每个用户的设备信息，使用开发者上传的 app bundle 来生成对应的 apk 文件。</p>
<blockquote>
<p><img src="https://conorlee.top/images/blogimages/2019/640.gif" alt="AAB">  </p>
</blockquote>
</blockquote>
<h2 id="Play-Asset-Delivery"><a href="#Play-Asset-Delivery" class="headerlink" title="Play Asset Delivery"></a>Play Asset Delivery</h2><blockquote>
<p>Play Asset Delivery (PAD)可以让依靠 Google Play 来托管和提供你的资产包，PAD提供灵活的分发模式，本质上减少包的体积，让用户更佳的体验,目前分发模式有3种，分别为<br><strong>1.install-time 2.fast-follow 3.on-demand</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分发模式</th>
<th align="center">大小限制</th>
<th align="left">简介</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">install-time  =&gt; 安装时分发</td>
<td align="center">总下载大小上限为1GB</td>
<td align="left">资源包在用户安装应用时进行分发，”预先”资源包</td>
<td align="left">在应用启动是使用，用户无法修改或删除这些资源包</td>
</tr>
<tr>
<td align="left">fast-follow =&gt; 快速跟进式分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包在用户安装应用后立即自动下载</td>
<td align="left">用户无需打开应用即可开始 fast-follow 下载。此类下载不会阻止用户访问应用。</td>
</tr>
<tr>
<td align="left">on-demand =&gt; 按需分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包会在应用运行时进行下载</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意 ！！！</strong>：如果为资源包选择 <strong>install-time 分发类型</strong>，就无需在游戏中使用 <strong>Play Asset Delivery API</strong>。这些资源包与主应用 APK同时安装。<br>目前公司项目使用就是分发模式就是 <strong>install-time</strong></p>
<p>由于google规定需要apk&lt;150m，等于aab中的base目录&lt;150m，如果超出限制，需要把多出的资源迁移到install-time，让google去动态下发资源</p>
<!-- # 软件使用说明
### 需要提前安装的环境   
* 需要自己额外再安装的路径  
    1. python3
    2. aapt  
    3. gradle 
    4. as-pro  ==> 模板工程 
* 该工具内置了反编译的环境 请勿随意修改路径  
    1. apktool  
    2. dex2jar  
    3. smali  

2 需要在该工具路径下/tool/apktool/signature/config/apk.ini文件配置以下路径

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置项 后续看项目的需求支持可增加参数</span></span><br><span class="line">[config]</span><br><span class="line"><span class="comment"># 注意所有配置项需要顶行写，&quot;=&quot; 号两边和行首尾不能有空格</span></span><br><span class="line"><span class="comment"># AS 路径 </span></span><br><span class="line">as_path=<span class="regexp">/Users/</span>zhupengbo<span class="regexp">/Desktop/</span>S3/S3_Hw</span><br><span class="line"><span class="comment"># AAB 生成的路径 必填</span></span><br><span class="line">abb_path=<span class="regexp">/Users/</span>zhupengbo<span class="regexp">/tool/</span>apktool<span class="regexp">/apk/</span>abb</span><br><span class="line"><span class="comment"># 版本号和版本名</span></span><br><span class="line">versionCode=<span class="number">1</span></span><br><span class="line">versionName=<span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.该项目增加了pad配置表<br>3.1 <strong>aab_pad.xls</strong> 配置表路径在 <strong>/apktool/signature/config</strong> 的路径下<br>3.2 配置的方法<br>支持配置<strong>文件路径</strong>和<strong>文件夹</strong><br>S3项目以resource路径下进行配表，该路径包含了游戏内的资源  </p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">配置形式为<span class="symbol">:resource/</span>路径</span><br></pre></td></tr></table></figure>

<p><strong>aab_pad.xls 格式如下-示例</strong></p>
<table>
<thead>
<tr>
<th align="left">Path</th>
</tr>
</thead>
<tbody><tr>
<td align="left">resource/model</td>
</tr>
<tr>
<td align="left">resource/Video</td>
</tr>
<tr>
<td align="left">resource/allRes.json</td>
</tr>
<tr>
<td align="left">resource/ui</td>
</tr>
</tbody></table>
<p>4 该工具支持下终端下执行，调用示例</p>
<pre><code>/Users/zhupengbo/tool/apktool/android_pack.sh /Users/zhupengbo/tool/apktool/apk/apk/AAA.apk
``` --&gt;




</code></pre>
]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo CMD</title>
    <url>/2021/07/19/hexo/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;博客名称&quot;</span>  =&gt; hexo <span class="keyword">new</span> <span class="string">&quot;博客名称&quot;</span>   <span class="meta">#这两个都是创建新文章，前者是简写模式</span></span><br><span class="line">hexo p  =&gt; hexo publish</span><br><span class="line">hexo g  =&gt; hexo generate  <span class="meta">#生成</span></span><br><span class="line">hexo s  =&gt; hexo <span class="keyword">server</span>  <span class="meta">#启动服务预览</span></span><br><span class="line">hexo d  =&gt; hexo deploy  <span class="meta">#部署  </span></span><br><span class="line"></span><br><span class="line">hexo <span class="keyword">server</span>   <span class="meta">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span></span><br><span class="line">hexo <span class="keyword">server</span> -s   <span class="meta">#静态模式</span></span><br><span class="line">hexo <span class="keyword">server</span> -p <span class="number">5000</span>   <span class="meta">#更改端口</span></span><br><span class="line">hexo <span class="keyword">server</span> -i <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>   <span class="meta">#自定义IP</span></span><br><span class="line">hexo clean   <span class="meta">#清除缓存，网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g   <span class="meta">#生成静态网页</span></span><br><span class="line">hexo d   <span class="meta">#开始部署</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
