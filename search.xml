<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-Apk安装的流程</title>
    <url>/2021/08/20/Android-Apk%E5%AE%89%E8%A3%85%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-并发篇-1</title>
    <url>/2021/08/13/Java-%E5%B9%B6%E5%8F%91%E7%AF%87-1/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Activity</title>
    <url>/2021/08/11/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>在最近的任务栈里面看见的task未必还活着。<br>在最近的任务栈里面看不见的task未必就死了。</p>
<h2 id="android-launchMode"><a href="#android-launchMode" class="headerlink" title="android-launchMode"></a>android-launchMode</h2><p>在这里我推荐大家去看扔物线的课程: <a href="https://www.bilibili.com/video/BV1CA41177Se">Android 面试黑洞</a></p>
<p>Activity有4种启动模式，分别是：Standard、SingleTop、SingleTask和SingleInstance，它们控制了被启动Activity的启动行为。<br>Activity任务栈（Task）是一个标准的栈结构<br>用于在ActivityManagerService侧管理所有的Activity（AMS通过TaskRecord标识一个任务栈，通过ActivityRecord标识一个Activity）。</p>
<table>
<thead>
<tr>
<th align="left">launchMode</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE【知识扩展】</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Standard</td>
<td align="center">标准模式</td>
<td align="left">标准模式，也是系统的默认模式。该模式下，每次启动Activity，都会创建一个新实例，并且将其加入到启动该Activity的那个Activity所在的任务栈中，所以目标Activity的多个实例可以位于不同的任务栈。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SingleTop</td>
<td align="center">栈顶复用模式</td>
<td align="left">该模式下，若目标Activity的实例已经存在，但是没有位于栈顶，那么仍然会创建新的实例，并添加到任务栈；</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SingleTask</td>
<td align="center">栈内复用模式</td>
<td align="left">clearTop的作用，整个任务栈只能有一个activity的实例。</td>
<td align="left">如果此时任务栈内已经存在 Activity C 的实例且未位于栈顶，当启动 Activity C 时，会将 Activity C 上方的实例全部出栈让其位于任务栈顶并 Activity C 中的 onNewIntent() 方法会被调用</td>
</tr>
<tr>
<td align="left">SingleInstance</td>
<td align="center">单一实例</td>
<td align="left">要求该Activity所在的Task只有有这么一个Activity，</td>
<td align="left">下面没有旧，上面没有新</td>
</tr>
</tbody></table>
<h2 id="MORE【知识扩展】"><a href="#MORE【知识扩展】" class="headerlink" title="MORE【知识扩展】"></a>MORE【知识扩展】</h2><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><p>当我们使用Application的Context来启动一个Activity的时候，会报AndroidRuntimeException，因为standard模式下启动的Activity，会默认进入启动它的Activity的任务栈中，而非Activity类型的context却并没有所谓的任务栈，所以就会出现问题，解决这个问题的方法是需要为要启动的Activity指定标记位：FLAG_ACTIVITY_NEW_TASK，这个标记的作用是为启动的Activity创建一个新的任务栈。</p>
<h3 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h3><p>该模式下，若目标Activity的实例已经存在，但是没有位于栈顶，那么仍然会创建新的实例，并添加到任务栈；</p>
<p>若目标Activity的实例已经存在，且位于栈顶，那么就不会创建新的实例，而是复用已有实例，并依次调用目标Activity的onPause -&gt; onNewIntent -&gt; onResume方法。<br>知识扩展！！！</p>
<p>singleTop模式的activity特点就是除了外部可以启动它显示信息外，它也可以用同样的方式启动自己更新显示信息，这样就减少了冗余代码，降低了维护成本。</p>
<p>他的onCreate、onStart方法不会被调用，避免多次初始化，应用宝用的就是这套方案。</p>
<h3 id="SingleTask-A和B都是不同的2个应用"><a href="#SingleTask-A和B都是不同的2个应用" class="headerlink" title="SingleTask A和B都是不同的2个应用"></a>SingleTask A和B都是不同的2个应用</h3><p>首先做个假设：A-Activity 启动 B_Activity,launchMode下文进行了标注<br>A_Activity[Standard] ==&gt; B_Activity[SingleTask]<br>B_Activity的Activity被启动时，不会进入启动A的Task里,而是创建属于B自己的Task里，置于B-Task栈顶,然后把整个B-Task 压到 A-Task上面,这种方式打开的方式是入场动画是应用间的切换。</p>
<p>如果这时按下返回键，这里回退的顺序是 B-Task 来回退，而不是返回原来的A_Activity[Standard]。原来的A要在前台显示，必须是B-Task的栈的Activity完全关闭才可以，这里场景动画也是场景间的切换。  </p>
<p>这里要明确一个概念：不止应用的Activity内部可以叠成栈，不同应用之间的Task也可以叠成栈。</p>
<p>Task的叠加只适用于前台的Task。</p>
<p>SingleTask是保证了一个栈内有且只有被该属性修饰Activity的实例对象，全局单例</p>
<h3 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h3><p>为了描述清晰，我们还是要举个例子:<br>A_Activity[Standard] ==&gt; B_Activity[SingleInstance]<br>还是 A 短信应用 打开 B 邮箱应用<br>邮件App不仅为了当前跳转的Activity创建对象，而且会创建一个单独的B-Task,然后把当前的打开应用的Activity的实例放到B-Task。<br>第二种情况是当前Activity已经被创建过了，则会回调当前应用的Activity生命周期的**onNewIntent()**方法</p>
<p>这2种情况的变化，这个B-Task都会被拿过来压在A-Task上面，入场动画是切换Task的动画。</p>
<p>假设用户这个时候点返回，上面的Task因为只有一个Activity，手机会直接回到短信App，入场动画是切换Task的动画。</p>
<p>假设用户没有直接点返回，而是选择查看了最近的任务又返回到之B-Task，这个时候短信的A-Task已经被退到后台，所以用户再点返回的话，又因为当前的Task内只有一个B-Activity，所以是直接回退到桌面。</p>
<p>假设用户又没有点返回，也没有选择查看任务，而是选择了在B-Task，又打开了一个C-App的Activity，由于SingleInstance的限制，所以C-task并不会叠在B-Task之上，而是另辟蹊径，而是装到另一个Task中，然后整个Task跌在B-Task上面。</p>
<p>知识点: 我来解释一下另辟蹊径的意思，这个时候相对邮箱App此时有2个Task，一个是独栈的，也就是短信调用的那个，还有一个是后台的Task，C的Activity是被放到了后台的Task。</p>
<blockquote>
<p>在最近的任务栈里面看不见的task未必就死了。这句话也是在这里体现。<br>在延伸出一个属性:Android:taskAffinity，</p>
</blockquote>
<h2 id="Android-taskAffinity属性"><a href="#Android-taskAffinity属性" class="headerlink" title="Android:taskAffinity属性"></a>Android:taskAffinity属性</h2><blockquote>
<p>在android里，一般情况下一个App默认只有一个Task，可以显示在最近的列表里面，但是用来甄别唯一性的不是App，而是<strong>taskAffinity</strong>，每一个Activity都有属于自己的Activity，相当于每个Activity的预先分组。<br><img src="taskAffinity%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99.png" alt="taskAffinity"><br>android:taskAffinity是Activity的一个属性，表示该Activity期望的任务栈的名称。<br>默认情况下，一个应用程序中所有Activity的taskAffinity都是相同的，即应用程序的包名。当然，我们可以在配置文件中为每个Activity指定不同的taskAffinity（只有和已有包名不同，才有意义）。<br><img src="taskAffinity%E6%9C%80%E8%BF%91%E5%88%97%E8%A1%A8.png" alt="taskAffinity"><br>另外每一个Task也有taskAffinity，他的值取自栈底的Activity的taskAffinity值，这个栈底Activity也就是第一个启动应用的Activity。</p>
</blockquote>
<p>另外一点taskAffinity也可以在androidManifest被定制。<br><img src="taskAffinity%E5%BC%80%E5%8F%91%E6%8E%A8%E8%8D%90.png" alt="taskAffinity">  </p>
<p>一般情况下，该属性主要和SingleTask启动模式或者android:allowTaskReparenting属性结合使用（下面会详细介绍），在其他情况下没有意义。</p>
<h3 id="Task-Reparenting"><a href="#Task-Reparenting" class="headerlink" title="Task - Reparenting"></a>Task - Reparenting</h3><p>B AndroidManifest属性 设置为android:allowTaskReparenting = True</p>
<p>场景具体化:A 短信应用 打开 B 邮箱应用</p>
<p>B还是会进入到A的Task里,但稍后用户从桌面点击B应用的时候，原先放在A-Task里面的B-Activity会被挪到B应用的Task的栈顶,这个时候你在切回短信Task，你会发现原先的B-Activity已经不见了。<br>(有争议… Android 8,9是有问题的，10以上正常)</p>
<h3 id="前台Task"><a href="#前台Task" class="headerlink" title="前台Task"></a>前台Task</h3><p>前台叠加的多个Task进入后台第一时间就会拆开</p>
<blockquote>
<p>1.按Home键回到桌面<br>2.按最近任务键 查看最近的任务  </p>
<ul>
<li>前台Task 在最近列表显示出来的时候就已经进入到了后台，而不是切到其他任务之后。</li>
</ul>
</blockquote>
<p>但是光知道理论还是不够的，由于我们开发的时候大部分的情况都是多变的，我们在前面的章节可以了解到不同的应用的Activity是启动Task内叠加的。</p>
<p>首先做个假设：A-Activity 启动 B_Activity,launchMode下文进行了标注<br>A_Activity[Standard] ==&gt; B_Activity[SingleTask]<br>我们再把场景具体化，A 短信应用 打开 B 邮箱应用，这个时间我们没有按下返回键，而是按最近任务键，再重新回去原来的Task，这个时候看起来没有变化，但是实际上A的Task已经被去除掉了，只留下B的Task，这个时候我们再按下返回键，把B的Task内的Activity全部关闭，这个时候返回的系统的桌面而不是短信的APP。</p>
<h2 id="Android十万个为什么系列"><a href="#Android十万个为什么系列" class="headerlink" title="Android十万个为什么系列"></a>Android十万个为什么系列</h2><h3 id="当前-app-正在前台运行，不在栈顶的-Activity-有可能会因为系统资源，例如内存等不足回收吗？"><a href="#当前-app-正在前台运行，不在栈顶的-Activity-有可能会因为系统资源，例如内存等不足回收吗？" class="headerlink" title="当前 app 正在前台运行，不在栈顶的 Activity 有可能会因为系统资源，例如内存等不足回收吗？"></a>当前 app 正在前台运行，不在栈顶的 Activity 有可能会因为系统资源，例如内存等不足回收吗？</h3><p>我现在还记得这个问题，那年我毕业，投了心仪公司的简历，过了Hr的面试，来到了技术环节，和蔼的面试官问了:我们日常开发比较多组件的是Activity，假设 App 正在前台运行，不在栈顶的Activity有可能会被回收吗?<br>那时年少，我感觉我天灵盖被人开了，当场差点直接自闭，懵逼，接下来回答支支吾吾，面试结果是显而易见的。。。  <strong>(ಥ_ಥ)</strong><br>回去的路上越想越不对劲，到家之后立马查源码，好家伙找到了！平时不看源码，关键时刻被别人搞得一愣一愣！</p>
<p>凡事先说结论: 会 ！！！<br>这里看的源码是API30,在网上也看到一些相关答案答案，这里我们提炼一下要点，重点我们日常开发对场景预测，比方说游戏A-APP开启了一个B-App应用的界面，这个时候B-App开启了一个比较消耗耗内存的线程，如果这个内存不断地增大，最后游戏A-App的生命周期onDestroy()就会被调用。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> attach(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq) &#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//ApplicationThread是ActivityThread和AMS沟通的桥梁</span></span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Watch for getting close to heap limit.</span></span><br><span class="line">            BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                @Override <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">Runtime</span> <span class="keyword">runtime</span> = <span class="keyword">Runtime</span>.getRuntime();</span><br><span class="line">                    <span class="keyword">long</span> dalvikMax = <span class="keyword">runtime</span>.maxMemory();</span><br><span class="line">                    <span class="keyword">long</span> dalvikUsed = <span class="keyword">runtime</span>.totalMemory() - <span class="keyword">runtime</span>.freeMemory();</span><br><span class="line">                    <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">&quot;Dalvik max=&quot;</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                                + <span class="string">&quot; total=&quot;</span> + (<span class="keyword">runtime</span>.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                                + <span class="string">&quot; used=&quot;</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                        mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ActivityTaskManager.getService().releaseSomeActivities(mAppThread);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="当-app-处于后台运行，app-进程未被杀死，其内部的-Activity-会被回收吗？"><a href="#当-app-处于后台运行，app-进程未被杀死，其内部的-Activity-会被回收吗？" class="headerlink" title="当 app 处于后台运行，app 进程未被杀死，其内部的 Activity 会被回收吗？"></a>当 app 处于后台运行，app 进程未被杀死，其内部的 Activity 会被回收吗？</h3><h3 id="当-app-处于后台运行，app-的进程会被杀死吗？"><a href="#当-app-处于后台运行，app-的进程会被杀死吗？" class="headerlink" title="当 app 处于后台运行，app 的进程会被杀死吗？"></a>当 app 处于后台运行，app 的进程会被杀死吗？</h3>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android杂谈-进程与线程</title>
    <url>/2021/08/04/Android%E6%9D%82%E8%B0%88-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>名词是对客观事物的指代，形容词是对客观事物的描述。</p>
<p>进程和线程又分别是什么? 进程和线程区别到底是什么?<br>带着简单的疑问，我们慢慢往下看看，本文不会过多章节去分析代码，而是比较多去谈自己的理解！</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程是<strong>操作系统</strong>分配资源的单位,线程是调度的基本单位,线程之间共享进程资源。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>其实就这么简单的一句话，就可以引申出很多概念。<br>逆向思维(反推)，从已有的结果出发挖掘更多的可能性.  </p>
<blockquote>
<p>到底线程之间共享了哪些进程资源？<br>共享资源意味着什么？<br>共享资源这种机制是如何实现的？<br>线程有哪些是线程私有的  </p>
</blockquote>
<h3 id="计算机扩展概念"><a href="#计算机扩展概念" class="headerlink" title="计算机扩展概念"></a>计算机扩展概念</h3><p>其实无论是谈生意也好，还是谈工作也好，首先必须要解决一个问题，就是明确主题和双方信息差的问题！<br>为了更好的理解，我们需要了解一些基础的计算机知识(linux)。具体文献请参考原文</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><a href="http://www.linfo.org/cpu.html">CPU</a></h3><blockquote>
<p>A CPU contains three main sections: (1) <strong>an arithmetic/logic unit</strong>, (2) <strong>a control unit</strong> and (3) <strong><a href="http://www.linfo.org/register.html">registers</a></strong>. The arithmetic/logic unit contains circuitry that performs data manipulation. The control unit consists of circuitry for coordinating the machine’s activities. The registers are high speed memory cells that are used for holding instructions for data that is currently being processed.<br>CPU 包含三个主要部分：(1)<strong>算术/逻辑单元</strong>，(2)<strong>控制单元</strong>和 (3)<strong>寄存器</strong>。<br>算术/逻辑单元包含执行数据操作的电路。<br>控制单元由用于协调机器活动的电路组成。<br>寄存器是<strong>高速存储</strong>单元，用于保存当前正在处理的数据的指令。</p>
</blockquote>
<h3 id="Register-Definition-—-寄存器"><a href="#Register-Definition-—-寄存器" class="headerlink" title="Register Definition — 寄存器"></a><a href="http://www.linfo.org/register.html">Register Definition</a> — 寄存器</h3><blockquote>
<p>A register is a very small amount of very fast memory that is built into the CPU (central processing unit) in order to speed up its operations by providing quick access to commonly used values.<br>寄存器是非常快又微型的存储器内置于Cpu，是通过访问快速提供的值,已加快Cpu(中央处理单元)的操作</p>
</blockquote>
<p>作用:寄存器是<strong>高速存储</strong>单元，用于保存当前正在处理的数据的指令。</p>
<p>专用寄存器存储内部 CPU 数据，例如程序计数器（也称为指令指针）、堆栈指针和状态寄存器。</p>
<h4 id="寄存器概念扩展"><a href="#寄存器概念扩展" class="headerlink" title="寄存器概念扩展"></a>寄存器概念扩展</h4><p>寄存器是存储器层次结构的顶部，是系统操作数据的最快方式。<br>在它们下面是几个级别的高速缓存，至少其中一些也内置在 CPU 中，而其中一些可能在其他专用芯片上。高速缓存比寄存器慢，但要丰富得多。在不同级别的高速缓存之下是主存储器，它更慢但更丰富（例如，与只有 32 个寄存器相比，数百兆字节）。但反过来，它仍然比存储设备和媒体（例如，硬盘驱动器和 CDROM）快得多，容量也小得多。</p>
<h4 id="其他作用"><a href="#其他作用" class="headerlink" title="其他作用"></a>其他作用</h4><p><strong>指令寄存器</strong>保存CPU正在执行的指令。<br><strong>地址寄存器</strong>保存内存地址，用于访问内存。<br><strong>数据寄存器</strong>用于存储整数。  </p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote>
<p>线程运行的本质就是函数。<br>函数的执行总会有一个源头，这个源头就是所谓的入口函数，相当于java的main的函数，<em>CPU</em> 从入口函数开始执行从而形成一个执行流，只不过我们人为的给执行流起一个名字，这个名字就叫线程。  </p>
</blockquote>
<h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><p>凡事从本质出发，我们就要去分析函数包含了些哪些信息。线程之间既然共享了进程资源，那就会对应不共享的资源，也就是线程私有资源<br>函数运行时的信息包含了栈帧中，栈帧中保存了函数的返回值，调用其他函数的参数，局部变量，该函数的寄存器初始值。  </p>
<p><img src="%E5%87%BD%E6%95%B0%E4%BF%A1%E6%81%AF.jpeg" alt="函数信息"></p>
<p>这里延伸出一个问题，因为线程是可以被操作系统随时暂停运行的和恢复运行的，那是怎么做到的？<br>可以通过保存以及恢复程序计数器的值就可以知道线程的从哪里运行又从哪里开始。</p>
<p>由于每个线程的本质都是函数的运行，函数运行时的信息是保存在栈中的，因此<strong>每个线程都有对应自己独立，私有的栈区</strong></p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%8C%BA.jpeg" alt="线程私有"></p>
<p>同时像函数的局部变量也是存放到寄存器之中，运行完就释放掉，回收内存。</p>
<p>所属线程的栈区，程序计数器，栈指针以及函数运行使用的寄存器都是线程私有的。</p>
<h3 id="线程间的共享"><a href="#线程间的共享" class="headerlink" title="线程间的共享"></a>线程间的共享</h3><h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h4><p>编译后的可执行机器指令,从可执行文件中加载到内存的，可执行程序中的代码区就是用来初始化进程地址空间中的代码区的。</p>
<h4 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h4><p>进程地址空间中的数据区，这里存放的就是所谓的全局变量。<br>全局变量简单的理解，一般不会被系统回收的变量，即使函数执行完后该变量依然存在，对于其他线程也是可见的 </p>
<h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>对象存放的地址空间，可被GC。<br>变量的地址，也就是指针。<br>任何一个线程都可以访问指针指向的数据，因此堆区也是线程共享的属于进程的资源。</p>
<h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>因为线程不像进程，进程是互相隔离，且独立。<br>如果一个线程能拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说这些线程可以任意修改本属于另一个线程栈区中的变量。<br>一个线程的栈区对其它线程是可以见的，也就是说我们可以修改属于任何一个线程的栈区  </p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>如果程序在运行过程中打开了一些文件，那么进程地址空间中还保存有打开的文件信息，进程打开的文件也可以被所有的线程使用，这也属于线程间的共享资源。</p>
<p>如图<br><img src="%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB.jpeg" alt="线程共享"><br>线程共享的地址，除了线程上下文的信息  </p>
<p>对于这个地方，我们引入java虚拟机<br>如图<br><img src="jvm.jpeg" alt="线程共享">  </p>
<p>这里再扩展一下,jdk.1.8.0其实以及取消了方法区,与之对于的是元空间</p>
<ul>
<li>以下jdk1.8 的标准（）<ul>
<li> 移除了永久代（PermGen），替换为元空间（Metaspace）；</li>
<li> 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li>
<li> 永久代中的 interned Strings 和 class static variables 转移到了 Java heap；<br>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize） </li>
</ul>
</li>
</ul>
<p><img src="jdk-1.8.0.png" alt="jdk-1.8.0.png">  </p>
<p>其实以下的概念我们都在上文讲过:</p>
<h3 id="java线程私有："><a href="#java线程私有：" class="headerlink" title="java线程私有："></a>java线程私有：</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>• 程序计数器：<br>    1. 每一个线程都需要有独立的计数器，各个线程互不干扰，独立存储<br>    2. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制<br>    3. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡 </p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>• Java虚拟机栈：<br>• 描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。<br>• 栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。<br>• Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。  </p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>• 本地方法栈<br>• 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。  </p>
<ul>
<li>线程共享:<br>• 堆<br>• 方法区<br>• 直接内存(非运行时数据区）<br>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。<br>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。    </li>
</ul>
<h3 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h3><h4 id="Android中的context"><a href="#Android中的context" class="headerlink" title="Android中的context"></a>Android中的context</h4><p>很多人面试包括开发，最常遇到的一个名词就是Context，就是android的上下文，但是很多开发者其实不知道Context代表了什么意思，这里我的理解是 (格外提一点 寄存器是多个，不是一个)</p>
<blockquote>
<p>线程的栈区 + 程序计数器 + 栈指针 + 函数运行使用的寄存器 = 上下文</p>
</blockquote>
<p>Android操作系统可以随时中断并且回复正常，依靠的就是线程上下文。</p>
<p>这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了的进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存</p>
<!-- 作者：zhonyong
链接：https://www.zhihu.com/question/25532384/answer/81152571
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 -->]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统Binder驱动分析(2)</title>
    <url>/2021/07/31/Android%E7%B3%BB%E7%BB%9FBinder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90-2/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我的文章比较多是对自己知识的梳理，有些概念没讲得那么清楚，但会贴出参考的链接，请大家自便</p>
<h1 id="Binder-概述"><a href="#Binder-概述" class="headerlink" title="Binder 概述"></a>Binder 概述</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote>
<p>IPC : Inter-Process Communication (进程间的通信)<br>RPC : Remote Procedure Call (远程过程调用)<br>RPC是IPC的基础上进行了封装</p>
</blockquote>
<h3 id="简单例子-大致有个概念"><a href="#简单例子-大致有个概念" class="headerlink" title="简单例子: 大致有个概念"></a>简单例子: 大致有个概念</h3><p>再简单的分析下要素 (led是例子)</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="keyword">A</span>(①封装数据 ②发送给B) ===&gt;(IPC) B(①取出数据 @调用数据) </span><br><span class="line">源 : <span class="keyword">A</span>   </span><br><span class="line">目的 B 先向 ServerManger注册led服务  </span><br><span class="line">    <span class="keyword">A</span> 向 ServerManger 查询led服务,得到一个Handler  </span><br><span class="line">数据：char_Buff   --&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Binder究竟是什么"><a href="#Binder究竟是什么" class="headerlink" title="Binder究竟是什么"></a>Binder究竟是什么</h2><p>Binder是Android系统中负责每个<strong>用户进程</strong>与<strong>内核</strong>通信的驱动模块。 </p>
<h3 id="Binder的优势"><a href="#Binder的优势" class="headerlink" title="Binder的优势"></a>Binder的优势</h3><p><a href="https://blog.csdn.net/universus/article/details/6211589">推荐文章</a><br>主要是基于性能、稳定性和安全性几方面的原因。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><table>
<thead>
<tr>
<th align="left">IPC</th>
<th align="center">数据拷贝次数</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">共享内存</td>
<td align="center">0</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Binder</td>
<td align="center">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Socket</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">管道</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">消息队列</td>
<td align="center">2</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>Binder 基于 C/S 架构，架构清晰、职责明确又相互独立</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。<br>首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。<br>Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。</p>
<!-- (App UID 可 **packagename** 包名来区分)  -->
<p>传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。<br>可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>以下对比 Binder IPC 对比 传统IPC 的区别</p>
<h3 id="Linux-下的传统-IPC-通信原理"><a href="#Linux-下的传统-IPC-通信原理" class="headerlink" title="Linux 下的传统 IPC 通信原理"></a>Linux 下的传统 IPC <a href="https://zhuanlan.zhihu.com/p/35519585">通信原理</a></h3><p><img src="%E4%BC%A0%E7%BB%9FIPC.jpg" alt="Linux传统 IPC"></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<p>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；<br>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。  </p>
<h2 id="专栏-Android十万个为什么"><a href="#专栏-Android十万个为什么" class="headerlink" title="专栏:Android十万个为什么"></a>专栏:Android十万个为什么</h2><h3 id="什么是实名Binder"><a href="#什么是实名Binder" class="headerlink" title="什么是实名Binder?"></a>什么是实名Binder?</h3><h3 id="什么是匿名Binder？"><a href="#什么是匿名Binder？" class="headerlink" title="什么是匿名Binder？"></a>什么是匿名Binder？</h3><h3 id="“内核缓存区”-和-“数据接收缓存区”-存在的意义"><a href="#“内核缓存区”-和-“数据接收缓存区”-存在的意义" class="headerlink" title="“内核缓存区” 和 “数据接收缓存区” 存在的意义"></a>“内核缓存区” 和 “数据接收缓存区” 存在的意义</h3><p>Linux是使用的虚拟内存寻址方式，虚拟内存需要映射一块真的的物理内存，<br>内核缓存区和数据接收区的映射就是指向了同一块物理内存。接收方下次也可能是发送方，如果共用一块缓存那么岂不是发送方，内核，接收方都指向了同一块物理内存，违反了进程隔离的设计原则。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-崩溃优化</title>
    <url>/2021/07/29/Android-%E5%A5%94%E6%BA%83%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="崩溃优化"><a href="#崩溃优化" class="headerlink" title="崩溃优化"></a>崩溃优化</h1><h2 id="Android-崩溃分析"><a href="#Android-崩溃分析" class="headerlink" title="Android 崩溃分析"></a>Android 崩溃分析</h2><p>Android 崩溃基本分为 <strong>Java 崩溃</strong>和 <strong>Native 崩溃</strong><br>简单来说，Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出。<br>那 Native 崩溃又是怎么产生的呢？一般都是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，<br>这些都会产生相应的 <strong>signal 信号</strong>，导致程序异常退出。</p>
<h3 id="Native-崩溃"><a href="#Native-崩溃" class="headerlink" title="Native 崩溃"></a>Native 崩溃</h3><blockquote>
<ol>
<li>在 Unix-like 系统中，所有的崩溃都是编程错误或者硬件错误相关的，系统遇到不可恢复的错误时会触发崩溃机制让程序退出，如除零、段地址错误等。</li>
<li>异常发生时，CPU 通过异常中断的方式，触发异常处理流程。不同的处理器，有不同的异常中断类型和中断处理方式。</li>
<li>linux 把这些中断处理，统一为信号量，可以注册信号量向量进行处理。</li>
<li>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。  </li>
</ol>
</blockquote>
<h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="signal.png" alt="信号机制"> </p>
<h5 id="1-信号的接收"><a href="#1-信号的接收" class="headerlink" title="(1) 信号的接收"></a>(1) 信号的接收</h5><p>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入<strong>内核态</strong> 。<br>！！！注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<h5 id="2-信号的检测"><a href="#2-信号的检测" class="headerlink" title="(2) 信号的检测"></a>(2) 信号的检测</h5><p>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<p>1.进程从内核态返回到用户态前进行信号检测</p>
<p>2.进程在内核态中，从睡眠状态被唤醒的时候进行信号检测</p>
<p>当发现有新信号时，便会进入下一步，信号的处理。</p>
<h5 id="3-信号的处理"><a href="#3-信号的处理" class="headerlink" title="(3) 信号的处理"></a>(3) 信号的处理</h5><p>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<p>四、捕捉native crash<br>1.注册信号处理函数<br>第一步就是要用信号处理函数捕获到native crash(SIGSEGV, SIGBUS等)。在posix系统，可以用sigaction()：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"><span class="keyword">int</span> sigaction(<span class="keyword">int</span> signum,<span class="keyword">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact));</span><br></pre></td></tr></table></figure>
<p>signum：代表信号编码，可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号，如果为这两个信号定义自己的处理函数，将导致信号安装错误。</p>
<p>act：指向结构体sigaction的一个实例的指针，该实例指定了对特定信号的处理，如果设置为空，进程会执行默认处理。</p>
<p>oldact：和参数act类似，只不过保存的是原来对相应信号的处理，也可设置为NULL。</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">struct sigaction s<span class="built_in">a_old</span><span class="comment">;  </span></span><br><span class="line">memset(&amp;sa, <span class="number">0</span>, sizeof(sa))<span class="comment">;  </span></span><br><span class="line">sigemptyset(&amp;sa.s<span class="built_in">a_mask</span>)<span class="comment">;  </span></span><br><span class="line">sa.s<span class="built_in">a_sigaction</span> = my_handler<span class="comment">;  </span></span><br><span class="line">sa.s<span class="built_in">a_flags</span> = S<span class="built_in">A_SIGINFO</span><span class="comment">;</span></span><br><span class="line">if (sigaction(sig, &amp;sa, &amp;s<span class="built_in">a_old</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.设置额外栈空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaltstack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">stack_t</span> *ss, <span class="keyword">stack_t</span> *oss)</span></span>;</span><br></pre></td></tr></table></figure>
<p>SIGSEGV很有可能是栈溢出引起的，如果在默认的栈上运行很有可能会破坏程序运行的现场，无法获取到正确的上下文。而且当栈满了（太多次递归，栈上太多对象），系统会在同一个已经满了的栈上调用SIGSEGV的信号处理函数，又再一次引起同样的信号。</p>
<p>我们应该开辟一块新的空间作为运行信号处理函数的栈。可以使用sigaltstack在任意线程注册一个可选的栈，保留一下在紧急情况下使用的空间。（系统会在危险情况下把栈指针指向这个地方，使得可以在一个新的栈上运行信号处理函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">stack_t</span> stack;  </span><br><span class="line"><span class="built_in">memset</span>(&amp;stack, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stack));  </span><br><span class="line"><span class="comment">/* Reserver the system default stack size. We don&#x27;t need that much by the way. */</span>  </span><br><span class="line">stack.ss_size = SIGSTKSZ;  </span><br><span class="line">stack.ss_sp = <span class="built_in">malloc</span>(stack.ss_size);  </span><br><span class="line">stack.ss_flags = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">/* Install alternate stack size. Be sure the memory region is valid until you revert it. */</span>  </span><br><span class="line"><span class="keyword">if</span> (stack.ss_sp != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">sigaltstack</span>(&amp;stack, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.兼容其他signal处理</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static void my<span class="constructor">_handler(<span class="params">const</span> <span class="params">int</span> <span class="params">code</span>, <span class="params">siginfo_t</span> <span class="operator">*</span><span class="params">const</span> <span class="params">si</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">const</span> <span class="params">sc</span>)</span> &#123;<span class="operator"></span></span><br><span class="line"><span class="operator">...  </span></span><br><span class="line"><span class="operator">  </span><span class="comment">/* Call previous handler. */</span>  </span><br><span class="line">  old_handler.sa<span class="constructor">_sigaction(<span class="params">code</span>, <span class="params">si</span>, <span class="params">sc</span>)</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某些信号可能在之前已经被安装过信号处理函数，而sigaction一个信号量只能注册一个处理函数，这意味着我们的处理函数会覆盖其他人的处理信号</p>
<p>保存旧的处理函数，在处理完我们的信号处理函数后，在重新运行老的处理函数就能完成兼容。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 与 Unity 的交互</title>
    <url>/2021/07/29/Android%E4%B8%8EUnity%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Unity</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统Binder驱动分析(1)</title>
    <url>/2021/07/29/Android%E7%B3%BB%E7%BB%9FBinder%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="提前掌握Binder的基础知识-预习"><a href="#提前掌握Binder的基础知识-预习" class="headerlink" title="提前掌握Binder的基础知识(预习)"></a>提前掌握Binder的基础知识(预习)</h1><p>Android系统架构的底层就是linux,本篇文章如有不懂的地方，建议参考<a href="http://www.linfo.org/">原文文档</a>,以便更好帮助自己学习。<br>希望能跟大家多多交流 !!!  </p>
<h2 id="Linux的基础知识"><a href="#Linux的基础知识" class="headerlink" title="Linux的基础知识"></a>Linux的基础知识</h2><p>Binder究竟是什么<br>什么是linux的系统内存<br>内核空间是什么<br>进程隔离<br>用户空间是什么</p>
<h2 id="Binder究竟是什么"><a href="#Binder究竟是什么" class="headerlink" title="Binder究竟是什么"></a>Binder究竟是什么</h2><p>Binder是Android系统中负责每个<strong>用户进程</strong>与<strong>内核</strong>通信的机制(驱动)</p>
<h2 id="内核空间是什么"><a href="#内核空间是什么" class="headerlink" title="内核空间是什么"></a>内核空间是什么</h2><p><a href="http://www.linfo.org/kernel_space.html">内核空间</a></p>
<blockquote>
<p>System memory in Linux can be divided into two distinct regions: kernel space and user space. Kernel space is where the kernel (i.e., the core of the operating system) executes (i.e., runs) and provides its services.<br>系统内存在的Linux可以分为两个不同的区域：<strong>内核空间</strong>和<strong>用户空间</strong>。内核空间是内核（即操作系统的核心）执行（即运行）并提供其服务的地方。</p>
</blockquote>
<h3 id="内核的作用是什么"><a href="#内核的作用是什么" class="headerlink" title="内核的作用是什么:"></a>内核的作用是什么:</h3><blockquote>
<p>One of the roles of the kernel is to manage individual user processes within this space and to prevent them from interfering with each other.<br>内核的作用之一是管理该空间内的各个用户进程并防止它们相互干扰。<br>这里涉及到一个概念 : <strong>进程隔离</strong></p>
</blockquote>
<h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
</blockquote>
<h4 id="内核空间的误区"><a href="#内核空间的误区" class="headerlink" title="内核空间的误区"></a>内核空间的误区</h4><blockquote>
<p>The kernel is a program that constitutes the central core of a computer operating system. It is not a process, but rather a controller of processes, and it has complete control over everything that occurs on the system. This includes managing individual user processes within user space and preventing them from interfering with each other.</p>
</blockquote>
<p>内核是构成计算机操作系统中央核心的程序。它不是一个进程，而是一个进程的控制器，它可以完全控制系统上发生的一切。这包括管理用户空间内的单个用户进程并防止它们相互干扰。</p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p><a href="http://www.linfo.org/user_space.html">用户空间</a></p>
<blockquote>
<p>User space is that portion of system memory in which user processes run<br>用户空间是用户进程在其中运行的系统内存部分</p>
</blockquote>
<h3 id="用户空间跟用户进程的区别"><a href="#用户空间跟用户进程的区别" class="headerlink" title="用户空间跟用户进程的区别"></a>用户空间跟用户进程的区别</h3><blockquote>
<p> User space is that set of memory locations in which user processes (i.e., everything other than the kernel) run<br>用户空间是一组内存位置，用户进程（即内核以外的所有东西）在其中运行。<br>每个正在运行的App都是一个用户进程,再不干涉的情景下，互相独立互不影响，都有属于自己的进程的用户空间。</p>
</blockquote>
<h2 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用/内核态/用户态"></a>系统调用/内核态/用户态</h2><blockquote>
<p>Kernel space can be accessed by user processes only through the use of system calls<br>用户空间访问内核空间的唯一方式就是系统调用</p>
</blockquote>
<p><strong>内核态</strong> : 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行<br><strong>用户态</strong> : 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。<br>处理器在特权等级高的时候才能执行那些特权CPU指令。 </p>
<h2 id="扩展概念"><a href="#扩展概念" class="headerlink" title="扩展概念"></a>扩展概念</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用是 <strong>类 Unix</strong> 操作系统中活动进程对内核执行的服务的请求，例如输入/输出(I/O) 或进程创建。活动进程是当前在 CPU 中进行的进程，与在 CPU 中等待其下一次运行的进程相反。I/O 是将数据传入或传出 CPU 以及传入或传出外围设备（如磁盘驱动器、键盘、鼠标和打印机）的任何程序、操作或设备。<br>系统调用主要通过如下两个函数来实现:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">copy_from_user</span><span class="params">()</span></span> <span class="comment">// 将数据从用户空间拷贝到内核空间</span></span><br><span class="line"><span class="function"><span class="title">copy_to_user</span><span class="params">()</span></span> <span class="comment">// 将数据从内核空间拷贝到用户空间</span></span><br></pre></td></tr></table></figure>
<h3 id="Linux-使用两级保护机制："><a href="#Linux-使用两级保护机制：" class="headerlink" title="Linux 使用两级保护机制："></a>Linux 使用两级保护机制：</h3><p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<h3 id="Linux-内存映射"><a href="#Linux-内存映射" class="headerlink" title="Linux 内存映射"></a>Linux 内存映射</h3><p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h3 id="动态内核可加载模块"><a href="#动态内核可加载模块" class="headerlink" title="动态内核可加载模块"></a>动态内核可加载模块</h3><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。<br>它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>android-Handler机制-2</title>
    <url>/2021/07/27/android-Handler%E6%9C%BA%E5%88%B6-2/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-外挂篇</title>
    <url>/2021/07/27/android-%E5%A4%96%E6%8C%82%E7%AF%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-APK构建流程</title>
    <url>/2021/07/26/android-APK%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Apk构建流程"><a href="#Apk构建流程" class="headerlink" title="Apk构建流程"></a>Apk构建流程</h1><h2 id="Apk是什么"><a href="#Apk是什么" class="headerlink" title="Apk是什么"></a>Apk是什么</h2><h2 id="Apk构成的属性"><a href="#Apk构成的属性" class="headerlink" title="Apk构成的属性"></a>Apk构成的属性</h2><h2 id="Apk编译的流程"><a href="#Apk编译的流程" class="headerlink" title="Apk编译的流程"></a>Apk编译的流程</h2><ol>
<li>通过<strong>aapt-Android Asset Packing Tool</strong> 打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）  </li>
</ol>
<blockquote>
<p>这一过程主要是aapt对res和asset文件夹，AndroidManifest.xml，android库(aar,jar)等的资源文件进行处理。  </p>
<ul>
<li>先检查<strong>AndroidManifest.xml</strong>的合法性  </li>
<li>然后编译res与asserts目录下的资源并生成resource.arsc文件  </li>
<li>再生成R文件。</li>
</ul>
</blockquote>
<p>除了assets和res/raw资源被原封不动地打包进APK之外，其它的资源都会被编译或者处理，<em>大部分文本格式的XML资源文件会被编译成二进制格式的XML资源文件</em>。<br>除了assets资源之外，其他的资源都会在R文件中被赋予一个资源ID。也就是说，R文件中只会存在id，真正的资源存在于resource.arsc中，resource.arsc相当于一个资源索引表，资源id是key，value是资源路径。我们使用drawable-xdpi或者drawable-xxdpi这些不同分辨率的图片的时候，就是依靠resource.arsc根据设备的分辨率选择不同的图片</p>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/20190915004258.png" alt="R.java"><br> (R.java相关知识)<br>2. 处理.aidl文件，生成对应的Java接口文件<br>3. 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 (编译期超出64k?)<br>4. 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex<br>5. 通过<strong>Japkbuilder</strong>J工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk<br>6. 通过<strong>Jarsigner</strong>工具，对上面的apk进行debug或release签名<br>通过zipalign工具，将签名后的apk进行对齐处理<br>(引申出问题，为什么需要签名，签名的方式有几种，有什么区别？)<br>7. 通过<strong>zipalign</strong>工具，将签名后的apk进行对齐处理<br>(引申一个问题，为什么需要对齐？)<br>8. 混淆proguard：proguard主要的目的是混淆代码，保护应用源代码。次要的功能还有移除无用类等，优化字节码，缩小包体积。  </p>
<h1 id="APK扩展性问题"><a href="#APK扩展性问题" class="headerlink" title="APK扩展性问题:"></a>APK扩展性问题:</h1><h2 id="Android十万个为什么"><a href="#Android十万个为什么" class="headerlink" title="Android十万个为什么"></a>Android十万个为什么</h2><h3 id="1-R-java是什么-R-java构成"><a href="#1-R-java是什么-R-java构成" class="headerlink" title="1. R.java是什么(R.java构成)"></a>1. <em>R.java是什么(R.java构成)</em></h3><blockquote>
<p>R.java由ADT(aapt)编译生成，<br>记录应用apk-res路径所有资源，并根据这些资源建立对应的ID(生成唯一的标识符)<br>编译期间，同一个资源在普通的apk中只会属于一个<strong>package</strong>，一个<strong>type</strong>，只拥有一个<strong>entry次序</strong>。<br>以0x01开头的就是系统已经内置的资源id，以0x7f开头的是咱们自己添加的app资源id </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/oubindo/ImageBed/master/img/%E8%B5%84%E6%BA%90id.png" alt="R.java"> </p>
<blockquote>
<p>由于项目开发是多模块的开发 - 编译期相关的知识</p>
<ul>
<li>主模块中的R.java中的字段以final修饰，以常量形式存在。  </li>
<li>库模块中的R.java中的字段不以final修饰，以变量形式被项目中的代码所引用。  </li>
</ul>
</blockquote>
<h4 id="Android资源的合并"><a href="#Android资源的合并" class="headerlink" title="Android资源的合并"></a>Android资源的合并</h4><blockquote>
<p>覆盖的优先级如下：<br>build variant &gt; build type &gt; product flavor &gt; main source set &gt; library dependences</p>
</blockquote>
<blockquote>
<p>这种依赖关系不同于gradle里面的implementation依赖传递，implementation是跨级不能传递，但是R文件的生成是跨级可以传递的。<br>module的R文件数 = 依赖的module/aar数量 + 1(自身的R文件)<br>R.文件的生成是底层到上层 </p>
</blockquote>
<h3 id="为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？"><a href="#为什么主模块-application-module-资源有final修饰，非主模块-library-module-都不是final的？" class="headerlink" title="为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？"></a>为什么主模块(application module)资源有final修饰，非主模块(library module)都不是final的？</h3><blockquote>
<p><em>比较早的aapt的版本生成的非主模块的资源id确实都是final修饰的，这样会带来一个问题，这些资源id全部内联到代码中，一旦新增或者删除，修改了资源，资源id就会有变化，所有的代码都需要重新编译，造成严重的编译耗时</em>。  </p>
</blockquote>
<p>后来改为主模块final常量方式内联，非主模块引用方式，这样等按照从下到上编译到App模块的时候，所有的资源id都已经确定了，底层模块的资源只需要通过引用就能拿到自己对应的id，而修改(新增，删除，修改)了资源之后，也只需要重新生成R文件就好了。编译耗时大大减少。</p>
<p>在我们平常打包的时候，反编译apk，再合并资源回编时，也是要重新生成R文件。  </p>
<p>开发时，在其他module代码引用资源文件时,使用以下代码进行索引  </p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return a resource identifier <span class="keyword">for</span> <span class="keyword">the</span> <span class="keyword">given</span> resource <span class="built_in">name</span>.  A fully</span><br><span class="line"> * qualified resource <span class="built_in">name</span> <span class="keyword">is</span> <span class="keyword">of</span> <span class="keyword">the</span> form <span class="string">&quot;package:type/entry&quot;</span>.  The <span class="keyword">first</span></span><br><span class="line"> * two components (package <span class="keyword">and</span> type) are optional <span class="keyword">if</span> defType <span class="keyword">and</span></span><br><span class="line"> * defPackage, respectively, are specified here.</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;Note: use <span class="keyword">of</span> this function <span class="keyword">is</span> discouraged.  It <span class="keyword">is</span> much more</span><br><span class="line"> * efficient <span class="keyword">to</span> retrieve resources <span class="keyword">by</span> identifier than <span class="keyword">by</span> <span class="built_in">name</span>.</span><br><span class="line"> * </span><br><span class="line"> * @param <span class="built_in">name</span> The <span class="built_in">name</span> <span class="keyword">of</span> <span class="keyword">the</span> desired resource.</span><br><span class="line"> * @param defType Optional default resource type <span class="keyword">to</span> find, <span class="keyword">if</span> <span class="string">&quot;type/&quot;</span> <span class="keyword">is</span></span><br><span class="line"> *                <span class="keyword">not</span> included <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">name</span>.  Can be null <span class="keyword">to</span> require an</span><br><span class="line"> *                explicit type.</span><br><span class="line"> * @param defPackage Optional default package <span class="keyword">to</span> find, <span class="keyword">if</span> <span class="string">&quot;package:&quot;</span> <span class="keyword">is</span></span><br><span class="line"> *                   <span class="keyword">not</span> included <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">name</span>.  Can be null <span class="keyword">to</span> require an</span><br><span class="line"> *                   explicit package.</span><br><span class="line"> * </span><br><span class="line"> * @<span class="literal">return</span> int The associated resource identifier.  Returns <span class="number">0</span> <span class="keyword">if</span> no such</span><br><span class="line"> *         resource was found.  (<span class="number">0</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid resource ID.)</span><br><span class="line"> */</span><br><span class="line">public int getIdentifier(String <span class="built_in">name</span>, String defType, String defPackage) &#123;</span><br><span class="line"><span class="built_in">    return</span> mResourcesImpl.getIdentifier(<span class="built_in">name</span>, defType, defPackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？"><a href="#为什么同一个资源，不同模块产生的R-java中的资源id值是不统一的？" class="headerlink" title="为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？"></a>为什么同一个资源，不同模块产生的R.java中的资源id值是不统一的？</h3><p>因为资源id只是表示资源的次序，而不是别的跟资源本身绑定的属性。当到了不同的模块以后，参与编译的资源变多了，那次序肯定会改变。资源id也就改变了。并且子模块的资源id只是引用形式存在于代码中，id具体是什么值并不是很care。</p>
<h3 id="apk或者aab，为什么需要对齐？"><a href="#apk或者aab，为什么需要对齐？" class="headerlink" title="apk或者aab，为什么需要对齐？"></a><em>apk或者aab</em>，为什么需要对齐？</h3><blockquote>
<p>zipalign的主要工作是将apk包进行对齐处理，使apk包中的所有资源文件举例文件起始偏移为4字节的整数倍，这样通过内存映射访问apk时的速度会更快。<br>为什么快呢？如果每个资源的开始位置上都是一个资源之后的4n字节，那么访问下一个资源就不用遍历，直接跳到4字节之后即可 </p>
</blockquote>
<h3 id="apk或者aab混淆的方式有哪些"><a href="#apk或者aab混淆的方式有哪些" class="headerlink" title="apk或者aab混淆的方式有哪些()"></a><em>apk或者aab</em>混淆的方式有哪些()</h3><blockquote>
</blockquote>
<p>压缩(Shrink)：检测并移除代码中无用的类、字段、方法和特性<br>优化(Optimize)：字节码进行优化，移除无用的指令。<br>混淆(Obfuscate)：使用a、b、c、d这样简短而无意义的名称，对垒、字段和方法进行重命名。<br>预检测(Preveirfy)：在Java平台对处理后的代码进行预检测，确保加载class文件是可执行的 </p>
<h3 id="“Android”-64k报错"><a href="#“Android”-64k报错" class="headerlink" title="“Android” 64k报错"></a>“Android” 64k报错</h3><p>应用及第三方库包含的方法数(method)总和超过65536，在开发的时候，会遇到一个构建的错误。<br>指明您的应用达到Android构建规定的应用的限制：</p>
<h4 id="构建错误的原因"><a href="#构建错误的原因" class="headerlink" title="构建错误的原因:"></a>构建错误的原因:</h4><h5 id="dex文件格式的限制"><a href="#dex文件格式的限制" class="headerlink" title="dex文件格式的限制"></a>dex文件格式的限制</h5><p>Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 二进制文件形式的可执行字节码文件，这些文件包含用来运行应用的已编译代码。<br>Dalvik Executable 规范将可在单个 DEX 文件内引用的方法总数限制为 65536 (其中包括 Android 框架方法、库方法以及您自己的代码中的方法)</p>
<h5 id="其他限制"><a href="#其他限制" class="headerlink" title="其他限制"></a>其他限制</h5><p>系统对dex文件进行优化操作时分配的缓冲区大小的限制 ，方法如果超出缓存区，同样也是会报错的。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Handle---消息分发机制</title>
    <url>/2021/07/26/android-Handler%E6%9C%BA%E5%88%B6-1/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="left">Class</th>
<th align="center">Name</th>
<th align="left">DES</th>
<th align="left">MORE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Message</td>
<td align="center">消息</td>
<td align="left">使用了享元设计模式 链表的数据结构</td>
<td align="left">详情</td>
</tr>
<tr>
<td align="left">MessageQuene</td>
<td align="center">消息队列</td>
<td align="left">单链表的数据结构</td>
<td align="left">优先级的队列 — 根据时间先后顺序排队的单链表</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="center">message的处理者</td>
<td align="left">即线程间传递的对象，传递的信息包含在其中    Handler的构造函 ，在构造函数中初始化了一个Looper 和 MessageQueue。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ThreadLocal</td>
<td align="center">数据结构是键值对</td>
<td align="left">只有在指定的线程可以获取到存储的数据</td>
<td align="left">获取线程唯一的变量 Theadlocal value 线程内部的数据存储类,使用场景：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本</td>
</tr>
<tr>
<td align="left">Looper</td>
<td align="center">循环器</td>
<td align="left"><img src="code_looper_1.jpg" alt="code_looper"></td>
<td align="left">类Looper的prepare的函数,即是对Looper进行了初始化，将Looper对象引用保存在sThreadLocal中，先保证了Looper和Threadlocal-1V1关系,由于sThreadLocal获取的值是通过获取当前线程获取线程唯一的变量,这样就保证了一个线程只有一个looper</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo CMD</title>
    <url>/2021/07/19/hexo/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;博客名称&quot;</span>  =&gt; hexo <span class="keyword">new</span> <span class="string">&quot;博客名称&quot;</span>   <span class="meta">#这两个都是创建新文章，前者是简写模式</span></span><br><span class="line">hexo p  =&gt; hexo publish</span><br><span class="line">hexo g  =&gt; hexo generate  <span class="meta">#生成</span></span><br><span class="line">hexo s  =&gt; hexo <span class="keyword">server</span>  <span class="meta">#启动服务预览</span></span><br><span class="line">hexo d  =&gt; hexo deploy  <span class="meta">#部署  </span></span><br><span class="line"></span><br><span class="line">hexo <span class="keyword">server</span>   <span class="meta">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span></span><br><span class="line">hexo <span class="keyword">server</span> -s   <span class="meta">#静态模式</span></span><br><span class="line">hexo <span class="keyword">server</span> -p <span class="number">5000</span>   <span class="meta">#更改端口</span></span><br><span class="line">hexo <span class="keyword">server</span> -i <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>   <span class="meta">#自定义IP</span></span><br><span class="line">hexo clean   <span class="meta">#清除缓存，网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g   <span class="meta">#生成静态网页</span></span><br><span class="line">hexo d   <span class="meta">#开始部署</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android App Bundles</title>
    <url>/2021/07/19/google-aab/</url>
    <content><![CDATA[<h1 id="Google-Android-App-Bundles"><a href="#Google-Android-App-Bundles" class="headerlink" title="Google - Android App Bundles"></a>Google - Android App Bundles</h1><p>2018 年的 Google I/O ，Google 向 Android 引入了新 App 动态化框架（即 Android App Bundle，缩写为<strong>AAB</strong>)</p>
<blockquote>
<p>App 动态化框架，动态化概念指的是 Play Dynamic Delivery </p>
<blockquote>
<p><strong>上线要求</strong>:从 2021 年 8 月起，新应用需要使用 Android App Bundle 才能在 Google Play 中发布。  </p>
</blockquote>
</blockquote>
<h2 id="About-Android-App-Bundles"><a href="#About-Android-App-Bundles" class="headerlink" title="About Android App Bundles"></a>About Android App Bundles</h2><blockquote>
<p>Android App Bundle 是一种包含编译后代码和资源文件的新的上传格式（.aab） </p>
</blockquote>
<p>补充:<strong>Android Application Bundle</strong> != <strong>Apk</strong><br>App Bundle 纯粹是为了上传设计的文件，用户无法直接安装和使用它。<br>虽然AAB和Apk本质上都是压缩包,但是内部的目录结构完全不同，以下是一个Abb正常的aab文件结构</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">–BundleConfig.pb ： 打包bundle的时候，自动生成</span><br><span class="line">–base : base目录</span><br><span class="line"><span class="section">——assets: 对应apk的assets目录</span></span><br><span class="line"><span class="section">——dex: 原apk中classes.dex,classes2.dex…都放这里</span></span><br><span class="line"><span class="section">——lib: 原apk中lib目录都放这里</span></span><br><span class="line"><span class="section">——manifest: 原apk的AndroidManifest.xml放这里，需要是编译后的AndroidManifest.xml</span></span><br><span class="line">——res：apk中的资源放这里，需要是编译后的资源</span><br><span class="line"><span class="section">——root: apk中相对于根目录的其他资源文件</span></span><br><span class="line">——resources.pb：编译资源的时候会生成的</span><br><span class="line"><span class="section">——assets.pb:编译bundle的时候会生成的</span></span><br><span class="line"><span class="section">——native.pb: 编译bundle的时候会生成的</span></span><br></pre></td></tr></table></figure>

<h2 id="Google-Play-Dynamic-Delivery"><a href="#Google-Play-Dynamic-Delivery" class="headerlink" title="Google Play Dynamic Delivery"></a>Google Play Dynamic Delivery</h2><blockquote>
<p>简介:Google Play 推出新 app 交付模式，叫做动态交付 (Dynamic Delivery)，它根据每个用户的设备信息，使用开发者上传的 app bundle 来生成对应的 apk 文件。</p>
<blockquote>
<p><img src="https://conorlee.top/images/blogimages/2019/640.gif" alt="AAB">  </p>
</blockquote>
</blockquote>
<h2 id="Play-Asset-Delivery"><a href="#Play-Asset-Delivery" class="headerlink" title="Play Asset Delivery"></a>Play Asset Delivery</h2><blockquote>
<p>Play Asset Delivery (PAD)可以让依靠 Google Play 来托管和提供你的资产包，PAD提供灵活的分发模式，本质上减少包的体积，让用户更佳的体验,目前分发模式有3种，分别为<br><strong>1.install-time 2.fast-follow 3.on-demand</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分发模式</th>
<th align="center">大小限制</th>
<th align="left">简介</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left">install-time  =&gt; 安装时分发</td>
<td align="center">总下载大小上限为1GB</td>
<td align="left">资源包在用户安装应用时进行分发，”预先”资源包</td>
<td align="left">在应用启动是使用，用户无法修改或删除这些资源包</td>
</tr>
<tr>
<td align="left">fast-follow =&gt; 快速跟进式分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包在用户安装应用后立即自动下载</td>
<td align="left">用户无需打开应用即可开始 fast-follow 下载。此类下载不会阻止用户访问应用。</td>
</tr>
<tr>
<td align="left">on-demand =&gt; 按需分发</td>
<td align="center">下载大小上限为512MB</td>
<td align="left">资源包会在应用运行时进行下载</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意 ！！！</strong>：如果为资源包选择 <strong>install-time 分发类型</strong>，就无需在游戏中使用 <strong>Play Asset Delivery API</strong>。这些资源包与主应用 APK同时安装。<br>目前公司项目使用就是分发模式就是 <strong>install-time</strong></p>
<p>由于google规定需要apk&lt;150m，等于aab中的base目录&lt;150m，如果超出限制，需要把多出的资源迁移到install-time，让google去动态下发资源</p>
<h1 id="软件使用说明"><a href="#软件使用说明" class="headerlink" title="软件使用说明"></a>软件使用说明</h1><h3 id="需要提前安装的环境"><a href="#需要提前安装的环境" class="headerlink" title="需要提前安装的环境"></a>需要提前安装的环境</h3><ul>
<li>需要自己额外再安装的路径  <ol>
<li>python3</li>
<li>aapt  </li>
<li>gradle </li>
<li>as-pro  ==&gt; 模板工程 </li>
</ol>
</li>
<li>该工具内置了反编译的环境 请勿随意修改路径  <ol>
<li>apktool  </li>
<li>dex2jar  </li>
<li>smali  </li>
</ol>
</li>
</ul>
<p>2 需要在该工具路径下/tool/apktool/signature/config/apk.ini文件配置以下路径</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置项 后续看项目的需求支持可增加参数</span></span><br><span class="line">[config]</span><br><span class="line"><span class="comment"># 注意所有配置项需要顶行写，&quot;=&quot; 号两边和行首尾不能有空格</span></span><br><span class="line"><span class="comment"># AS 路径 </span></span><br><span class="line">as_path=<span class="regexp">/Users/</span>zhupengbo<span class="regexp">/Desktop/</span>S3/S3_Hw</span><br><span class="line"><span class="comment"># AAB 生成的路径 必填</span></span><br><span class="line">abb_path=<span class="regexp">/Users/</span>zhupengbo<span class="regexp">/tool/</span>apktool<span class="regexp">/apk/</span>abb</span><br><span class="line"><span class="comment"># 版本号和版本名</span></span><br><span class="line">versionCode=<span class="number">1</span></span><br><span class="line">versionName=<span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.该项目增加了pad配置表<br>3.1 <strong>aab_pad.xls</strong> 配置表路径在 <strong>/apktool/signature/config</strong> 的路径下<br>3.2 配置的方法<br>支持配置<strong>文件路径</strong>和<strong>文件夹</strong><br>S3项目以resource路径下进行配表，该路径包含了游戏内的资源  </p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">配置形式为<span class="symbol">:resource/</span>路径</span><br></pre></td></tr></table></figure>

<p><strong>aab_pad.xls 格式如下-示例</strong></p>
<table>
<thead>
<tr>
<th align="left">Path</th>
</tr>
</thead>
<tbody><tr>
<td align="left">resource/model</td>
</tr>
<tr>
<td align="left">resource/Video</td>
</tr>
<tr>
<td align="left">resource/allRes.json</td>
</tr>
<tr>
<td align="left">resource/ui</td>
</tr>
</tbody></table>
<p>4 该工具支持下终端下执行，调用示例</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>zhupengbo<span class="regexp">/tool/</span>apktool<span class="regexp">/android_pack.sh /</span>Users<span class="regexp">/zhupengbo/</span>tool<span class="regexp">/apktool/</span>apk<span class="regexp">/apk/</span>AAA.apk</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
</search>
